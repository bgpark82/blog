{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":1,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":1,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":1,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1661007307560},{"_id":"source/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1661007307560},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1661007307587},{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1661007307587},{"_id":"source/tags/index.md","hash":"9d558ce28d0d44c3463517088689bbca44bbb364","modified":1661007307587},{"_id":"source/archive/index.md","hash":"279ff19668395f5c6b26417da99d2c1f3ecd5886","modified":1661007307566},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1661007307583},{"_id":"source/_posts/1-Two-Sum.md","hash":"24986f09f2bc5a6e6660afee7e29cedb9011624d","modified":1665411684818},{"_id":"source/_posts/102-Binary-Tree-Level-Order-Traversal.md","hash":"f2b8e538dbbb4e65ecc5c5d574de979ce4af2f2a","modified":1664777832469},{"_id":"source/about/index.md","hash":"ebca34cfe8d13ec641d17fcfec0127a966338f8e","modified":1661007307566},{"_id":"source/_posts/100-Same-Tree.md","hash":"14a7c64153dd13d795641a368567caa21df04354","modified":1663990319099},{"_id":"source/_posts/11-Container-With-Most-Water.md","hash":"28b50299b06f61bbee70f2c000b719a4fe7dd974","modified":1665481900792},{"_id":"source/_posts/1048-Longest-String-Chain.md","hash":"7b6feb80a0ca60e06f2d65d4f9a83a93ec3d3bb9","modified":1666786860582},{"_id":"source/_posts/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.md","hash":"92086e6f71190cf7e30192d7688f35abe4aa42c9","modified":1664781701575},{"_id":"source/_posts/104-Maximum-Depth-of-Binary-Tree.md","hash":"8644c4d2c6e426f7e9366dbcecfd450cabe34d21","modified":1666094904898},{"_id":"source/_posts/11111-test.md","hash":"81eee391c4bfa676dae4f6bc436f384c81b979bb","modified":1665672199258},{"_id":"source/_posts/121-Best-Time-to-Buy-and-Sell-Stock.md","hash":"b058617ea3550f7db4fa4f90e2ad1fcb6ad923b3","modified":1666094057748},{"_id":"source/_posts/118-Pascal-s-Triangle.md","hash":"63bc8bb8cc662d41f5dde9009cfeb88293e2cb56","modified":1667211891356},{"_id":"source/_posts/1143-Longest-Common-Subsequence.md","hash":"808ebc25695fb0554c9f8e274d1dc50569f1bd14","modified":1662882019755},{"_id":"source/_posts/133-Clone-Graph.md","hash":"ac5d88c2d0b80fad2452fa6b458c9ef740360678","modified":1664970588525},{"_id":"source/_posts/128-Longest-Consecutive-Sequence.md","hash":"a517f3d6e03139d1f5f297ef5b4f0fddb187c439","modified":1663238831929},{"_id":"source/_posts/136-Single-Number.md","hash":"c2052b8db683b12e7b3ef0c31b1815725a541bb1","modified":1666535995758},{"_id":"source/_posts/139-Word-Break.md","hash":"081ea0611f079073c2d80a82f341314d598fce5a","modified":1666428060521},{"_id":"source/_posts/125-Valid-Palindrome.md","hash":"17bd1ea480865774f8950a20bb820c33181b9ff2","modified":1666024706727},{"_id":"source/_posts/141-Linked-List-Cycle.md","hash":"1f327b43ffea32e08d06ca84c854ebdb09d350e7","modified":1663929908369},{"_id":"source/_posts/152-Maximum-Product-Subarray.md","hash":"7cb5ccb930fbac616b3f435475ff1aca20c1e269","modified":1664708032682},{"_id":"source/_posts/15-3Sum.md","hash":"1905e61f793c2da9c2d17efe0fc35a626e19e932","modified":1665840205854},{"_id":"source/_posts/153-Find-Minimum-in-Rotated-Sorted-Array.md","hash":"ef79722ce7ae15efd1ff4b1c95b8f36a87e07395","modified":1663408132100},{"_id":"source/_posts/143-Reorder-List.md","hash":"00f2f7c0a9c8a1d6a78bba5a1035a12625a61b4b","modified":1664764463012},{"_id":"source/_posts/1903-Largest-Odd-Number-in-String.md","hash":"e298bc6da2b8cef2b1bbf78d4669f6a78b19eba2","modified":1666620265460},{"_id":"source/_posts/1624-Largest-Substring-Between-Two-Equal-Characters.md","hash":"919fe2a5b546924fda70f55af739c14b0f2d4489","modified":1666624034990},{"_id":"source/_posts/19-Remove-Nth-Node-From-End-of-List.md","hash":"068c8e1efcced11435b1288b7f160ad96dd5778b","modified":1665217006714},{"_id":"source/_posts/190-Reverse-Bits.md","hash":"7644fdf35bbd30fbf0e73c43420470e33c1fbca9","modified":1664690397627},{"_id":"source/_posts/191-Number-of-1-Bits.md","hash":"00733927fdae10e5a75a468e1e5251408459b036","modified":1663999775217},{"_id":"source/_posts/198-House-Robber.md","hash":"71f412428489150e1ba30bce975d6442e809e00e","modified":1664638912704},{"_id":"source/_posts/20-Valid-Parentheses.md","hash":"2a3458621ae289017bda33489046ddcf3c7e720a","modified":1663064873500},{"_id":"source/_posts/206-Reverse-Linked-List.md","hash":"f6fbbe6efcfa9039380c06427e67ae9c2bcfaced","modified":1664596016251},{"_id":"source/_posts/200-Number-of-Islands.md","hash":"49639dfe49b89b26ec9583b79b8263ba80cb4296","modified":1663760394969},{"_id":"source/_posts/211-Design-Add-and-Search-Words-Data-Structure.md","hash":"d0278f9238596694f92df4d1b76e8dbba0bc36bd","modified":1664195043558},{"_id":"source/_posts/207-Course-Schedule.md","hash":"26d0b2306ddfac9f9376764c2a8026cf2932f4b6","modified":1664088248085},{"_id":"source/_posts/208-Implement-Trie-Prefix-Tree.md","hash":"08a68cb94930a47a8d968ce86f5538c15a65a8a8","modified":1664686863418},{"_id":"source/_posts/21-Merge-Two-Sorted-Lists.md","hash":"86efc603f97eeff0a14de7e1469db3498d05ca31","modified":1665205057257},{"_id":"source/_posts/22-Generate-Parentheses.md","hash":"bef27b20e2fdc1cde2c647a7856293274174ced8","modified":1667301054266},{"_id":"source/_posts/217-Contains-Duplicate.md","hash":"1e6e53ee24d9eb77b719bd51737318f631dcf9f8","modified":1666085130983},{"_id":"source/_posts/226-Invert-Binary-Tree.md","hash":"11b9f9d2a74222816c09df3423d51e97fc805cc9","modified":1666082922697},{"_id":"source/_posts/212-Word-Search-II.md","hash":"a9b48ad7b1517d1de3c38a33266041163542c31e","modified":1663598413735},{"_id":"source/_posts/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree.md","hash":"19a05b63db3f246857becde8cbb10def89fd4a42","modified":1664113963358},{"_id":"source/_posts/268-Missing-Number.md","hash":"123565dc38574b270a040b001de7f01e663ce177","modified":1663837591298},{"_id":"source/_posts/230-Kth-Smallest-Element-in-a-BST.md","hash":"97eebbeba89bece9f31b607cfe330cd262925877","modified":1664676477226},{"_id":"source/_posts/238-Product-of-Array-Except-Self.md","hash":"e4c4524d9c8dc59d62d6814ca7704306f0c6d869","modified":1664537610895},{"_id":"source/_posts/236-Lowest-Common-Ancestor-of-a-Binary-Tree.md","hash":"6c4c8cde1226ff56df9cf1922b621c59dcca1aa9","modified":1664592909257},{"_id":"source/_posts/3-Longest-Substring-Without-Repeating-Characters.md","hash":"6ae73539831773ae4f6fc456742b0a3f9a314278","modified":1665486958693},{"_id":"source/_posts/322-Coin-Change.md","hash":"c5b3006a3409d3eb7adaf125fba591232ca25ee2","modified":1664533761698},{"_id":"source/_posts/33-Search-in-Rotated-Sorted-Array-1.md","hash":"eb671def9b6c75d976aad58e153d2ad6f239dc6d","modified":1665892016955},{"_id":"source/_posts/300-Longest-Increasing-Subsequence.md","hash":"576273b2adf152a7e7f907afd3a30b020dbb7848","modified":1666271341195},{"_id":"source/_posts/338-Counting-Bits.md","hash":"f3568026fff0d74d592d841a9d2418ff455191b5","modified":1666265679114},{"_id":"source/_posts/33-Search-in-Rotated-Sorted-Array.md","hash":"0d9e22517d9ecef67984ec506f6e87062d91dfb1","modified":1665892216286},{"_id":"source/_posts/347-Top-K-Frequent-Elements.md","hash":"d551aef530ef0ec13a096ca4177cb248fb5d697c","modified":1664279025718},{"_id":"source/_posts/39-Combination-Sum.md","hash":"3997f2937d61381164a32cf149746a91aa81af4f","modified":1662791783798},{"_id":"source/_posts/424-Longest-Repeating-Character-Replacement.md","hash":"c7618e6bdc616975f63d8d61259cf0cde6599343","modified":1663062543172},{"_id":"source/_posts/412-Fizz-Buzz.md","hash":"c841b96b969d21c0239006c364dd18549a036489","modified":1667296968690},{"_id":"source/_posts/435-Non-overlapping-Intervals.md","hash":"ca91ec1893c96ea79c09f55e827f7624465d71df","modified":1664365834979},{"_id":"source/_posts/417-Pacific-Atlantic-Water-Flow.md","hash":"5b4468dc246e687cefee26ff00084bc9d7d52c37","modified":1664415071105},{"_id":"source/_posts/46-Permutations.md","hash":"87afe9e20c974b6b83b15de27e6f495f174be117","modified":1667220465787},{"_id":"source/_posts/48-Rotate-Image.md","hash":"243e9b0b3ecfad9985532c22e8235bdefa10224c","modified":1663085185277},{"_id":"source/_posts/449-Serialize-and-Deserialize-BST.md","hash":"a2842dcc5c0d0b6771fbbb548d34fae94c168a56","modified":1663988206003},{"_id":"source/_posts/49-Group-Anagrams.md","hash":"36b770c1bcfd10a697a0ef28ef7e4caaa02f0484","modified":1663162262809},{"_id":"source/_posts/53-Maximum-Subarray.md","hash":"b86196612a4be92d3ed537543da4e1f4145d1307","modified":1666422887575},{"_id":"source/_posts/5-Longest-Palindromic-Substring.md","hash":"02d250d93a075e23dd24772cadba0b09d82a2f98","modified":1665298493663},{"_id":"source/_posts/371-Sum-of-Two-Integers.md","hash":"f163c71434d487fcffca1976f1f88b920da7fb84","modified":1663932988055},{"_id":"source/_posts/55-Jump-Game.md","hash":"3e8cd015990d3105d080083d3929da4a9abf1d1a","modified":1663331536380},{"_id":"source/_posts/54-Spiral-Matrix.md","hash":"a13d6b666cc1dff099e57b5338744e76212a1fc7","modified":1663240798635},{"_id":"source/_posts/56-Merge-Intervals.md","hash":"ac254aa404a2ae55bbfff0cca75a5de2e970f18a","modified":1665153153220},{"_id":"source/_posts/57-Insert-Interval.md","hash":"2c8d39920c77e88c06fd4df27991ae224284829b","modified":1664074243351},{"_id":"source/_posts/62-Unique-Paths.md","hash":"767ca8a2069f008570703d8a9d65e9c6095c40a7","modified":1665066288256},{"_id":"source/_posts/572-Subtree-of-Another-Tree.md","hash":"6676c85b1be4cd91f16c8b9e9beba545ffde5eca","modified":1664328136370},{"_id":"source/_posts/659-Encode-and-Decode-Strings.md","hash":"1a10f0debb38270c6ef2c676be0d6db9f2d56598","modified":1666182438005},{"_id":"source/_posts/647-Palindromic-Substrings.md","hash":"656c7faa2b376324670eb7a33035024e0d20b5e5","modified":1662899581585},{"_id":"source/_posts/70-Climbing-Stairs.md","hash":"e5bbd37ad8feb1309d50875b5a972030ef3c4922","modified":1665894889921},{"_id":"source/_posts/79-Word-Search.md","hash":"e6f010f6e8b43e8d13f4f2f62d8f03a3804b5e36","modified":1663405881598},{"_id":"source/_posts/73-Set-Matrix-Zeroes.md","hash":"39bb5436b998ba027a213b2d3b02992b506044cd","modified":1664967010748},{"_id":"source/_posts/920-Meeting-Rooms.md","hash":"0c05d4174591cccb2417eb56fabfe06cd1d7eeca","modified":1666180043529},{"_id":"source/_posts/91-Decode-Ways.md","hash":"2c8774f941dfe8b702acd2dc3e2d14de4131aae6","modified":1666357886632},{"_id":"source/_posts/938-Range-Sum-of-BST.md","hash":"6f3a73e3f4447cc50325cffce9b9d7f0e549a8e3","modified":1663513018584},{"_id":"source/_posts/hexo-theme-beantech.md","hash":"8aa4bffe04fceed5b676692ec5cf3ea150dc1f6e","modified":1661007307561},{"_id":"source/_posts/98-Validate-Binary-Search-Tree.md","hash":"75881d849d79149152e8f22db4437f936653ed77","modified":1664892552458},{"_id":"source/_posts/9월-2일-새로운-컨텐츠.md","hash":"a774c25cb086f44c14a6e5e686a67393de23ba8b","modified":1662125906079},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1661007307587},{"_id":"source/_posts/test.md","hash":"a0d47f73129b02b0c06f2061b3ae13fa649a1b34","modified":1667135922898},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1661007307587},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1661007307587},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1661007307587},{"_id":"source/_posts/새로운-포스트.md","hash":"5250715d6edd6fcd13a39c72e430b78699951cca","modified":1661939055414},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1661007307587},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1661007307587},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1661007307587},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1661007307587},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1661007307587},{"_id":"source/_posts/img.png","hash":"8664a190fdd25898ee203e9ddb4aa5f9d8e64b85","modified":1661938874945},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1661007307588},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1661007307589},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1661007307589},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1661007307589},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1661007307589},{"_id":"themes/beantech/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1661007307589},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1661007307589},{"_id":"themes/beantech/layout/post.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1661007307589},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1661007307589},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1661007307567},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"c31863b1fa66fd915bc4913440be6c610d12af80","modified":1661007307588},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"3542d15bdf73aa59f05f566b7ecd2255e83ee370","modified":1661007307588},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1661007307588},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1661007307588},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1661007307588},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1661007307588},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1661007307588},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1661007307588},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1661007307588},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1661007307588},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1661007307588},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1661007307588},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1661007307589},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1661007307589},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1661007307589},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1661007307589},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1661007307590},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1661007307591},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1661007307591},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1661007307591},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1661007307590},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1661007307591},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1661007307591},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1661007307592},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1661007307592},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1661007307592},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1661007307592},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1661007307592},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1661007307592},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1661007307594},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1661007307594},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1661007307594},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1661007307594},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1661007307572},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1661007307584},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1661007307591},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1661007307590},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1661007307592},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1661007307594},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1661007307571},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1661007307587},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1661007307565},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1661007307590},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1661007307590},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1661007307590},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1661007307583},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1661007307586},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1661007307566},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1661007307593},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1661007307570},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1661007307582},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1661007307564},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1661007307580},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1661007307578},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1661007307575}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2022-08-20T14:55:07.560Z","updated":"2022-08-20T14:55:07.560Z","path":"404.html","title":"","comments":1,"_id":"cl9zaxc0g0000qkccpaxkmhid","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T11:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2022-08-20T14:55:07.566Z","path":"archive/index.html","_id":"cl9zaxc0y0002qkcc41xikb54","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2022-08-20T14:55:07.587Z","updated":"2022-08-20T14:55:07.587Z","path":"tags/index.html","comments":1,"_id":"cl9zaxc0z0004qkcciho0gpyz","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T19:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","updated":"2022-08-20T14:55:07.566Z","path":"about/index.html","_id":"cl9zaxc100006qkcc7513vm9p","content":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n"}],"Post":[{"title":"1. Two Sum","catalog":true,"date":"2022-10-10T14:20:53.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- return *indices of the two numbers such that they add up to `target`*\n- you may not use the *same* element twice.\n- You can return the answer in any order\n\n## Solve by hands first\n\n---\n\nwe can use HashMap to match the value and target - value. Map contains element as key and index as value. Time complexity is O(n) and space complexity is O(n)\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> m = new HashMap();\n    for(int i = 0; i < nums.length; i++) {\n        m.put(nums[i], i);\n    }\n    for(int i = 0; i < nums.length; i++) {\n        if(m.containsKey(target - nums[i])) {\n            return new int[]{m.get(target - nums[i]), i};\n        }\n    }\n    return null;\n}\n```\n\nProblem of this solution is there is chance to use the same element twice. for instance if nums is [3, 2, 4] and target is 6, it will use the 3 twice which meet the constraint. \n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> m = new HashMap();\n        for(int i = 0; i < nums.length; i++) {\n            if(m.containsKey(target - nums[i])) {\n                return new int[]{m.get(target - nums[i]), i};\n            }\n            m.put(nums[i], i);\n        }\n        return null;\n\t\t}\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/386ea77a-7fa5-41cd-9de4-94d880758a2b/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. HashMap is useful when it comes to match two values\n\n```java\nnums   2 7 11 15\ntarget 9\n----------------\nkey 2 7 11 15\nval 0 1 2  3\n----------------\n9 - 2 = 7\n9 - 7 = 2\n\n```\n","source":"_posts/1-Two-Sum.md","raw":"---\ntitle: \"1.\\_Two Sum\"\ncatalog: true\ndate: 2022-10-10 23:20:53\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- return *indices of the two numbers such that they add up to `target`*\n- you may not use the *same* element twice.\n- You can return the answer in any order\n\n## Solve by hands first\n\n---\n\nwe can use HashMap to match the value and target - value. Map contains element as key and index as value. Time complexity is O(n) and space complexity is O(n)\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> m = new HashMap();\n    for(int i = 0; i < nums.length; i++) {\n        m.put(nums[i], i);\n    }\n    for(int i = 0; i < nums.length; i++) {\n        if(m.containsKey(target - nums[i])) {\n            return new int[]{m.get(target - nums[i]), i};\n        }\n    }\n    return null;\n}\n```\n\nProblem of this solution is there is chance to use the same element twice. for instance if nums is [3, 2, 4] and target is 6, it will use the 3 twice which meet the constraint. \n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> m = new HashMap();\n        for(int i = 0; i < nums.length; i++) {\n            if(m.containsKey(target - nums[i])) {\n                return new int[]{m.get(target - nums[i]), i};\n            }\n            m.put(nums[i], i);\n        }\n        return null;\n\t\t}\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/386ea77a-7fa5-41cd-9de4-94d880758a2b/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. HashMap is useful when it comes to match two values\n\n```java\nnums   2 7 11 15\ntarget 9\n----------------\nkey 2 7 11 15\nval 0 1 2  3\n----------------\n9 - 2 = 7\n9 - 7 = 2\n\n```\n","slug":"1-Two-Sum","published":1,"updated":"2022-10-10T14:21:24.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc0w0001qkcchi7wvxnv","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>return <em>indices of the two numbers such that they add up to <code>target</code></em></li>\n<li>you may not use the <em>same</em> element twice.</li>\n<li>You can return the answer in any order</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can use HashMap to match the value and target - value. Map contains element as key and index as value. Time complexity is O(n) and space complexity is O(n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        m.put(nums[i], i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;m.get(target - nums[i]), i&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Problem of this solution is there is chance to use the same element twice. for instance if nums is [3, 2, 4] and target is 6, it will use the 3 twice which meet the constraint.</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;m.get(target - nums[i]), i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/386ea77a-7fa5-41cd-9de4-94d880758a2b/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>HashMap is useful when it comes to match two values</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums   <span class=\"number\">2</span> <span class=\"number\">7</span> <span class=\"number\">11</span> <span class=\"number\">15</span></span><br><span class=\"line\">target <span class=\"number\">9</span></span><br><span class=\"line\">----------------</span><br><span class=\"line\">key <span class=\"number\">2</span> <span class=\"number\">7</span> <span class=\"number\">11</span> <span class=\"number\">15</span></span><br><span class=\"line\">val <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span>  <span class=\"number\">3</span></span><br><span class=\"line\">----------------</span><br><span class=\"line\"><span class=\"number\">9</span> - <span class=\"number\">2</span> = <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">9</span> - <span class=\"number\">7</span> = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>return <em>indices of the two numbers such that they add up to <code>target</code></em></li>\n<li>you may not use the <em>same</em> element twice.</li>\n<li>You can return the answer in any order</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can use HashMap to match the value and target - value. Map contains element as key and index as value. Time complexity is O(n) and space complexity is O(n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        m.put(nums[i], i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;m.get(target - nums[i]), i&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Problem of this solution is there is chance to use the same element twice. for instance if nums is [3, 2, 4] and target is 6, it will use the 3 twice which meet the constraint.</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;m.get(target - nums[i]), i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/386ea77a-7fa5-41cd-9de4-94d880758a2b/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>HashMap is useful when it comes to match two values</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums   <span class=\"number\">2</span> <span class=\"number\">7</span> <span class=\"number\">11</span> <span class=\"number\">15</span></span><br><span class=\"line\">target <span class=\"number\">9</span></span><br><span class=\"line\">----------------</span><br><span class=\"line\">key <span class=\"number\">2</span> <span class=\"number\">7</span> <span class=\"number\">11</span> <span class=\"number\">15</span></span><br><span class=\"line\">val <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span>  <span class=\"number\">3</span></span><br><span class=\"line\">----------------</span><br><span class=\"line\"><span class=\"number\">9</span> - <span class=\"number\">2</span> = <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">9</span> - <span class=\"number\">7</span> = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n"},{"title":"102. Binary Tree Level Order Traversal","catalog":true,"date":"2022-10-03T06:16:57.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- binary tree\n- return *the level order traversal of its nodes' values*\n- from left to right, level by level\n\n## Solve by hands first\n\n---\n\nwe can use BFS algorithm. Time complexity is O(height of node)\n\nThe problem is how to I know the node in queue was in the same level. **The answer is that get the size of current queue which is the node in the same level and iterate in length of curren queue times** \n\n```java\nqueue = [1] // level 0 -> size 1 -> iterate once\nqueue = [2,3] // level 1 -> size 2 -> iterate twice\n```\n\n```java\nwhile(!q.isEmpty()) {\n    int len = q.size();\n\n    for(int i = 0; i < len; i++) {\n        TreeNode node = q.poll();        \n\t\t\t\tq.offer(node.left);\n        q.offer(node.right);    \n    }            \n    ans.addlurn ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6536d54e-02ff-4b64-9ef6-116b55ffe9aa/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Mark the same level in queue\n    - Iterate length of current queue size times\n    \n    ```java\n    while(!q.isEmpty()) {\n        int len = q.size();\n    \n        for(int i = 0; i < len; i++) {\n            TreeNode node = q.poll();        \n    \t\t\t\tq.offer(node.left);\n            q.offer(node.right);    \n        }            \n        ans.add(list);\n    }\n    ```ist);\n}\n```\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> ans = new ArrayList();\n        \n        if(root == null) return ans;\n        \n        Queue<TreeNode> q = new ArrayDeque();\n        q.offer(root);\n        \n        while(!q.isEmpty()) {\n            int len = q.size();\n            \n            List<Integer> list = new ArrayList();\n            for(int i = 0; i < len; i++) {\n                TreeNode node = q.poll();\n                list.add(node.val);\n                \n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);    \n            }            \n            ans.add(list);\n        }\n        \n        ret(\n","source":"_posts/102-Binary-Tree-Level-Order-Traversal.md","raw":"---\ntitle: \"102.\\_Binary Tree Level Order Traversal\"\ncatalog: true\ndate: 2022-10-03 15:16:57\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- binary tree\n- return *the level order traversal of its nodes' values*\n- from left to right, level by level\n\n## Solve by hands first\n\n---\n\nwe can use BFS algorithm. Time complexity is O(height of node)\n\nThe problem is how to I know the node in queue was in the same level. **The answer is that get the size of current queue which is the node in the same level and iterate in length of curren queue times** \n\n```java\nqueue = [1] // level 0 -> size 1 -> iterate once\nqueue = [2,3] // level 1 -> size 2 -> iterate twice\n```\n\n```java\nwhile(!q.isEmpty()) {\n    int len = q.size();\n\n    for(int i = 0; i < len; i++) {\n        TreeNode node = q.poll();        \n\t\t\t\tq.offer(node.left);\n        q.offer(node.right);    \n    }            \n    ans.addlurn ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6536d54e-02ff-4b64-9ef6-116b55ffe9aa/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Mark the same level in queue\n    - Iterate length of current queue size times\n    \n    ```java\n    while(!q.isEmpty()) {\n        int len = q.size();\n    \n        for(int i = 0; i < len; i++) {\n            TreeNode node = q.poll();        \n    \t\t\t\tq.offer(node.left);\n            q.offer(node.right);    \n        }            \n        ans.add(list);\n    }\n    ```ist);\n}\n```\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> ans = new ArrayList();\n        \n        if(root == null) return ans;\n        \n        Queue<TreeNode> q = new ArrayDeque();\n        q.offer(root);\n        \n        while(!q.isEmpty()) {\n            int len = q.size();\n            \n            List<Integer> list = new ArrayList();\n            for(int i = 0; i < len; i++) {\n                TreeNode node = q.poll();\n                list.add(node.val);\n                \n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);    \n            }            \n            ans.add(list);\n        }\n        \n        ret(\n","slug":"102-Binary-Tree-Level-Order-Traversal","published":1,"updated":"2022-10-03T06:17:12.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc0y0003qkcco2442etn","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>binary tree</li>\n<li>return <em>the level order traversal of its nodes’ values</em></li>\n<li>from left to right, level by level</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can use BFS algorithm. Time complexity is O(height of node)</p>\n<p>The problem is how to I know the node in queue was in the same level. <strong>The answer is that get the size of current queue which is the node in the same level and iterate in length of curren queue times</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue = [<span class=\"number\">1</span>] <span class=\"comment\">// level 0 -&gt; size 1 -&gt; iterate once</span></span><br><span class=\"line\">queue = [<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">// level 1 -&gt; size 2 -&gt; iterate twice</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = q.size();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        TreeNode node = q.poll();        </span><br><span class=\"line\">\t\t\t\tq.offer(node.left);</span><br><span class=\"line\">        q.offer(node.right);    </span><br><span class=\"line\">    &#125;            </span><br><span class=\"line\">    ans.addlurn ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6536d54e-02ff-4b64-9ef6-116b55ffe9aa/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>Mark the same level in queue</p>\n<ul>\n<li>Iterate length of current queue size times</li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = q.size();</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            TreeNode node = q.poll();        </span><br><span class=\"line\">    \t\t\t\tq.offer(node.left);</span><br><span class=\"line\">            q.offer(node.right);    </span><br><span class=\"line\">        &#125;            </span><br><span class=\"line\">        ans.add(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ```ist);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<pre><code class=\"language-java\">class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList();\n        \n        if(root == null) return ans;\n        \n        Queue&lt;TreeNode&gt; q = new ArrayDeque();\n        q.offer(root);\n        \n        while(!q.isEmpty()) {\n            int len = q.size();\n            \n            List&lt;Integer&gt; list = new ArrayList();\n            for(int i = 0; i &lt; len; i++) {\n                TreeNode node = q.poll();\n                list.add(node.val);\n                \n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);    \n            }            \n            ans.add(list);\n        }\n        \n        ret(\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>binary tree</li>\n<li>return <em>the level order traversal of its nodes’ values</em></li>\n<li>from left to right, level by level</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can use BFS algorithm. Time complexity is O(height of node)</p>\n<p>The problem is how to I know the node in queue was in the same level. <strong>The answer is that get the size of current queue which is the node in the same level and iterate in length of curren queue times</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue = [<span class=\"number\">1</span>] <span class=\"comment\">// level 0 -&gt; size 1 -&gt; iterate once</span></span><br><span class=\"line\">queue = [<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">// level 1 -&gt; size 2 -&gt; iterate twice</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = q.size();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        TreeNode node = q.poll();        </span><br><span class=\"line\">\t\t\t\tq.offer(node.left);</span><br><span class=\"line\">        q.offer(node.right);    </span><br><span class=\"line\">    &#125;            </span><br><span class=\"line\">    ans.addlurn ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6536d54e-02ff-4b64-9ef6-116b55ffe9aa/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>Mark the same level in queue</p>\n<ul>\n<li>Iterate length of current queue size times</li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = q.size();</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            TreeNode node = q.poll();        </span><br><span class=\"line\">    \t\t\t\tq.offer(node.left);</span><br><span class=\"line\">            q.offer(node.right);    </span><br><span class=\"line\">        &#125;            </span><br><span class=\"line\">        ans.add(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ```ist);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2>Solution</h2>\n<hr>\n<pre><code class=\"language-java\">class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList();\n        \n        if(root == null) return ans;\n        \n        Queue&lt;TreeNode&gt; q = new ArrayDeque();\n        q.offer(root);\n        \n        while(!q.isEmpty()) {\n            int len = q.size();\n            \n            List&lt;Integer&gt; list = new ArrayList();\n            for(int i = 0; i &lt; len; i++) {\n                TreeNode node = q.poll();\n                list.add(node.val);\n                \n                if(node.left != null) q.offer(node.left);\n                if(node.right != null) q.offer(node.right);    \n            }            \n            ans.add(list);\n        }\n        \n        ret(\n</code></pre>\n"},{"title":"104. Maximum Depth of Binary Tree ","catalog":true,"date":"2022-10-18T12:07:59.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- return maximum depth of binary tree\n- maximum depth is the longest path from the root node to farthet leaf node\n- maximum number of nodex in the trees is between 0 to 10^4\n- range of value of node is between -100 and 100\n\n### **Edge cases**\n\n---\n\n[1, null, 2] → 2\n\n[] → 0\n\n[1] → 1\n\n[3, 9, 20, null, null, 15, 7] → 3\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nIt’s hard to use brute force way on Tree data structure\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can start with Depth First Search. Visit the left and right child node. If the node is null, return 0. Find the maximum of return value from left and right child node and **plus one as referring to one more steps**.\n\nTime complexity is O(height of binary tree)\n\n```java\npublic int maxDepth(TreeNode root) {\n    if(root == null) return 0;\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n}\n```\n\n![F97107E0-C8AF-4D10-9F58-67A0714AF800.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4191c462-eb81-4e76-ba0e-ef847e4c0ccb/F97107E0-C8AF-4D10-9F58-67A0714AF800.jpeg)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    \n\t  public int maxDepth(TreeNode root) {\n\t      if(root == null) return 0;\n\t      return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n\t  }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09618b8f-d784-46a8-a817-3c243ab46f0a/Untitled.png)\n\n### What I learned\n\n---\n","source":"_posts/104-Maximum-Depth-of-Binary-Tree.md","raw":"---\ntitle: \"104.\\_Maximum Depth of Binary Tree \"\ncatalog: true\ndate: 2022-10-18 21:07:59\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- return maximum depth of binary tree\n- maximum depth is the longest path from the root node to farthet leaf node\n- maximum number of nodex in the trees is between 0 to 10^4\n- range of value of node is between -100 and 100\n\n### **Edge cases**\n\n---\n\n[1, null, 2] → 2\n\n[] → 0\n\n[1] → 1\n\n[3, 9, 20, null, null, 15, 7] → 3\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nIt’s hard to use brute force way on Tree data structure\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can start with Depth First Search. Visit the left and right child node. If the node is null, return 0. Find the maximum of return value from left and right child node and **plus one as referring to one more steps**.\n\nTime complexity is O(height of binary tree)\n\n```java\npublic int maxDepth(TreeNode root) {\n    if(root == null) return 0;\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n}\n```\n\n![F97107E0-C8AF-4D10-9F58-67A0714AF800.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4191c462-eb81-4e76-ba0e-ef847e4c0ccb/F97107E0-C8AF-4D10-9F58-67A0714AF800.jpeg)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    \n\t  public int maxDepth(TreeNode root) {\n\t      if(root == null) return 0;\n\t      return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n\t  }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09618b8f-d784-46a8-a817-3c243ab46f0a/Untitled.png)\n\n### What I learned\n\n---\n","slug":"104-Maximum-Depth-of-Binary-Tree","published":1,"updated":"2022-10-18T12:08:24.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc0z0005qkccaixvnexb","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>return maximum depth of binary tree</li>\n<li>maximum depth is the longest path from the root node to farthet leaf node</li>\n<li>maximum number of nodex in the trees is between 0 to 10^4</li>\n<li>range of value of node is between -100 and 100</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<p>[1, null, 2] → 2</p>\n<p>[] → 0</p>\n<p>[1] → 1</p>\n<p>[3, 9, 20, null, null, 15, 7] → 3</p>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>It’s hard to use brute force way on Tree data structure</p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>We can start with Depth First Search. Visit the left and right child node. If the node is null, return 0. Find the maximum of return value from left and right child node and <strong>plus one as referring to one more steps</strong>.</p>\n<p>Time complexity is O(height of binary tree)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4191c462-eb81-4e76-ba0e-ef847e4c0ccb/F97107E0-C8AF-4D10-9F58-67A0714AF800.jpeg\" alt=\"F97107E0-C8AF-4D10-9F58-67A0714AF800.jpeg\"></p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t      <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t      <span class=\"keyword\">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09618b8f-d784-46a8-a817-3c243ab46f0a/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>return maximum depth of binary tree</li>\n<li>maximum depth is the longest path from the root node to farthet leaf node</li>\n<li>maximum number of nodex in the trees is between 0 to 10^4</li>\n<li>range of value of node is between -100 and 100</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<p>[1, null, 2] → 2</p>\n<p>[] → 0</p>\n<p>[1] → 1</p>\n<p>[3, 9, 20, null, null, 15, 7] → 3</p>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>It’s hard to use brute force way on Tree data structure</p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>We can start with Depth First Search. Visit the left and right child node. If the node is null, return 0. Find the maximum of return value from left and right child node and <strong>plus one as referring to one more steps</strong>.</p>\n<p>Time complexity is O(height of binary tree)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4191c462-eb81-4e76-ba0e-ef847e4c0ccb/F97107E0-C8AF-4D10-9F58-67A0714AF800.jpeg\" alt=\"F97107E0-C8AF-4D10-9F58-67A0714AF800.jpeg\"></p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t      <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t      <span class=\"keyword\">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09618b8f-d784-46a8-a817-3c243ab46f0a/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n"},{"title":"100. Same Tree","catalog":true,"date":"2022-09-24T03:27:51.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- two binary trees `p` and `q`\n- write a function to check if they are the same or not.\n    - structurally identical\n    - the nodes have the same value\n\n## Solve by hands first\n\n---\n\nwe need to check if both of tree are structurally identical first. it means that each node has identical child node at exact same poistion. for instance binary tree `p` only has left node then another binary tree `q` has to have left child node. \n\nsecond, we have to check if each node has same value. \n\nTime complexity is O(n)\n\n![A04630F7-8261-49BD-9313-74502FA348E6.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e49aa33-bdf2-41ad-b362-67de9f5f321e/A04630F7-8261-49BD-9313-74502FA348E6.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    } \n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5dc130f0-51d5-42e1-92b8-673b4ee15eec/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. when p and q both are null, if one of the p and q is null, **then each q and p has to be not null**. so I don’t need to check like below\n    \n    ```java\n    // before\n    if(p == null && q == null) return true;\n    if(p == null) {\n    \tif(q != null) return false;\n    }\n    if(q == null) {\n    \tif(p != null) return false;\n    }\n    ```\n    \n    ```java\n    // after\n    if(p == null && q == null) return true;\n    if(p == null || q == null) return false; \n    // when p is null then q have to be not null\n    ```\n","source":"_posts/100-Same-Tree.md","raw":"---\ntitle: \"100.\\_Same Tree\"\ncatalog: true\ndate: 2022-09-24 12:27:51\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- two binary trees `p` and `q`\n- write a function to check if they are the same or not.\n    - structurally identical\n    - the nodes have the same value\n\n## Solve by hands first\n\n---\n\nwe need to check if both of tree are structurally identical first. it means that each node has identical child node at exact same poistion. for instance binary tree `p` only has left node then another binary tree `q` has to have left child node. \n\nsecond, we have to check if each node has same value. \n\nTime complexity is O(n)\n\n![A04630F7-8261-49BD-9313-74502FA348E6.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e49aa33-bdf2-41ad-b362-67de9f5f321e/A04630F7-8261-49BD-9313-74502FA348E6.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    } \n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5dc130f0-51d5-42e1-92b8-673b4ee15eec/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. when p and q both are null, if one of the p and q is null, **then each q and p has to be not null**. so I don’t need to check like below\n    \n    ```java\n    // before\n    if(p == null && q == null) return true;\n    if(p == null) {\n    \tif(q != null) return false;\n    }\n    if(q == null) {\n    \tif(p != null) return false;\n    }\n    ```\n    \n    ```java\n    // after\n    if(p == null && q == null) return true;\n    if(p == null || q == null) return false; \n    // when p is null then q have to be not null\n    ```\n","slug":"100-Same-Tree","published":1,"updated":"2022-09-24T03:31:59.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc100007qkcccs2q191v","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>two binary trees <code>p</code> and <code>q</code></li>\n<li>write a function to check if they are the same or not.\n<ul>\n<li>structurally identical</li>\n<li>the nodes have the same value</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we need to check if both of tree are structurally identical first. it means that each node has identical child node at exact same poistion. for instance binary tree <code>p</code> only has left node then another binary tree <code>q</code> has to have left child node.</p>\n<p>second, we have to check if each node has same value.</p>\n<p>Time complexity is O(n)</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e49aa33-bdf2-41ad-b362-67de9f5f321e/A04630F7-8261-49BD-9313-74502FA348E6.jpeg\" alt=\"A04630F7-8261-49BD-9313-74502FA348E6.jpeg\"></p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> &amp;&amp; q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> || q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p.val != q.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5dc130f0-51d5-42e1-92b8-673b4ee15eec/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>when p and q both are null, if one of the p and q is null, <strong>then each q and p has to be not null</strong>. so I don’t need to check like below</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> &amp;&amp; q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(q != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> &amp;&amp; q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> || q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; </span><br><span class=\"line\"><span class=\"comment\">// when p is null then q have to be not null</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>two binary trees <code>p</code> and <code>q</code></li>\n<li>write a function to check if they are the same or not.\n<ul>\n<li>structurally identical</li>\n<li>the nodes have the same value</li>\n</ul>\n</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we need to check if both of tree are structurally identical first. it means that each node has identical child node at exact same poistion. for instance binary tree <code>p</code> only has left node then another binary tree <code>q</code> has to have left child node.</p>\n<p>second, we have to check if each node has same value.</p>\n<p>Time complexity is O(n)</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e49aa33-bdf2-41ad-b362-67de9f5f321e/A04630F7-8261-49BD-9313-74502FA348E6.jpeg\" alt=\"A04630F7-8261-49BD-9313-74502FA348E6.jpeg\"></p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> &amp;&amp; q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> || q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p.val != q.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5dc130f0-51d5-42e1-92b8-673b4ee15eec/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>when p and q both are null, if one of the p and q is null, <strong>then each q and p has to be not null</strong>. so I don’t need to check like below</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> &amp;&amp; q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(q != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> &amp;&amp; q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> || q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; </span><br><span class=\"line\"><span class=\"comment\">// when p is null then q have to be not null</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n"},{"title":"105. Construct Binary Tree from Preorder and Inorder Traversal","catalog":true,"date":"2022-10-03T07:21:17.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- return *the binary tree*\n\n## Solve by hands first\n\n---\n\nIn preorder traversal, **first element is always be parent node**.\n\nIn inorder traversal, **first element is always be left node**.\n\nso, we can split two sequence of array from parent node. \n\n```java\npreorder = [3,9,20,15,7] -> [3 | 9 | 20,15,7]\ninorder = [9,3,15,20,7]  -> [9 | 3 | 15,20,7] \n```\n\nCreate parent node with the first elmenet of preorder.\n\nFind the index of the parent element in inorder from the first element of preorder. then, **pass left subarray of both preorder and inorder to** \n\n**left subproblem and also right subarray of both preorder and inorder to right sub problem**\n\n```java\nTreeNode parent = new TreeNode(preorder[0]);\n\nparent.left = buildTree([9], [9]);\nparent.right = buildTree([20,15,7], [15,20,7]);\n```\n\nTime complexity is O(logN)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public TreeNode buildTree(int[] pre, int[] in) {\n        if(pre.length == 0 || in.length == 0) return null;\n        \n        int head = pre[0];\n        TreeNode root = new TreeNode(head);\n        \n        int mid = 0;\n        for(int i = 0; i < in.length; i++) {\n            if(in[i] == head) mid = i;\n        }\n        \n        root.left = buildTree(Arrays.copyOfRange(pre, 1, mid+1), Arrays.copyOfRange(in, 0, mid));\n        root.right = buildTree(Arrays.copyOfRange(pre, mid+1, pre.length), Arrays.copyOfRange(in, mid+1, in.length));\n        \n        return root;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a7234d8b-1ac4-4607-ae43-65687c183477/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. return node in tree dynamic programming would help\n\n```java\npublic TreeNode buildTree(int[] pre, int[] in) {\n\tif(pre.length == 0 || in.length == 0) return null;\n\tTreeNode root = new TreeNode(head);\n\t        \n\troot.left = buildTree(sub(pre, 1, mid+1), sub(in, 0, mid));\n\troot.right = buildTree(sub(pre, mid+1, pre.length), sub(in, mid+1, in.length));\n\n\treturn root;\n}\t\n```\n","source":"_posts/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.md","raw":"---\ntitle: \"105.\\_Construct Binary Tree from Preorder and Inorder Traversal\"\ncatalog: true\ndate: 2022-10-03 16:21:17\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- return *the binary tree*\n\n## Solve by hands first\n\n---\n\nIn preorder traversal, **first element is always be parent node**.\n\nIn inorder traversal, **first element is always be left node**.\n\nso, we can split two sequence of array from parent node. \n\n```java\npreorder = [3,9,20,15,7] -> [3 | 9 | 20,15,7]\ninorder = [9,3,15,20,7]  -> [9 | 3 | 15,20,7] \n```\n\nCreate parent node with the first elmenet of preorder.\n\nFind the index of the parent element in inorder from the first element of preorder. then, **pass left subarray of both preorder and inorder to** \n\n**left subproblem and also right subarray of both preorder and inorder to right sub problem**\n\n```java\nTreeNode parent = new TreeNode(preorder[0]);\n\nparent.left = buildTree([9], [9]);\nparent.right = buildTree([20,15,7], [15,20,7]);\n```\n\nTime complexity is O(logN)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public TreeNode buildTree(int[] pre, int[] in) {\n        if(pre.length == 0 || in.length == 0) return null;\n        \n        int head = pre[0];\n        TreeNode root = new TreeNode(head);\n        \n        int mid = 0;\n        for(int i = 0; i < in.length; i++) {\n            if(in[i] == head) mid = i;\n        }\n        \n        root.left = buildTree(Arrays.copyOfRange(pre, 1, mid+1), Arrays.copyOfRange(in, 0, mid));\n        root.right = buildTree(Arrays.copyOfRange(pre, mid+1, pre.length), Arrays.copyOfRange(in, mid+1, in.length));\n        \n        return root;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a7234d8b-1ac4-4607-ae43-65687c183477/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. return node in tree dynamic programming would help\n\n```java\npublic TreeNode buildTree(int[] pre, int[] in) {\n\tif(pre.length == 0 || in.length == 0) return null;\n\tTreeNode root = new TreeNode(head);\n\t        \n\troot.left = buildTree(sub(pre, 1, mid+1), sub(in, 0, mid));\n\troot.right = buildTree(sub(pre, mid+1, pre.length), sub(in, mid+1, in.length));\n\n\treturn root;\n}\t\n```\n","slug":"105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","published":1,"updated":"2022-10-03T07:21:41.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc100008qkcc2ja52a2y","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>return <em>the binary tree</em></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>In preorder traversal, <strong>first element is always be parent node</strong>.</p>\n<p>In inorder traversal, <strong>first element is always be left node</strong>.</p>\n<p>so, we can split two sequence of array from parent node.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preorder = [<span class=\"number\">3</span>,<span class=\"number\">9</span>,<span class=\"number\">20</span>,<span class=\"number\">15</span>,<span class=\"number\">7</span>] -&gt; [<span class=\"number\">3</span> | <span class=\"number\">9</span> | <span class=\"number\">20</span>,<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">inorder = [<span class=\"number\">9</span>,<span class=\"number\">3</span>,<span class=\"number\">15</span>,<span class=\"number\">20</span>,<span class=\"number\">7</span>]  -&gt; [<span class=\"number\">9</span> | <span class=\"number\">3</span> | <span class=\"number\">15</span>,<span class=\"number\">20</span>,<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure>\n<p>Create parent node with the first elmenet of preorder.</p>\n<p>Find the index of the parent element in inorder from the first element of preorder. then, <strong>pass left subarray of both preorder and inorder to</strong></p>\n<p><strong>left subproblem and also right subarray of both preorder and inorder to right sub problem</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TreeNode parent = <span class=\"keyword\">new</span> TreeNode(preorder[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">parent.left = buildTree([<span class=\"number\">9</span>], [<span class=\"number\">9</span>]);</span><br><span class=\"line\">parent.right = buildTree([<span class=\"number\">20</span>,<span class=\"number\">15</span>,<span class=\"number\">7</span>], [<span class=\"number\">15</span>,<span class=\"number\">20</span>,<span class=\"number\">7</span>]);</span><br></pre></td></tr></table></figure>\n<p>Time complexity is O(logN)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"keyword\">int</span>[] pre, <span class=\"keyword\">int</span>[] in)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre.length == <span class=\"number\">0</span> || in.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> head = pre[<span class=\"number\">0</span>];</span><br><span class=\"line\">        TreeNode root = <span class=\"keyword\">new</span> TreeNode(head);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; in.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(in[i] == head) mid = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        root.left = buildTree(Arrays.copyOfRange(pre, <span class=\"number\">1</span>, mid+<span class=\"number\">1</span>), Arrays.copyOfRange(in, <span class=\"number\">0</span>, mid));</span><br><span class=\"line\">        root.right = buildTree(Arrays.copyOfRange(pre, mid+<span class=\"number\">1</span>, pre.length), Arrays.copyOfRange(in, mid+<span class=\"number\">1</span>, in.length));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a7234d8b-1ac4-4607-ae43-65687c183477/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>return node in tree dynamic programming would help</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"keyword\">int</span>[] pre, <span class=\"keyword\">int</span>[] in)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(pre.length == <span class=\"number\">0</span> || in.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\tTreeNode root = <span class=\"keyword\">new</span> TreeNode(head);</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\troot.left = buildTree(sub(pre, <span class=\"number\">1</span>, mid+<span class=\"number\">1</span>), sub(in, <span class=\"number\">0</span>, mid));</span><br><span class=\"line\">\troot.right = buildTree(sub(pre, mid+<span class=\"number\">1</span>, pre.length), sub(in, mid+<span class=\"number\">1</span>, in.length));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>return <em>the binary tree</em></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>In preorder traversal, <strong>first element is always be parent node</strong>.</p>\n<p>In inorder traversal, <strong>first element is always be left node</strong>.</p>\n<p>so, we can split two sequence of array from parent node.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preorder = [<span class=\"number\">3</span>,<span class=\"number\">9</span>,<span class=\"number\">20</span>,<span class=\"number\">15</span>,<span class=\"number\">7</span>] -&gt; [<span class=\"number\">3</span> | <span class=\"number\">9</span> | <span class=\"number\">20</span>,<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">inorder = [<span class=\"number\">9</span>,<span class=\"number\">3</span>,<span class=\"number\">15</span>,<span class=\"number\">20</span>,<span class=\"number\">7</span>]  -&gt; [<span class=\"number\">9</span> | <span class=\"number\">3</span> | <span class=\"number\">15</span>,<span class=\"number\">20</span>,<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure>\n<p>Create parent node with the first elmenet of preorder.</p>\n<p>Find the index of the parent element in inorder from the first element of preorder. then, <strong>pass left subarray of both preorder and inorder to</strong></p>\n<p><strong>left subproblem and also right subarray of both preorder and inorder to right sub problem</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TreeNode parent = <span class=\"keyword\">new</span> TreeNode(preorder[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">parent.left = buildTree([<span class=\"number\">9</span>], [<span class=\"number\">9</span>]);</span><br><span class=\"line\">parent.right = buildTree([<span class=\"number\">20</span>,<span class=\"number\">15</span>,<span class=\"number\">7</span>], [<span class=\"number\">15</span>,<span class=\"number\">20</span>,<span class=\"number\">7</span>]);</span><br></pre></td></tr></table></figure>\n<p>Time complexity is O(logN)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"keyword\">int</span>[] pre, <span class=\"keyword\">int</span>[] in)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre.length == <span class=\"number\">0</span> || in.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> head = pre[<span class=\"number\">0</span>];</span><br><span class=\"line\">        TreeNode root = <span class=\"keyword\">new</span> TreeNode(head);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; in.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(in[i] == head) mid = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        root.left = buildTree(Arrays.copyOfRange(pre, <span class=\"number\">1</span>, mid+<span class=\"number\">1</span>), Arrays.copyOfRange(in, <span class=\"number\">0</span>, mid));</span><br><span class=\"line\">        root.right = buildTree(Arrays.copyOfRange(pre, mid+<span class=\"number\">1</span>, pre.length), Arrays.copyOfRange(in, mid+<span class=\"number\">1</span>, in.length));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a7234d8b-1ac4-4607-ae43-65687c183477/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>return node in tree dynamic programming would help</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">buildTree</span><span class=\"params\">(<span class=\"keyword\">int</span>[] pre, <span class=\"keyword\">int</span>[] in)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(pre.length == <span class=\"number\">0</span> || in.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\tTreeNode root = <span class=\"keyword\">new</span> TreeNode(head);</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\troot.left = buildTree(sub(pre, <span class=\"number\">1</span>, mid+<span class=\"number\">1</span>), sub(in, <span class=\"number\">0</span>, mid));</span><br><span class=\"line\">\troot.right = buildTree(sub(pre, mid+<span class=\"number\">1</span>, pre.length), sub(in, mid+<span class=\"number\">1</span>, in.length));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"11. Container With Most Water","catalog":true,"date":"2022-10-11T09:51:17.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- Find two lines contains the most water\n- Return *the maximum amount of water a container can store*\n.\n\n## Solve by hands first\n\n---\n\nThe goal is to find the two lines containing the most water. **Formular to calculate the max water is max height * max width**. so **we can start from max width which is index 0 to length - 1**. then calculate the water. move the left or right index from the smaller height line to heigher. Time complexity is O(n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    public int maxArea(int[] height) {\n        int l = 0, r = height.length - 1, max = 0;\n        while(l < r) {\n            max = Math.max(Math.min(height[l], height[r]) * (r - l), max);\n            if(height[l] < height[r]) l++;\n            else r--;\n        }\n        return max;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9bce7f1d-8c66-4182-b3d8-e1a9cfdb9884/Untitled.png)\n\n## Lesson I learnt\n\n---\n","source":"_posts/11-Container-With-Most-Water.md","raw":"---\ntitle: \"11.\\_Container With Most Water\"\ncatalog: true\ndate: 2022-10-11 18:51:17\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- Find two lines contains the most water\n- Return *the maximum amount of water a container can store*\n.\n\n## Solve by hands first\n\n---\n\nThe goal is to find the two lines containing the most water. **Formular to calculate the max water is max height * max width**. so **we can start from max width which is index 0 to length - 1**. then calculate the water. move the left or right index from the smaller height line to heigher. Time complexity is O(n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    public int maxArea(int[] height) {\n        int l = 0, r = height.length - 1, max = 0;\n        while(l < r) {\n            max = Math.max(Math.min(height[l], height[r]) * (r - l), max);\n            if(height[l] < height[r]) l++;\n            else r--;\n        }\n        return max;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9bce7f1d-8c66-4182-b3d8-e1a9cfdb9884/Untitled.png)\n\n## Lesson I learnt\n\n---\n","slug":"11-Container-With-Most-Water","published":1,"updated":"2022-10-11T09:51:40.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc110009qkccmho7xzr2","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>Find two lines contains the most water</li>\n<li>Return <em>the maximum amount of water a container can store</em><br>\n.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>The goal is to find the two lines containing the most water. <strong>Formular to calculate the max water is max height * max width</strong>. so <strong>we can start from max width which is index 0 to length - 1</strong>. then calculate the water. move the left or right index from the smaller height line to heigher. Time complexity is O(n)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"keyword\">int</span>[] height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = height.length - <span class=\"number\">1</span>, max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            max = Math.max(Math.min(height[l], height[r]) * (r - l), max);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[l] &lt; height[r]) l++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9bce7f1d-8c66-4182-b3d8-e1a9cfdb9884/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>Find two lines contains the most water</li>\n<li>Return <em>the maximum amount of water a container can store</em><br>\n.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>The goal is to find the two lines containing the most water. <strong>Formular to calculate the max water is max height * max width</strong>. so <strong>we can start from max width which is index 0 to length - 1</strong>. then calculate the water. move the left or right index from the smaller height line to heigher. Time complexity is O(n)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"keyword\">int</span>[] height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = height.length - <span class=\"number\">1</span>, max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            max = Math.max(Math.min(height[l], height[r]) * (r - l), max);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[l] &lt; height[r]) l++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9bce7f1d-8c66-4182-b3d8-e1a9cfdb9884/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n"},{"title":"118. Pascal's Triangle","catalog":true,"date":"2022-10-31T10:24:38.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- return the first numRows of **Pascal's triangle**\n- **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:\n\n### **Edge cases**\n\n---\n\n- 1 → [[1]]\n- 2 → [[1],[1,1]]\n- 3 → [[1],[1,1],[1,2,1]]\n- 4 → [[1],[1,1],[1,2,1],[1,3,4,3,1]]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nCreate the ArrayList to store the each level. Loop through 1 to input number. Each value in iteration represent length of level in pascal triangle.  In every iteration we have to add 1 for the first index and sum of value of i-1, i index in previous level. Time complexity is O(numRows * numRows) and space complexity is O(numRows * numRows)\n\n```java\nList<List<Integer>> res = new ArrayList();\n\nfor(int i = 1; i <= numRows; i++) {\n\tList<Integer> list = new ArrayList();\n\tfor(int j = 0; j < i; j++) {\n\t\tif(j == 0 || j == i-1) list.add(1);\n\t\telse list.add(res.get(i-1).get(j) + res.get(i-1).get(j+1));\n\t}\n\tres.add(list);\n}\nreturn res;\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n*the interviewer can provide you with some hints to unblock you*\n\n*it’s okay to ask the interviewer for direction.*\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> res = new ArrayList();\n        for(int i = 1; i <= numRows; i++) {\n            List<Integer> list = new ArrayList();\n            for(int j = 0; j < i; j++) {\n                if(j == 0 || j == i-1) list.add(1);\n                else list.add(res.get(i-2).get(j-1) + res.get(i-2).get(j));\n            }\n            res.add(list);\n        }\n        return res;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c0146532-ca05-48f7-9ae3-fa4970da250f/Untitled.png)\n\n### What I learned\n\n---\n\n1. Brute force approach first is important in array problems\n2. determine the meaning of row and column index and relationship between\n    - columns and rows\n\n```java\nfor(int i = 1; i <= numRows; i++) { // i = row of pascal's triangle = width of every row\n  for(int j = 0; j < i; j++) { // j = column of pascal's trainable\n\n  }\n}\n```\n","source":"_posts/118-Pascal-s-Triangle.md","raw":"---\ntitle: \"118.\\_Pascal's Triangle\"\ncatalog: true\ndate: 2022-10-31 19:24:38\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- return the first numRows of **Pascal's triangle**\n- **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:\n\n### **Edge cases**\n\n---\n\n- 1 → [[1]]\n- 2 → [[1],[1,1]]\n- 3 → [[1],[1,1],[1,2,1]]\n- 4 → [[1],[1,1],[1,2,1],[1,3,4,3,1]]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nCreate the ArrayList to store the each level. Loop through 1 to input number. Each value in iteration represent length of level in pascal triangle.  In every iteration we have to add 1 for the first index and sum of value of i-1, i index in previous level. Time complexity is O(numRows * numRows) and space complexity is O(numRows * numRows)\n\n```java\nList<List<Integer>> res = new ArrayList();\n\nfor(int i = 1; i <= numRows; i++) {\n\tList<Integer> list = new ArrayList();\n\tfor(int j = 0; j < i; j++) {\n\t\tif(j == 0 || j == i-1) list.add(1);\n\t\telse list.add(res.get(i-1).get(j) + res.get(i-1).get(j+1));\n\t}\n\tres.add(list);\n}\nreturn res;\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n*the interviewer can provide you with some hints to unblock you*\n\n*it’s okay to ask the interviewer for direction.*\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> res = new ArrayList();\n        for(int i = 1; i <= numRows; i++) {\n            List<Integer> list = new ArrayList();\n            for(int j = 0; j < i; j++) {\n                if(j == 0 || j == i-1) list.add(1);\n                else list.add(res.get(i-2).get(j-1) + res.get(i-2).get(j));\n            }\n            res.add(list);\n        }\n        return res;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c0146532-ca05-48f7-9ae3-fa4970da250f/Untitled.png)\n\n### What I learned\n\n---\n\n1. Brute force approach first is important in array problems\n2. determine the meaning of row and column index and relationship between\n    - columns and rows\n\n```java\nfor(int i = 1; i <= numRows; i++) { // i = row of pascal's triangle = width of every row\n  for(int j = 0; j < i; j++) { // j = column of pascal's trainable\n\n  }\n}\n```\n","slug":"118-Pascal-s-Triangle","published":1,"updated":"2022-10-31T10:24:51.356Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc12000aqkccdv9w5ytm","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>return the first numRows of <strong>Pascal’s triangle</strong></li>\n<li><strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>1 → [[1]]</li>\n<li>2 → [[1],[1,1]]</li>\n<li>3 → [[1],[1,1],[1,2,1]]</li>\n<li>4 → [[1],[1,1],[1,2,1],[1,3,4,3,1]]</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>Create the ArrayList to store the each level. Loop through 1 to input number. Each value in iteration represent length of level in pascal triangle.  In every iteration we have to add 1 for the first index and sum of value of i-1, i index in previous level. Time complexity is O(numRows * numRows) and space complexity is O(numRows * numRows)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= numRows; i++) &#123;</span><br><span class=\"line\">\tList&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || j == i-<span class=\"number\">1</span>) list.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> list.add(res.get(i-<span class=\"number\">1</span>).get(j) + res.get(i-<span class=\"number\">1</span>).get(j+<span class=\"number\">1</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres.add(list);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> res;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p><em>the interviewer can provide you with some hints to unblock you</em></p>\n<p><em>it’s okay to ask the interviewer for direction.</em></p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class=\"keyword\">int</span> numRows) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= numRows; i++) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || j == i-<span class=\"number\">1</span>) list.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> list.add(res.get(i-<span class=\"number\">2</span>).get(j-<span class=\"number\">1</span>) + res.get(i-<span class=\"number\">2</span>).get(j));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(list);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c0146532-ca05-48f7-9ae3-fa4970da250f/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>Brute force approach first is important in array problems</li>\n<li>determine the meaning of row and column index and relationship between\n<ul>\n<li>columns and rows</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= numRows; i++) &#123; <span class=\"comment\">// i = row of pascal's triangle = width of every row</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123; <span class=\"comment\">// j = column of pascal's trainable</span></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>return the first numRows of <strong>Pascal’s triangle</strong></li>\n<li><strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>1 → [[1]]</li>\n<li>2 → [[1],[1,1]]</li>\n<li>3 → [[1],[1,1],[1,2,1]]</li>\n<li>4 → [[1],[1,1],[1,2,1],[1,3,4,3,1]]</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>Create the ArrayList to store the each level. Loop through 1 to input number. Each value in iteration represent length of level in pascal triangle.  In every iteration we have to add 1 for the first index and sum of value of i-1, i index in previous level. Time complexity is O(numRows * numRows) and space complexity is O(numRows * numRows)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= numRows; i++) &#123;</span><br><span class=\"line\">\tList&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || j == i-<span class=\"number\">1</span>) list.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> list.add(res.get(i-<span class=\"number\">1</span>).get(j) + res.get(i-<span class=\"number\">1</span>).get(j+<span class=\"number\">1</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres.add(list);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> res;</span><br></pre></td></tr></table></figure>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p><em>the interviewer can provide you with some hints to unblock you</em></p>\n<p><em>it’s okay to ask the interviewer for direction.</em></p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class=\"keyword\">int</span> numRows) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= numRows; i++) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || j == i-<span class=\"number\">1</span>) list.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> list.add(res.get(i-<span class=\"number\">2</span>).get(j-<span class=\"number\">1</span>) + res.get(i-<span class=\"number\">2</span>).get(j));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(list);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c0146532-ca05-48f7-9ae3-fa4970da250f/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>Brute force approach first is important in array problems</li>\n<li>determine the meaning of row and column index and relationship between\n<ul>\n<li>columns and rows</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= numRows; i++) &#123; <span class=\"comment\">// i = row of pascal's triangle = width of every row</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123; <span class=\"comment\">// j = column of pascal's trainable</span></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"121. Best Time to Buy and Sell Stock","catalog":true,"date":"2022-10-18T11:49:31.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- prices[i] is the price of a given stock on the ith day\n- maximize the profit by **choosing a single day to buy one stock** and **choosing a different day in the future to sell that stock**\n- if you can’t not achieve any profit return 0\n- given days are between 1 and 10^5 days\n- price is between 0 to 10^4\n- order matters in this case which means buy the stock at the minimum and cell it at maximum\n- **elements are distinct in array?**\n\n### **Edge cases**\n\n---\n\n- [1, 2, 3] → 2 = 3 - 1\n- [3, 2, 1] → 0\n- [] → 0\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nStarting from left index at index 0 and compare with the right index which is next index of left index. if the value of left index is smaller than equals to value of right index. Find the take out of both value and store as max. After whole iteration, return max value\n\nTime complexity is O(lenth of array * length of array) which is O(n^2). Space complexity is O(1)\n\n```java\nint max = 0;\nfor(int i = 0; i < nums.length; i++) {\n\tfor(int j = i+1; j < nums.length; j++) {\n\t\tif(nums[i] <= nums[j]) {\n\t\t\tmax = Math.max(max, nums[j] - nums[i]);\n\t\t}\n\t}\n}\nreturn max;\n\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can optimize the time complexity to O(n) with **Two Pointer**. We need two pointer from index 0 and the last index. Compare the value of those value of indices, If left value is greater than right value, then move left pointer to right. if left value is less than equals to right value, store it as max and move the right pointer to left. it keeps on going until left index is greater than right index. if we can’t meet any condition, then it will return 0 as max\n\n```java\nint max = 0, l = 0, r = prices.length-1;\nwhile(l <= r) {\n\tif(prices[l] > prices[r]) l++;\n\telse {\n\t\tmax = Math.max(max, prices[r] - prices[l]);\n\t\tr--;\n\t}\n}\nreturn max;\n```\n\nProblem of the approach is that in case of [2, 1, 4], since 4 is greater than 2, so right index move to left but left index has to move to get maximum profit. so, instead of putting the right index from the last index, we can simply start off left and right index from 0 index.\n\nMove to right index one at a time. If left pointer value is less than right pointer value which makes positive profit, compare the previous maximum and current profit and choose the larger value. otherwise move the left pointer to the right pointer because **right pointer is currently less than left pointer which pointing to the minimum value**. Time complexity is O(length of input array)\n\n```java\nint max = 0, l = 0, r = 0;\nwhile(r < prices.length) {\n\tif(prices[l] < prices[r]) max = Math.max(max, prices[r] - prices[l]);\n\telse l = r;\n\tr++;\n}\nreturn max;\n```\n\n![206A8703-105F-4E47-890C-07CEB6CE7FE3.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23ffcb0b-fe1d-416f-8a05-5930fdf2d7db/206A8703-105F-4E47-890C-07CEB6CE7FE3.jpeg)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int max = 0, l = 0, r = 0;\n        while(r <th) {\n            if(prices[l] < prices[r]) max = Math.max(max, prices[r] - prices[l]);\n            else l = r;\n            r++;\n        }\n        return max;\n    }\n}\n``` \n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7be58ed8-3a62-4e83-9244-741848f1cc06/Untitled.png)\n\n### What I learned\n\n---\n\n1. [Kadane's Algorithm](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/Kadane's-Algorithm-Since-no-one-has-mentioned-about-this-so-far-%3A)-(In-case-if-interviewer-twists-the-input))\n    - it’s the algorithm comparing the current max value and global max value\n\n```java\npublic int maxProfit(int[] prices) {\n    int maxCur = 0, maxSoFar = 0;\n    for(int i = 1; i < prices.length; i++) {\n        maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);\n        maxSoFar = Math.max(maxCur, maxSoFar);\n    }\n    return maxSoFar;\n}\n```\n\n1. Two pointer can be from 0 to last index or start from 0 at the same time\n    - **left = 0, right = n.length**\n    - **left = 0, right = 0**\n2. Two pointer is a good solution for Array problem\n","source":"_posts/121-Best-Time-to-Buy-and-Sell-Stock.md","raw":"---\ntitle: \"121.\\_Best Time to Buy and Sell Stock\"\ncatalog: true\ndate: 2022-10-18 20:49:31\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- prices[i] is the price of a given stock on the ith day\n- maximize the profit by **choosing a single day to buy one stock** and **choosing a different day in the future to sell that stock**\n- if you can’t not achieve any profit return 0\n- given days are between 1 and 10^5 days\n- price is between 0 to 10^4\n- order matters in this case which means buy the stock at the minimum and cell it at maximum\n- **elements are distinct in array?**\n\n### **Edge cases**\n\n---\n\n- [1, 2, 3] → 2 = 3 - 1\n- [3, 2, 1] → 0\n- [] → 0\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nStarting from left index at index 0 and compare with the right index which is next index of left index. if the value of left index is smaller than equals to value of right index. Find the take out of both value and store as max. After whole iteration, return max value\n\nTime complexity is O(lenth of array * length of array) which is O(n^2). Space complexity is O(1)\n\n```java\nint max = 0;\nfor(int i = 0; i < nums.length; i++) {\n\tfor(int j = i+1; j < nums.length; j++) {\n\t\tif(nums[i] <= nums[j]) {\n\t\t\tmax = Math.max(max, nums[j] - nums[i]);\n\t\t}\n\t}\n}\nreturn max;\n\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can optimize the time complexity to O(n) with **Two Pointer**. We need two pointer from index 0 and the last index. Compare the value of those value of indices, If left value is greater than right value, then move left pointer to right. if left value is less than equals to right value, store it as max and move the right pointer to left. it keeps on going until left index is greater than right index. if we can’t meet any condition, then it will return 0 as max\n\n```java\nint max = 0, l = 0, r = prices.length-1;\nwhile(l <= r) {\n\tif(prices[l] > prices[r]) l++;\n\telse {\n\t\tmax = Math.max(max, prices[r] - prices[l]);\n\t\tr--;\n\t}\n}\nreturn max;\n```\n\nProblem of the approach is that in case of [2, 1, 4], since 4 is greater than 2, so right index move to left but left index has to move to get maximum profit. so, instead of putting the right index from the last index, we can simply start off left and right index from 0 index.\n\nMove to right index one at a time. If left pointer value is less than right pointer value which makes positive profit, compare the previous maximum and current profit and choose the larger value. otherwise move the left pointer to the right pointer because **right pointer is currently less than left pointer which pointing to the minimum value**. Time complexity is O(length of input array)\n\n```java\nint max = 0, l = 0, r = 0;\nwhile(r < prices.length) {\n\tif(prices[l] < prices[r]) max = Math.max(max, prices[r] - prices[l]);\n\telse l = r;\n\tr++;\n}\nreturn max;\n```\n\n![206A8703-105F-4E47-890C-07CEB6CE7FE3.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23ffcb0b-fe1d-416f-8a05-5930fdf2d7db/206A8703-105F-4E47-890C-07CEB6CE7FE3.jpeg)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int max = 0, l = 0, r = 0;\n        while(r <th) {\n            if(prices[l] < prices[r]) max = Math.max(max, prices[r] - prices[l]);\n            else l = r;\n            r++;\n        }\n        return max;\n    }\n}\n``` \n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7be58ed8-3a62-4e83-9244-741848f1cc06/Untitled.png)\n\n### What I learned\n\n---\n\n1. [Kadane's Algorithm](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/Kadane's-Algorithm-Since-no-one-has-mentioned-about-this-so-far-%3A)-(In-case-if-interviewer-twists-the-input))\n    - it’s the algorithm comparing the current max value and global max value\n\n```java\npublic int maxProfit(int[] prices) {\n    int maxCur = 0, maxSoFar = 0;\n    for(int i = 1; i < prices.length; i++) {\n        maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);\n        maxSoFar = Math.max(maxCur, maxSoFar);\n    }\n    return maxSoFar;\n}\n```\n\n1. Two pointer can be from 0 to last index or start from 0 at the same time\n    - **left = 0, right = n.length**\n    - **left = 0, right = 0**\n2. Two pointer is a good solution for Array problem\n","slug":"121-Best-Time-to-Buy-and-Sell-Stock","published":1,"updated":"2022-10-18T11:54:17.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc13000bqkccxhm3g9qs","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>prices[i] is the price of a given stock on the ith day</li>\n<li>maximize the profit by <strong>choosing a single day to buy one stock</strong> and <strong>choosing a different day in the future to sell that stock</strong></li>\n<li>if you can’t not achieve any profit return 0</li>\n<li>given days are between 1 and 10^5 days</li>\n<li>price is between 0 to 10^4</li>\n<li>order matters in this case which means buy the stock at the minimum and cell it at maximum</li>\n<li><strong>elements are distinct in array?</strong></li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>[1, 2, 3] → 2 = 3 - 1</li>\n<li>[3, 2, 1] → 0</li>\n<li>[] → 0</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>Starting from left index at index 0 and compare with the right index which is next index of left index. if the value of left index is smaller than equals to value of right index. Find the take out of both value and store as max. After whole iteration, return max value</p>\n<p>Time complexity is O(lenth of array * length of array) which is O(n^2). Space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[i] &lt;= nums[j]) &#123;</span><br><span class=\"line\">\t\t\tmax = Math.max(max, nums[j] - nums[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>We can optimize the time complexity to O(n) with <strong>Two Pointer</strong>. We need two pointer from index 0 and the last index. Compare the value of those value of indices, If left value is greater than right value, then move left pointer to right. if left value is less than equals to right value, store it as max and move the right pointer to left. it keeps on going until left index is greater than right index. if we can’t meet any condition, then it will return 0 as max</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> max = <span class=\"number\">0</span>, l = <span class=\"number\">0</span>, r = prices.length-<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(prices[l] &gt; prices[r]) l++;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tmax = Math.max(max, prices[r] - prices[l]);</span><br><span class=\"line\">\t\tr--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max;</span><br></pre></td></tr></table></figure>\n<p>Problem of the approach is that in case of [2, 1, 4], since 4 is greater than 2, so right index move to left but left index has to move to get maximum profit. so, instead of putting the right index from the last index, we can simply start off left and right index from 0 index.</p>\n<p>Move to right index one at a time. If left pointer value is less than right pointer value which makes positive profit, compare the previous maximum and current profit and choose the larger value. otherwise move the left pointer to the right pointer because <strong>right pointer is currently less than left pointer which pointing to the minimum value</strong>. Time complexity is O(length of input array)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> max = <span class=\"number\">0</span>, l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(r &lt; prices.length) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(prices[l] &lt; prices[r]) max = Math.max(max, prices[r] - prices[l]);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> l = r;</span><br><span class=\"line\">\tr++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23ffcb0b-fe1d-416f-8a05-5930fdf2d7db/206A8703-105F-4E47-890C-07CEB6CE7FE3.jpeg\" alt=\"206A8703-105F-4E47-890C-07CEB6CE7FE3.jpeg\"></p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>, l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r &lt;th) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(prices[l] &lt; prices[r]) max = Math.max(max, prices[r] - prices[l]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = r;</span><br><span class=\"line\">            r++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">### **Dry Run**</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\">![Untitled](https:<span class=\"comment\">//s3-us-west-2.amazonaws.com/secure.notion-static.com/7be58ed8-3a62-4e83-9244-741848f1cc06/Untitled.png)</span></span><br><span class=\"line\"></span><br><span class=\"line\">### What I learned</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>. [Kadane<span class=\"string\">'s Algorithm](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/Kadane'</span>s-Algorithm-Since-no-one-has-mentioned-about-<span class=\"keyword\">this</span>-so-far-%<span class=\"number\">3</span>A)-(In-<span class=\"keyword\">case</span>-<span class=\"keyword\">if</span>-interviewer-twists-the-input))</span><br><span class=\"line\">    - it’s the algorithm comparing the current max value and global max value</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxCur = <span class=\"number\">0</span>, maxSoFar = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">        maxCur = Math.max(<span class=\"number\">0</span>, maxCur += prices[i] - prices[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">        maxSoFar = Math.max(maxCur, maxSoFar);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxSoFar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Two pointer can be from 0 to last index or start from 0 at the same time\n<ul>\n<li><strong>left = 0, right = n.length</strong></li>\n<li><strong>left = 0, right = 0</strong></li>\n</ul>\n</li>\n<li>Two pointer is a good solution for Array problem</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>prices[i] is the price of a given stock on the ith day</li>\n<li>maximize the profit by <strong>choosing a single day to buy one stock</strong> and <strong>choosing a different day in the future to sell that stock</strong></li>\n<li>if you can’t not achieve any profit return 0</li>\n<li>given days are between 1 and 10^5 days</li>\n<li>price is between 0 to 10^4</li>\n<li>order matters in this case which means buy the stock at the minimum and cell it at maximum</li>\n<li><strong>elements are distinct in array?</strong></li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>[1, 2, 3] → 2 = 3 - 1</li>\n<li>[3, 2, 1] → 0</li>\n<li>[] → 0</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>Starting from left index at index 0 and compare with the right index which is next index of left index. if the value of left index is smaller than equals to value of right index. Find the take out of both value and store as max. After whole iteration, return max value</p>\n<p>Time complexity is O(lenth of array * length of array) which is O(n^2). Space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[i] &lt;= nums[j]) &#123;</span><br><span class=\"line\">\t\t\tmax = Math.max(max, nums[j] - nums[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max;</span><br></pre></td></tr></table></figure>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>We can optimize the time complexity to O(n) with <strong>Two Pointer</strong>. We need two pointer from index 0 and the last index. Compare the value of those value of indices, If left value is greater than right value, then move left pointer to right. if left value is less than equals to right value, store it as max and move the right pointer to left. it keeps on going until left index is greater than right index. if we can’t meet any condition, then it will return 0 as max</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> max = <span class=\"number\">0</span>, l = <span class=\"number\">0</span>, r = prices.length-<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(prices[l] &gt; prices[r]) l++;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tmax = Math.max(max, prices[r] - prices[l]);</span><br><span class=\"line\">\t\tr--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max;</span><br></pre></td></tr></table></figure>\n<p>Problem of the approach is that in case of [2, 1, 4], since 4 is greater than 2, so right index move to left but left index has to move to get maximum profit. so, instead of putting the right index from the last index, we can simply start off left and right index from 0 index.</p>\n<p>Move to right index one at a time. If left pointer value is less than right pointer value which makes positive profit, compare the previous maximum and current profit and choose the larger value. otherwise move the left pointer to the right pointer because <strong>right pointer is currently less than left pointer which pointing to the minimum value</strong>. Time complexity is O(length of input array)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> max = <span class=\"number\">0</span>, l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(r &lt; prices.length) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(prices[l] &lt; prices[r]) max = Math.max(max, prices[r] - prices[l]);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> l = r;</span><br><span class=\"line\">\tr++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23ffcb0b-fe1d-416f-8a05-5930fdf2d7db/206A8703-105F-4E47-890C-07CEB6CE7FE3.jpeg\" alt=\"206A8703-105F-4E47-890C-07CEB6CE7FE3.jpeg\"></p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>, l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r &lt;th) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(prices[l] &lt; prices[r]) max = Math.max(max, prices[r] - prices[l]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = r;</span><br><span class=\"line\">            r++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">### **Dry Run**</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\">![Untitled](https:<span class=\"comment\">//s3-us-west-2.amazonaws.com/secure.notion-static.com/7be58ed8-3a62-4e83-9244-741848f1cc06/Untitled.png)</span></span><br><span class=\"line\"></span><br><span class=\"line\">### What I learned</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>. [Kadane<span class=\"string\">'s Algorithm](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/Kadane'</span>s-Algorithm-Since-no-one-has-mentioned-about-<span class=\"keyword\">this</span>-so-far-%<span class=\"number\">3</span>A)-(In-<span class=\"keyword\">case</span>-<span class=\"keyword\">if</span>-interviewer-twists-the-input))</span><br><span class=\"line\">    - it’s the algorithm comparing the current max value and global max value</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxCur = <span class=\"number\">0</span>, maxSoFar = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">        maxCur = Math.max(<span class=\"number\">0</span>, maxCur += prices[i] - prices[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">        maxSoFar = Math.max(maxCur, maxSoFar);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxSoFar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Two pointer can be from 0 to last index or start from 0 at the same time\n<ul>\n<li><strong>left = 0, right = n.length</strong></li>\n<li><strong>left = 0, right = 0</strong></li>\n</ul>\n</li>\n<li>Two pointer is a good solution for Array problem</li>\n</ol>\n"},{"title":"133. Clone Graph","catalog":true,"date":"2022-10-05T11:49:31.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- **[connected](https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph)** undirected graph.\n- Return a **[deep copy](https://en.wikipedia.org/wiki/Object_copying#Deep_copy)** (clone) of the graph.\n\n## Solve by hands first\n\n---\n\nwe can use dfs with map. it will traverse all the way to the last node in graph and travel back to the first node. Time complexity is O(n). \n\n![DD01F724-B3D7-40D6-B669-0B6B9DD7B10D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c025d93f-7565-439e-b936-6ce5a100b005/DD01F724-B3D7-40D6-B669-0B6B9DD7B10D.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    Map<Node, Node> oldToNew;\n    \n    public Node cloneGraph(Node node) {\n        if(node == null) return null;\n        oldToNew = new HashMap();\n        return dfs(node);\n    }\n    \n    private Node dfs(Node node) {\n        if(oldToNew.containsKey(node)) {\n            return oldToNew.get(node);\n        }\n        \n        Node n = new Node(node.val);\n        oldToNew.put(node, n);\n        for(Node nb : node.neighbors) {\n            n.neighbors.add(dfs(nb));\n        }\n        return n;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5032e015-32ab-4a4f-a5f2-50063ada3264/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. **HashMap can be a good solution for Graph problem**\n    - purpose of using map is to **disconnect reference of nodes**\n    - the code below will exceed time limit\n    - because it will create new node and  reference all of other nodes infinitely\n\n```java\npublic Node cloneGraph(Node node) {\n    return dfs(node);\n}\n\nprivate Node dfs(Node node) {        \n    Node n = new Node(node.val);\n    for(Node nb : node.neighbors) {\n        n.neighbors.add(dfs(nb));\n    }\n    return n;\n}\n```\n\n1. **dfs in Graph will traverse all the way to last node**. only way dereference node is using map\n","source":"_posts/133-Clone-Graph.md","raw":"---\ntitle: \"133.\\_Clone Graph\"\ncatalog: true\ndate: 2022-10-05 20:49:31\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- **[connected](https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph)** undirected graph.\n- Return a **[deep copy](https://en.wikipedia.org/wiki/Object_copying#Deep_copy)** (clone) of the graph.\n\n## Solve by hands first\n\n---\n\nwe can use dfs with map. it will traverse all the way to the last node in graph and travel back to the first node. Time complexity is O(n). \n\n![DD01F724-B3D7-40D6-B669-0B6B9DD7B10D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c025d93f-7565-439e-b936-6ce5a100b005/DD01F724-B3D7-40D6-B669-0B6B9DD7B10D.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    Map<Node, Node> oldToNew;\n    \n    public Node cloneGraph(Node node) {\n        if(node == null) return null;\n        oldToNew = new HashMap();\n        return dfs(node);\n    }\n    \n    private Node dfs(Node node) {\n        if(oldToNew.containsKey(node)) {\n            return oldToNew.get(node);\n        }\n        \n        Node n = new Node(node.val);\n        oldToNew.put(node, n);\n        for(Node nb : node.neighbors) {\n            n.neighbors.add(dfs(nb));\n        }\n        return n;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5032e015-32ab-4a4f-a5f2-50063ada3264/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. **HashMap can be a good solution for Graph problem**\n    - purpose of using map is to **disconnect reference of nodes**\n    - the code below will exceed time limit\n    - because it will create new node and  reference all of other nodes infinitely\n\n```java\npublic Node cloneGraph(Node node) {\n    return dfs(node);\n}\n\nprivate Node dfs(Node node) {        \n    Node n = new Node(node.val);\n    for(Node nb : node.neighbors) {\n        n.neighbors.add(dfs(nb));\n    }\n    return n;\n}\n```\n\n1. **dfs in Graph will traverse all the way to last node**. only way dereference node is using map\n","slug":"133-Clone-Graph","published":1,"updated":"2022-10-05T11:49:48.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc13000cqkcceh12e4hs","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li><strong><a href=\"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph\" target=\"_blank\" rel=\"noopener\">connected</a></strong> undirected graph.</li>\n<li>Return a <strong><a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\" rel=\"noopener\">deep copy</a></strong> (clone) of the graph.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can use dfs with map. it will traverse all the way to the last node in graph and travel back to the first node. Time complexity is O(n).</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c025d93f-7565-439e-b936-6ce5a100b005/DD01F724-B3D7-40D6-B669-0B6B9DD7B10D.jpeg\" alt=\"DD01F724-B3D7-40D6-B669-0B6B9DD7B10D.jpeg\"></p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Map&lt;Node, Node&gt; oldToNew;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">cloneGraph</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        oldToNew = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">dfs</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(oldToNew.containsKey(node)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldToNew.get(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Node n = <span class=\"keyword\">new</span> Node(node.val);</span><br><span class=\"line\">        oldToNew.put(node, n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Node nb : node.neighbors) &#123;</span><br><span class=\"line\">            n.neighbors.add(dfs(nb));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5032e015-32ab-4a4f-a5f2-50063ada3264/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li><strong>HashMap can be a good solution for Graph problem</strong>\n<ul>\n<li>purpose of using map is to <strong>disconnect reference of nodes</strong></li>\n<li>the code below will exceed time limit</li>\n<li>because it will create new node and  reference all of other nodes infinitely</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">cloneGraph</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">dfs</span><span class=\"params\">(Node node)</span> </span>&#123;        </span><br><span class=\"line\">    Node n = <span class=\"keyword\">new</span> Node(node.val);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Node nb : node.neighbors) &#123;</span><br><span class=\"line\">        n.neighbors.add(dfs(nb));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><strong>dfs in Graph will traverse all the way to last node</strong>. only way dereference node is using map</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li><strong><a href=\"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph\" target=\"_blank\" rel=\"noopener\">connected</a></strong> undirected graph.</li>\n<li>Return a <strong><a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\" rel=\"noopener\">deep copy</a></strong> (clone) of the graph.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can use dfs with map. it will traverse all the way to the last node in graph and travel back to the first node. Time complexity is O(n).</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c025d93f-7565-439e-b936-6ce5a100b005/DD01F724-B3D7-40D6-B669-0B6B9DD7B10D.jpeg\" alt=\"DD01F724-B3D7-40D6-B669-0B6B9DD7B10D.jpeg\"></p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Map&lt;Node, Node&gt; oldToNew;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">cloneGraph</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        oldToNew = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">dfs</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(oldToNew.containsKey(node)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldToNew.get(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Node n = <span class=\"keyword\">new</span> Node(node.val);</span><br><span class=\"line\">        oldToNew.put(node, n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Node nb : node.neighbors) &#123;</span><br><span class=\"line\">            n.neighbors.add(dfs(nb));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5032e015-32ab-4a4f-a5f2-50063ada3264/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li><strong>HashMap can be a good solution for Graph problem</strong>\n<ul>\n<li>purpose of using map is to <strong>disconnect reference of nodes</strong></li>\n<li>the code below will exceed time limit</li>\n<li>because it will create new node and  reference all of other nodes infinitely</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">cloneGraph</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">dfs</span><span class=\"params\">(Node node)</span> </span>&#123;        </span><br><span class=\"line\">    Node n = <span class=\"keyword\">new</span> Node(node.val);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Node nb : node.neighbors) &#123;</span><br><span class=\"line\">        n.neighbors.add(dfs(nb));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><strong>dfs in Graph will traverse all the way to last node</strong>. only way dereference node is using map</li>\n</ol>\n"},{"title":"128. Longest Consecutive Sequence","catalog":true,"date":"2022-09-15T10:46:45.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- You must write an algorithm that runs in `O(n)` time.\n- -109 <= nums[i] <= 109\n\n## Solve by hands first\n\n---\n\nwe can think of Brute Force way but Its time complexity will be O(m*m) which doesn’t follow condition. Instead I can use PriorityQueue data structure to sort the array. Time complexity on enque is O(logN) which is less than O(N).\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if(nums.length == 0) return 0;\n        \n        PriorityQueue<Integer> pq = new PriorityQueue();\n        for(int n : nums) {\n            pq.add(n);\n        }\n        \n        int count = 1, max = 1;\n        int tmp = pq.poll();\n        while(!pq.isEmpty()) {    \n            int n = pq.poll(); \n            \n            if(n - tmp == 1) max = Math.max(max, ++count); \n            else if(n == tmp) continue;\n            else count = 1;\n            \n            tmp = n;\n        }\n        \n        return max;\n        \n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/714cdd3b-506a-4482-8f9d-2de81a3732ee/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. **Time complexity of enque and deque is O(logN)**\n","source":"_posts/128-Longest-Consecutive-Sequence.md","raw":"---\ntitle: \"128.\\_Longest Consecutive Sequence\"\ncatalog: true\ndate: 2022-09-15 19:46:45\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- You must write an algorithm that runs in `O(n)` time.\n- -109 <= nums[i] <= 109\n\n## Solve by hands first\n\n---\n\nwe can think of Brute Force way but Its time complexity will be O(m*m) which doesn’t follow condition. Instead I can use PriorityQueue data structure to sort the array. Time complexity on enque is O(logN) which is less than O(N).\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if(nums.length == 0) return 0;\n        \n        PriorityQueue<Integer> pq = new PriorityQueue();\n        for(int n : nums) {\n            pq.add(n);\n        }\n        \n        int count = 1, max = 1;\n        int tmp = pq.poll();\n        while(!pq.isEmpty()) {    \n            int n = pq.poll(); \n            \n            if(n - tmp == 1) max = Math.max(max, ++count); \n            else if(n == tmp) continue;\n            else count = 1;\n            \n            tmp = n;\n        }\n        \n        return max;\n        \n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/714cdd3b-506a-4482-8f9d-2de81a3732ee/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. **Time complexity of enque and deque is O(logN)**\n","slug":"128-Longest-Consecutive-Sequence","published":1,"updated":"2022-09-15T10:47:11.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc14000dqkcchu906hl0","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>You must write an algorithm that runs in <code>O(n)</code> time.</li>\n<li>-109 &lt;= nums[i] &lt;= 109</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can think of Brute Force way but Its time complexity will be O(m*m) which doesn’t follow condition. Instead I can use PriorityQueue data structure to sort the array. Time complexity on enque is O(logN) which is less than O(N).</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestConsecutive</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PriorityQueue&lt;Integer&gt; pq = <span class=\"keyword\">new</span> PriorityQueue();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">            pq.add(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>, max = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = pq.poll();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!pq.isEmpty()) &#123;    </span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = pq.poll(); </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n - tmp == <span class=\"number\">1</span>) max = Math.max(max, ++count); </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n == tmp) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            tmp = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/714cdd3b-506a-4482-8f9d-2de81a3732ee/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li><strong>Time complexity of enque and deque is O(logN)</strong></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>You must write an algorithm that runs in <code>O(n)</code> time.</li>\n<li>-109 &lt;= nums[i] &lt;= 109</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can think of Brute Force way but Its time complexity will be O(m*m) which doesn’t follow condition. Instead I can use PriorityQueue data structure to sort the array. Time complexity on enque is O(logN) which is less than O(N).</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestConsecutive</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        PriorityQueue&lt;Integer&gt; pq = <span class=\"keyword\">new</span> PriorityQueue();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">            pq.add(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>, max = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = pq.poll();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!pq.isEmpty()) &#123;    </span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = pq.poll(); </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n - tmp == <span class=\"number\">1</span>) max = Math.max(max, ++count); </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n == tmp) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            tmp = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/714cdd3b-506a-4482-8f9d-2de81a3732ee/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li><strong>Time complexity of enque and deque is O(logN)</strong></li>\n</ol>\n"},{"title":"136. Single Number","catalog":true,"date":"2022-10-23T14:39:38.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- find the single element in array\n- linear time complexity and constant extra space\n- element is between -3*10^4 and 3*10^4\n- can’t use sorting\n\n### **Edge cases**\n\n---\n\n- [2,2,1] → 1\n- [1] → 1\n- [1,2,3,1,2,4] → 4\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\neven though it has to be linear time complexity but I want to start with brute force way first. we can sort the array and use two pointer to find the target value. if the length of array is 1, return the value at index 0 since there is empty input array. sort the array in whichever order. create two pointer left and right. left start with 0 and right start with 1. if the value at index left and right is equals, increase 2 index and move on. because if we just move 1 index at a time, value at left and right index will be different and accidently return wrong answer. otherwise return current value. if there is nothing returned and return the last value of array since it can’t reach to it. Time complexity is O(nlog(n)) for dual pivot quick sort to sort the array and space complexity is O(1)\n\n```java\nif(nums.length == 1) return nums[0];\n\nArrays.sort(nums);\n\nint l = 0, r = 1;\nwhile(r < nums.length) {\n    if(nums[l] == nums[r]) {\n        l+=2; \n        r+=2;\n        continue;\n    }\n    return nums[l];\n}\nreturn nums[nums.length-1];\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nI can use XOR operator to optimize above solution by O(n). If we do XOR operation with the same value it will return 0. XOR operation with 0 and whatever number, it will return whatever number. we gonna use this behavior. So, there is only 1 single element, it means if we do XOR operation, the single element will be returned. For instance, [2,2,1] turn into 2 ^ 2 = 0 and 0 ^ 1 = 1. Time complexity is O(n) and space complexity is O(1)\n\n```java\nint ans = 0;\nfor(int n : nums) ans ^= n;\nreturn ans;\n```\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int ans = 0;\n        for(int n : nums) ans ^= n;\n        return ans;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da817482-331e-4647-8e4c-0f61237ea263/Untitled.png)\n\n### What I learned\n\n---\n\n1. bit manipulation can be good solution for array problem\n    - XOR : the same value will return 0\n","source":"_posts/136-Single-Number.md","raw":"---\ntitle: \"136.\\_Single Number\"\ncatalog: true\ndate: 2022-10-23 23:39:38\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- find the single element in array\n- linear time complexity and constant extra space\n- element is between -3*10^4 and 3*10^4\n- can’t use sorting\n\n### **Edge cases**\n\n---\n\n- [2,2,1] → 1\n- [1] → 1\n- [1,2,3,1,2,4] → 4\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\neven though it has to be linear time complexity but I want to start with brute force way first. we can sort the array and use two pointer to find the target value. if the length of array is 1, return the value at index 0 since there is empty input array. sort the array in whichever order. create two pointer left and right. left start with 0 and right start with 1. if the value at index left and right is equals, increase 2 index and move on. because if we just move 1 index at a time, value at left and right index will be different and accidently return wrong answer. otherwise return current value. if there is nothing returned and return the last value of array since it can’t reach to it. Time complexity is O(nlog(n)) for dual pivot quick sort to sort the array and space complexity is O(1)\n\n```java\nif(nums.length == 1) return nums[0];\n\nArrays.sort(nums);\n\nint l = 0, r = 1;\nwhile(r < nums.length) {\n    if(nums[l] == nums[r]) {\n        l+=2; \n        r+=2;\n        continue;\n    }\n    return nums[l];\n}\nreturn nums[nums.length-1];\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nI can use XOR operator to optimize above solution by O(n). If we do XOR operation with the same value it will return 0. XOR operation with 0 and whatever number, it will return whatever number. we gonna use this behavior. So, there is only 1 single element, it means if we do XOR operation, the single element will be returned. For instance, [2,2,1] turn into 2 ^ 2 = 0 and 0 ^ 1 = 1. Time complexity is O(n) and space complexity is O(1)\n\n```java\nint ans = 0;\nfor(int n : nums) ans ^= n;\nreturn ans;\n```\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int ans = 0;\n        for(int n : nums) ans ^= n;\n        return ans;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da817482-331e-4647-8e4c-0f61237ea263/Untitled.png)\n\n### What I learned\n\n---\n\n1. bit manipulation can be good solution for array problem\n    - XOR : the same value will return 0\n","slug":"136-Single-Number","published":1,"updated":"2022-10-23T14:39:55.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc15000eqkcc1j0xiidt","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>find the single element in array</li>\n<li>linear time complexity and constant extra space</li>\n<li>element is between -3<em>10^4 and 3</em>10^4</li>\n<li>can’t use sorting</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>[2,2,1] → 1</li>\n<li>[1] → 1</li>\n<li>[1,2,3,1,2,4] → 4</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>even though it has to be linear time complexity but I want to start with brute force way first. we can sort the array and use two pointer to find the target value. if the length of array is 1, return the value at index 0 since there is empty input array. sort the array in whichever order. create two pointer left and right. left start with 0 and right start with 1. if the value at index left and right is equals, increase 2 index and move on. because if we just move 1 index at a time, value at left and right index will be different and accidently return wrong answer. otherwise return current value. if there is nothing returned and return the last value of array since it can’t reach to it. Time complexity is O(nlog(n)) for dual pivot quick sort to sort the array and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(nums.length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">Arrays.sort(nums);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(r &lt; nums.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[l] == nums[r]) &#123;</span><br><span class=\"line\">        l+=<span class=\"number\">2</span>; </span><br><span class=\"line\">        r+=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> nums[nums.length-<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>I can use XOR operator to optimize above solution by O(n). If we do XOR operation with the same value it will return 0. XOR operation with 0 and whatever number, it will return whatever number. we gonna use this behavior. So, there is only 1 single element, it means if we do XOR operation, the single element will be returned. For instance, [2,2,1] turn into 2 ^ 2 = 0 and 0 ^ 1 = 1. Time complexity is O(n) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) ans ^= n;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) ans ^= n;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da817482-331e-4647-8e4c-0f61237ea263/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>bit manipulation can be good solution for array problem\n<ul>\n<li>XOR : the same value will return 0</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>find the single element in array</li>\n<li>linear time complexity and constant extra space</li>\n<li>element is between -3<em>10^4 and 3</em>10^4</li>\n<li>can’t use sorting</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>[2,2,1] → 1</li>\n<li>[1] → 1</li>\n<li>[1,2,3,1,2,4] → 4</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>even though it has to be linear time complexity but I want to start with brute force way first. we can sort the array and use two pointer to find the target value. if the length of array is 1, return the value at index 0 since there is empty input array. sort the array in whichever order. create two pointer left and right. left start with 0 and right start with 1. if the value at index left and right is equals, increase 2 index and move on. because if we just move 1 index at a time, value at left and right index will be different and accidently return wrong answer. otherwise return current value. if there is nothing returned and return the last value of array since it can’t reach to it. Time complexity is O(nlog(n)) for dual pivot quick sort to sort the array and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(nums.length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">Arrays.sort(nums);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(r &lt; nums.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[l] == nums[r]) &#123;</span><br><span class=\"line\">        l+=<span class=\"number\">2</span>; </span><br><span class=\"line\">        r+=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> nums[nums.length-<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>I can use XOR operator to optimize above solution by O(n). If we do XOR operation with the same value it will return 0. XOR operation with 0 and whatever number, it will return whatever number. we gonna use this behavior. So, there is only 1 single element, it means if we do XOR operation, the single element will be returned. For instance, [2,2,1] turn into 2 ^ 2 = 0 and 0 ^ 1 = 1. Time complexity is O(n) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) ans ^= n;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans;</span><br></pre></td></tr></table></figure>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) ans ^= n;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da817482-331e-4647-8e4c-0f61237ea263/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>bit manipulation can be good solution for array problem\n<ul>\n<li>XOR : the same value will return 0</li>\n</ul>\n</li>\n</ol>\n"},{"title":"139. Word Break","catalog":true,"date":"2022-10-22T08:40:18.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- return true if s can be segmented into one or more dictionary words.\n- we can reuse the word in dictionary\n- s should consisted of combination of words in dictionary\n\n### **Edge cases**\n\n---\n\n- [abcdefg], [abc, de, fg] → true\n- [abcdeabc], [abc, de] → true\n- [abcdeabc], [abc, abcd, ea] → false\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nIterate through each index and check the word in dictinary. Initially setup the first index of dp as true. it means we can compare the word in dictionary to the substring from index which was true to length of word. if the current index is not true, it means we don’t need to make substring out of word. it makes us easily skip to the next index. when the index reaches to the last index (s.length()) and its dp value is true. we found the segements string out of word. Time complexity is O(length of string * length of wordDict) and space complexity is O(length of string)\n\n```java\nboolean[] dp = new boolean[s.length() + 1];\ndp[0] = true; \nfor(int i = 0; i <= s.length(); i++) {\n    for(String w : wordDict) {\n        if(dp[i] && i + w.length() <= s.length() && s.substring(i, i + w.length()).equals(w)) {\n            dp[i + w.length()] = true;\n        }\n    }\n}\nreturn dp[s.length()];\n```\n\nin many solution, it breaks the loop if they meet the if statement. but we don’t actually need to do it. \n\n![ACBC727B-C97A-4424-89CE-487FD86C4663.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/92476fdf-d45e-4b62-b57b-e2955b340e4d/ACBC727B-C97A-4424-89CE-487FD86C4663.jpeg)\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n*the interviewer can provide you with some hints to unblock you*\n\n*it’s okay to ask the interviewer for direction.*\n\n### **Coding**\n\n---\n\n```java\npublic class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true; \n        for(int i = 0; i <= s.length(); i++) {\n            for(String w : wordDict) {\n                if(dp[i] && i + w.length() <= s.length() && s.substring(i, i + w.length()).equals(w)) {\n                    dp[i + w.length()] = true;\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f120d056-355d-4c6a-b1ad-40e15df878c2/Untitled.png)\n\n### What I learned\n\n---\n\n1. **dp array can be mark flag** whether substring start with the current index can be valid or not.\n2. try not to make tree for dynamic programming. just use the memoization\n","source":"_posts/139-Word-Break.md","raw":"---\ntitle: \"139.\\_Word Break\"\ncatalog: true\ndate: 2022-10-22 17:40:18\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- return true if s can be segmented into one or more dictionary words.\n- we can reuse the word in dictionary\n- s should consisted of combination of words in dictionary\n\n### **Edge cases**\n\n---\n\n- [abcdefg], [abc, de, fg] → true\n- [abcdeabc], [abc, de] → true\n- [abcdeabc], [abc, abcd, ea] → false\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nIterate through each index and check the word in dictinary. Initially setup the first index of dp as true. it means we can compare the word in dictionary to the substring from index which was true to length of word. if the current index is not true, it means we don’t need to make substring out of word. it makes us easily skip to the next index. when the index reaches to the last index (s.length()) and its dp value is true. we found the segements string out of word. Time complexity is O(length of string * length of wordDict) and space complexity is O(length of string)\n\n```java\nboolean[] dp = new boolean[s.length() + 1];\ndp[0] = true; \nfor(int i = 0; i <= s.length(); i++) {\n    for(String w : wordDict) {\n        if(dp[i] && i + w.length() <= s.length() && s.substring(i, i + w.length()).equals(w)) {\n            dp[i + w.length()] = true;\n        }\n    }\n}\nreturn dp[s.length()];\n```\n\nin many solution, it breaks the loop if they meet the if statement. but we don’t actually need to do it. \n\n![ACBC727B-C97A-4424-89CE-487FD86C4663.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/92476fdf-d45e-4b62-b57b-e2955b340e4d/ACBC727B-C97A-4424-89CE-487FD86C4663.jpeg)\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n*the interviewer can provide you with some hints to unblock you*\n\n*it’s okay to ask the interviewer for direction.*\n\n### **Coding**\n\n---\n\n```java\npublic class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true; \n        for(int i = 0; i <= s.length(); i++) {\n            for(String w : wordDict) {\n                if(dp[i] && i + w.length() <= s.length() && s.substring(i, i + w.length()).equals(w)) {\n                    dp[i + w.length()] = true;\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f120d056-355d-4c6a-b1ad-40e15df878c2/Untitled.png)\n\n### What I learned\n\n---\n\n1. **dp array can be mark flag** whether substring start with the current index can be valid or not.\n2. try not to make tree for dynamic programming. just use the memoization\n","slug":"139-Word-Break","published":1,"updated":"2022-10-22T08:41:00.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc15000fqkcc9l8wt6dp","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>return true if s can be segmented into one or more dictionary words.</li>\n<li>we can reuse the word in dictionary</li>\n<li>s should consisted of combination of words in dictionary</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>[abcdefg], [abc, de, fg] → true</li>\n<li>[abcdeabc], [abc, de] → true</li>\n<li>[abcdeabc], [abc, abcd, ea] → false</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>Iterate through each index and check the word in dictinary. Initially setup the first index of dp as true. it means we can compare the word in dictionary to the substring from index which was true to length of word. if the current index is not true, it means we don’t need to make substring out of word. it makes us easily skip to the next index. when the index reaches to the last index (s.length()) and its dp value is true. we found the segements string out of word. Time complexity is O(length of string * length of wordDict) and space complexity is O(length of string)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[s.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">dp[<span class=\"number\">0</span>] = <span class=\"keyword\">true</span>; </span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= s.length(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(String w : wordDict) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[i] &amp;&amp; i + w.length() &lt;= s.length() &amp;&amp; s.substring(i, i + w.length()).equals(w)) &#123;</span><br><span class=\"line\">            dp[i + w.length()] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[s.length()];</span><br></pre></td></tr></table></figure>\n<p>in many solution, it breaks the loop if they meet the if statement. but we don’t actually need to do it.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/92476fdf-d45e-4b62-b57b-e2955b340e4d/ACBC727B-C97A-4424-89CE-487FD86C4663.jpeg\" alt=\"ACBC727B-C97A-4424-89CE-487FD86C4663.jpeg\"></p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p><em>the interviewer can provide you with some hints to unblock you</em></p>\n<p><em>it’s okay to ask the interviewer for direction.</em></p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">wordBreak</span><span class=\"params\">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[s.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"keyword\">true</span>; </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(String w : wordDict) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(dp[i] &amp;&amp; i + w.length() &lt;= s.length() &amp;&amp; s.substring(i, i + w.length()).equals(w)) &#123;</span><br><span class=\"line\">                    dp[i + w.length()] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[s.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f120d056-355d-4c6a-b1ad-40e15df878c2/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li><strong>dp array can be mark flag</strong> whether substring start with the current index can be valid or not.</li>\n<li>try not to make tree for dynamic programming. just use the memoization</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>return true if s can be segmented into one or more dictionary words.</li>\n<li>we can reuse the word in dictionary</li>\n<li>s should consisted of combination of words in dictionary</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>[abcdefg], [abc, de, fg] → true</li>\n<li>[abcdeabc], [abc, de] → true</li>\n<li>[abcdeabc], [abc, abcd, ea] → false</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>Iterate through each index and check the word in dictinary. Initially setup the first index of dp as true. it means we can compare the word in dictionary to the substring from index which was true to length of word. if the current index is not true, it means we don’t need to make substring out of word. it makes us easily skip to the next index. when the index reaches to the last index (s.length()) and its dp value is true. we found the segements string out of word. Time complexity is O(length of string * length of wordDict) and space complexity is O(length of string)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[s.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">dp[<span class=\"number\">0</span>] = <span class=\"keyword\">true</span>; </span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= s.length(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(String w : wordDict) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[i] &amp;&amp; i + w.length() &lt;= s.length() &amp;&amp; s.substring(i, i + w.length()).equals(w)) &#123;</span><br><span class=\"line\">            dp[i + w.length()] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[s.length()];</span><br></pre></td></tr></table></figure>\n<p>in many solution, it breaks the loop if they meet the if statement. but we don’t actually need to do it.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/92476fdf-d45e-4b62-b57b-e2955b340e4d/ACBC727B-C97A-4424-89CE-487FD86C4663.jpeg\" alt=\"ACBC727B-C97A-4424-89CE-487FD86C4663.jpeg\"></p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p><em>the interviewer can provide you with some hints to unblock you</em></p>\n<p><em>it’s okay to ask the interviewer for direction.</em></p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">wordBreak</span><span class=\"params\">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[s.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"keyword\">true</span>; </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(String w : wordDict) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(dp[i] &amp;&amp; i + w.length() &lt;= s.length() &amp;&amp; s.substring(i, i + w.length()).equals(w)) &#123;</span><br><span class=\"line\">                    dp[i + w.length()] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[s.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f120d056-355d-4c6a-b1ad-40e15df878c2/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li><strong>dp array can be mark flag</strong> whether substring start with the current index can be valid or not.</li>\n<li>try not to make tree for dynamic programming. just use the memoization</li>\n</ol>\n"},{"title":"125. Valid Palindrome","catalog":true,"date":"2022-10-17T14:46:56.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- after converting all uppercase letters into lowercase letters\n- removing all non-alphanumeric characters\n- Alphanumeric characters include letters and numbers\n- return `true` *if it is a **palindrome**, or* `false` *otherwise*\n\n### **Edge cases**\n\n---\n\na b2b A → ab2ba\n\n2 → 2\n\na → a\n\nAba → aba\n\n! @ ! 2 → 2\n\n- space\n- letter\n- numeric\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nCheck each element if it’s letter or numeric. if the character is letter and uppercase, convert it to lowercase. \n\nAfter iteration complete, check if the string is palindrome or not\n\nTime complexity is O(n)\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can just compare from very left and right characters. if each of the character is not letter or digits then move the pointer to left or right. otherwise compare the chrarcter of left and right index, if those are not the same character then return false, otherwise move the pointer to left and right.\n\nTime complexity is O(n)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        int l = 0, r = s.length() - 1;\n        while(l <= r) {\n            if(!Character.isLetterOrDigit(s.charAt(l))) l++; \n            else if(!Character.isLetterOrDigit(s.charAt(r))) r--;\n            else {\n                if(Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r))) return false;\n                l++; r--;\n            }\n        }\n        return true;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad2a96b5-ad39-4fb4-9e66-dba769650eda/Untitled.png)\n\n### What I learned\n\n---\n\n1. Compare from left and right index to solve the Palindrome problem\n","source":"_posts/125-Valid-Palindrome.md","raw":"---\ntitle: \"125.\\_Valid Palindrome\"\ncatalog: true\ndate: 2022-10-17 23:46:56\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- after converting all uppercase letters into lowercase letters\n- removing all non-alphanumeric characters\n- Alphanumeric characters include letters and numbers\n- return `true` *if it is a **palindrome**, or* `false` *otherwise*\n\n### **Edge cases**\n\n---\n\na b2b A → ab2ba\n\n2 → 2\n\na → a\n\nAba → aba\n\n! @ ! 2 → 2\n\n- space\n- letter\n- numeric\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nCheck each element if it’s letter or numeric. if the character is letter and uppercase, convert it to lowercase. \n\nAfter iteration complete, check if the string is palindrome or not\n\nTime complexity is O(n)\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can just compare from very left and right characters. if each of the character is not letter or digits then move the pointer to left or right. otherwise compare the chrarcter of left and right index, if those are not the same character then return false, otherwise move the pointer to left and right.\n\nTime complexity is O(n)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        int l = 0, r = s.length() - 1;\n        while(l <= r) {\n            if(!Character.isLetterOrDigit(s.charAt(l))) l++; \n            else if(!Character.isLetterOrDigit(s.charAt(r))) r--;\n            else {\n                if(Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r))) return false;\n                l++; r--;\n            }\n        }\n        return true;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad2a96b5-ad39-4fb4-9e66-dba769650eda/Untitled.png)\n\n### What I learned\n\n---\n\n1. Compare from left and right index to solve the Palindrome problem\n","slug":"125-Valid-Palindrome","published":1,"updated":"2022-10-17T16:38:26.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc15000gqkcc46rs21xo","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>after converting all uppercase letters into lowercase letters</li>\n<li>removing all non-alphanumeric characters</li>\n<li>Alphanumeric characters include letters and numbers</li>\n<li>return <code>true</code> <em>if it is a <strong>palindrome</strong>, or</em> <code>false</code> <em>otherwise</em></li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<p>a b2b A → ab2ba</p>\n<p>2 → 2</p>\n<p>a → a</p>\n<p>Aba → aba</p>\n<p>! @ ! 2 → 2</p>\n<ul>\n<li>space</li>\n<li>letter</li>\n<li>numeric</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>Check each element if it’s letter or numeric. if the character is letter and uppercase, convert it to lowercase.</p>\n<p>After iteration complete, check if the string is palindrome or not</p>\n<p>Time complexity is O(n)</p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>We can just compare from very left and right characters. if each of the character is not letter or digits then move the pointer to left or right. otherwise compare the chrarcter of left and right index, if those are not the same character then return false, otherwise move the pointer to left and right.</p>\n<p>Time complexity is O(n)</p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Character.isLetterOrDigit(s.charAt(l))) l++; </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!Character.isLetterOrDigit(s.charAt(r))) r--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r))) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                l++; r--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad2a96b5-ad39-4fb4-9e66-dba769650eda/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>Compare from left and right index to solve the Palindrome problem</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>after converting all uppercase letters into lowercase letters</li>\n<li>removing all non-alphanumeric characters</li>\n<li>Alphanumeric characters include letters and numbers</li>\n<li>return <code>true</code> <em>if it is a <strong>palindrome</strong>, or</em> <code>false</code> <em>otherwise</em></li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<p>a b2b A → ab2ba</p>\n<p>2 → 2</p>\n<p>a → a</p>\n<p>Aba → aba</p>\n<p>! @ ! 2 → 2</p>\n<ul>\n<li>space</li>\n<li>letter</li>\n<li>numeric</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>Check each element if it’s letter or numeric. if the character is letter and uppercase, convert it to lowercase.</p>\n<p>After iteration complete, check if the string is palindrome or not</p>\n<p>Time complexity is O(n)</p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>We can just compare from very left and right characters. if each of the character is not letter or digits then move the pointer to left or right. otherwise compare the chrarcter of left and right index, if those are not the same character then return false, otherwise move the pointer to left and right.</p>\n<p>Time complexity is O(n)</p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Character.isLetterOrDigit(s.charAt(l))) l++; </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!Character.isLetterOrDigit(s.charAt(r))) r--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r))) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                l++; r--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad2a96b5-ad39-4fb4-9e66-dba769650eda/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>Compare from left and right index to solve the Palindrome problem</li>\n</ol>\n"},{"title":"141. Linked List Cycle","catalog":true,"date":"2022-09-23T10:44:36.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- determine if the linked list has a cycle in it.\n- `pos` is used to denote the index of the node\n- `pos` is `-1` or a **valid index** in the linked-list.\n- The number of the nodes in the list is in the range `[0, 10^4]`.\n- `10^5 <= Node.val <= 10^5`\n\n## Solve by hands first\n\n---\n\nEach node in list has its own unique memory address. **we can store them in HashSet and during the iteration if there is value in HashSet exist then we can return true**. Time complexity is O(n) and space complexity is O(n)\n\n## Solution\n\n---\n\n```java\npublic class Solution {\n    \n    public boolean hasCycle(ListNode head) {\n        if(head == null) return false;\n        \n        Set<ListNode> s = new HashSet();\n        \n        while(head.next != null) {\n            if(s.contains(head)) return true;\n            s.add(head);\n            head = head.next;\n        }\n        return false;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/21a3df08-f29d-4f0a-ad7f-7fc58ba80a3f/Untitled.png)\n\nis there any way lower than space complexity O(n)?\n\nIf we use the **tortoise and hare algorithm then time complexity is O(n) and space complexity is O(1)**\n\n```java\npublic class Solution {\n    \n    public boolean hasCycle(ListNode head) {\n        \n        ListNode slow = head, fast = head;\n        \n        while(fast != null && fast.next != null) { // fast pointer reach to the last node quicker than slow pointer\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if(slow == fast) return true;\n        }\n        return false;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5bd3c9f7-ec04-4ead-91bc-9898ac1c6d72/Untitled.png)\n\nfast pointer reach to the last node quicker than slow pointer. **so we can check the loop condition at the fast node**\n\n## Lesson I learnt\n\n---\n\n1. [Floyd's tortoise and hare algorithm](https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare)\n    - pointer algorithm that uses only two pointers\n    - move through the sequence at different speeds\n    - **if slow pointer and fast pointer meet, then it’s cylce!**\n    - but what if cycle is long enough??\n    - it’s always O(n)\n        - every iteration distance between slow and fast pointer decrease 1 at a time!\n        - if the entire length of list is n then the maximum gap between two pointer would be n, it ended up meeting two pointers after O(n) time\n        - so total time complexity is O(2n) which is equals to O(n)\n    - fast node always reach the last node earlier than slow node. so **check the last node with fast pointer**\n2. Don’t compare value of node, **compare address of node!**\n    \n    ```json\n    Set<Node> s\n    ```\n","source":"_posts/141-Linked-List-Cycle.md","raw":"---\ntitle: \"141.\\_Linked List Cycle\"\ncatalog: true\ndate: 2022-09-23 19:44:36\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- determine if the linked list has a cycle in it.\n- `pos` is used to denote the index of the node\n- `pos` is `-1` or a **valid index** in the linked-list.\n- The number of the nodes in the list is in the range `[0, 10^4]`.\n- `10^5 <= Node.val <= 10^5`\n\n## Solve by hands first\n\n---\n\nEach node in list has its own unique memory address. **we can store them in HashSet and during the iteration if there is value in HashSet exist then we can return true**. Time complexity is O(n) and space complexity is O(n)\n\n## Solution\n\n---\n\n```java\npublic class Solution {\n    \n    public boolean hasCycle(ListNode head) {\n        if(head == null) return false;\n        \n        Set<ListNode> s = new HashSet();\n        \n        while(head.next != null) {\n            if(s.contains(head)) return true;\n            s.add(head);\n            head = head.next;\n        }\n        return false;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/21a3df08-f29d-4f0a-ad7f-7fc58ba80a3f/Untitled.png)\n\nis there any way lower than space complexity O(n)?\n\nIf we use the **tortoise and hare algorithm then time complexity is O(n) and space complexity is O(1)**\n\n```java\npublic class Solution {\n    \n    public boolean hasCycle(ListNode head) {\n        \n        ListNode slow = head, fast = head;\n        \n        while(fast != null && fast.next != null) { // fast pointer reach to the last node quicker than slow pointer\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if(slow == fast) return true;\n        }\n        return false;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5bd3c9f7-ec04-4ead-91bc-9898ac1c6d72/Untitled.png)\n\nfast pointer reach to the last node quicker than slow pointer. **so we can check the loop condition at the fast node**\n\n## Lesson I learnt\n\n---\n\n1. [Floyd's tortoise and hare algorithm](https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare)\n    - pointer algorithm that uses only two pointers\n    - move through the sequence at different speeds\n    - **if slow pointer and fast pointer meet, then it’s cylce!**\n    - but what if cycle is long enough??\n    - it’s always O(n)\n        - every iteration distance between slow and fast pointer decrease 1 at a time!\n        - if the entire length of list is n then the maximum gap between two pointer would be n, it ended up meeting two pointers after O(n) time\n        - so total time complexity is O(2n) which is equals to O(n)\n    - fast node always reach the last node earlier than slow node. so **check the last node with fast pointer**\n2. Don’t compare value of node, **compare address of node!**\n    \n    ```json\n    Set<Node> s\n    ```\n","slug":"141-Linked-List-Cycle","published":1,"updated":"2022-09-23T10:45:08.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc16000hqkccyeaydmat","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>determine if the linked list has a cycle in it.</li>\n<li><code>pos</code> is used to denote the index of the node</li>\n<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n<li>The number of the nodes in the list is in the range <code>[0, 10^4]</code>.</li>\n<li><code>10^5 &lt;= Node.val &lt;= 10^5</code></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>Each node in list has its own unique memory address. <strong>we can store them in HashSet and during the iteration if there is value in HashSet exist then we can return true</strong>. Time complexity is O(n) and space complexity is O(n)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Set&lt;ListNode&gt; s = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.contains(head)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            s.add(head);</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/21a3df08-f29d-4f0a-ad7f-7fc58ba80a3f/Untitled.png\" alt=\"Untitled\"></p>\n<p>is there any way lower than space complexity O(n)?</p>\n<p>If we use the <strong>tortoise and hare algorithm then time complexity is O(n) and space complexity is O(1)</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode slow = head, fast = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// fast pointer reach to the last node quicker than slow pointer</span></span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(slow == fast) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5bd3c9f7-ec04-4ead-91bc-9898ac1c6d72/Untitled.png\" alt=\"Untitled\"></p>\n<p>fast pointer reach to the last node quicker than slow pointer. <strong>so we can check the loop condition at the fast node</strong></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p><a href=\"https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare\" target=\"_blank\" rel=\"noopener\">Floyd’s tortoise and hare algorithm</a></p>\n<ul>\n<li>pointer algorithm that uses only two pointers</li>\n<li>move through the sequence at different speeds</li>\n<li><strong>if slow pointer and fast pointer meet, then it’s cylce!</strong></li>\n<li>but what if cycle is long enough??</li>\n<li>it’s always O(n)\n<ul>\n<li>every iteration distance between slow and fast pointer decrease 1 at a time!</li>\n<li>if the entire length of list is n then the maximum gap between two pointer would be n, it ended up meeting two pointers after O(n) time</li>\n<li>so total time complexity is O(2n) which is equals to O(n)</li>\n</ul>\n</li>\n<li>fast node always reach the last node earlier than slow node. so <strong>check the last node with fast pointer</strong></li>\n</ul>\n</li>\n<li>\n<p>Don’t compare value of node, <strong>compare address of node!</strong></p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Node&gt; s</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>determine if the linked list has a cycle in it.</li>\n<li><code>pos</code> is used to denote the index of the node</li>\n<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n<li>The number of the nodes in the list is in the range <code>[0, 10^4]</code>.</li>\n<li><code>10^5 &lt;= Node.val &lt;= 10^5</code></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>Each node in list has its own unique memory address. <strong>we can store them in HashSet and during the iteration if there is value in HashSet exist then we can return true</strong>. Time complexity is O(n) and space complexity is O(n)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Set&lt;ListNode&gt; s = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.contains(head)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            s.add(head);</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/21a3df08-f29d-4f0a-ad7f-7fc58ba80a3f/Untitled.png\" alt=\"Untitled\"></p>\n<p>is there any way lower than space complexity O(n)?</p>\n<p>If we use the <strong>tortoise and hare algorithm then time complexity is O(n) and space complexity is O(1)</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode slow = head, fast = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// fast pointer reach to the last node quicker than slow pointer</span></span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(slow == fast) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5bd3c9f7-ec04-4ead-91bc-9898ac1c6d72/Untitled.png\" alt=\"Untitled\"></p>\n<p>fast pointer reach to the last node quicker than slow pointer. <strong>so we can check the loop condition at the fast node</strong></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p><a href=\"https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare\" target=\"_blank\" rel=\"noopener\">Floyd’s tortoise and hare algorithm</a></p>\n<ul>\n<li>pointer algorithm that uses only two pointers</li>\n<li>move through the sequence at different speeds</li>\n<li><strong>if slow pointer and fast pointer meet, then it’s cylce!</strong></li>\n<li>but what if cycle is long enough??</li>\n<li>it’s always O(n)\n<ul>\n<li>every iteration distance between slow and fast pointer decrease 1 at a time!</li>\n<li>if the entire length of list is n then the maximum gap between two pointer would be n, it ended up meeting two pointers after O(n) time</li>\n<li>so total time complexity is O(2n) which is equals to O(n)</li>\n</ul>\n</li>\n<li>fast node always reach the last node earlier than slow node. so <strong>check the last node with fast pointer</strong></li>\n</ul>\n</li>\n<li>\n<p>Don’t compare value of node, <strong>compare address of node!</strong></p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Node&gt; s</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"152. Maximum Product Subarray","catalog":true,"date":"2022-10-02T10:53:37.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- find a **contiguous non-empty subarray** within the array that has **the largest product**\n- and return *the product*\n- the answer will fit in a **32-bit** integer.\n\n## Solve by hands first\n\n---\n\nwe can start with brute force. but then its time complexity will be O(n*n)\n\nanother option can be dynamic programming. Time complexity is O(n)\n\n![379A741F-7B28-445A-A702-04CCF520CAF7.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a32b6443-e355-4ca5-a503-4c1e1dc63e96/379A741F-7B28-445A-A702-04CCF520CAF7.jpeg)\n\nwe have to consider two different cases, max and min. since there are positive and negative element in array, product can be positive or negative. \n\n1. maximum\n2. minimum\n\nwe can seperate maximum and minimum cases\n\n1. positive\n2. negative \n    - if previous calculation was positive\n        - after calculation with negative value will be minimum\n        - negative value itself will be maximum\n    - if previous calculation was negative\n        - after calculation with negative value will be maximum\n        - negative value itself will be minimum\n        \n\ncompare current maximum value and previous maximum value\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int maxProduct(int[] nums) {\n        int ans = Integer.MIN_VALUE;\n        for(int num : nums) {\n            ans = Math.max(ans, num);\n        }\n        int max = 1, min = 1;\n        for(int n : nums) {\n            if(n == 0) {\n                max = 1;\n                min = 1;\n                continue;\n            }\n            int nmax = max * n;\n            int nmin = min * n;\n            max = Math.max(Math.max(nmax, nmin), n);\n            min = Math.min(Math.min(nmax, nmin), n);\n            ans = Math.max(max, ans);\n        }\n        return ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4605588c-5865-4608-b674-114838d38486/Untitled.png)\n\n## Lesson I learnt\n\n---\n","source":"_posts/152-Maximum-Product-Subarray.md","raw":"---\ntitle: \"152.\\_Maximum Product Subarray\"\ncatalog: true\ndate: 2022-10-02 19:53:37\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- find a **contiguous non-empty subarray** within the array that has **the largest product**\n- and return *the product*\n- the answer will fit in a **32-bit** integer.\n\n## Solve by hands first\n\n---\n\nwe can start with brute force. but then its time complexity will be O(n*n)\n\nanother option can be dynamic programming. Time complexity is O(n)\n\n![379A741F-7B28-445A-A702-04CCF520CAF7.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a32b6443-e355-4ca5-a503-4c1e1dc63e96/379A741F-7B28-445A-A702-04CCF520CAF7.jpeg)\n\nwe have to consider two different cases, max and min. since there are positive and negative element in array, product can be positive or negative. \n\n1. maximum\n2. minimum\n\nwe can seperate maximum and minimum cases\n\n1. positive\n2. negative \n    - if previous calculation was positive\n        - after calculation with negative value will be minimum\n        - negative value itself will be maximum\n    - if previous calculation was negative\n        - after calculation with negative value will be maximum\n        - negative value itself will be minimum\n        \n\ncompare current maximum value and previous maximum value\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int maxProduct(int[] nums) {\n        int ans = Integer.MIN_VALUE;\n        for(int num : nums) {\n            ans = Math.max(ans, num);\n        }\n        int max = 1, min = 1;\n        for(int n : nums) {\n            if(n == 0) {\n                max = 1;\n                min = 1;\n                continue;\n            }\n            int nmax = max * n;\n            int nmin = min * n;\n            max = Math.max(Math.max(nmax, nmin), n);\n            min = Math.min(Math.min(nmax, nmin), n);\n            ans = Math.max(max, ans);\n        }\n        return ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4605588c-5865-4608-b674-114838d38486/Untitled.png)\n\n## Lesson I learnt\n\n---\n","slug":"152-Maximum-Product-Subarray","published":1,"updated":"2022-10-02T10:53:52.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc16000iqkccyp5m9su3","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>find a <strong>contiguous non-empty subarray</strong> within the array that has <strong>the largest product</strong></li>\n<li>and return <em>the product</em></li>\n<li>the answer will fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can start with brute force. but then its time complexity will be O(n*n)</p>\n<p>another option can be dynamic programming. Time complexity is O(n)</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a32b6443-e355-4ca5-a503-4c1e1dc63e96/379A741F-7B28-445A-A702-04CCF520CAF7.jpeg\" alt=\"379A741F-7B28-445A-A702-04CCF520CAF7.jpeg\"></p>\n<p>we have to consider two different cases, max and min. since there are positive and negative element in array, product can be positive or negative.</p>\n<ol>\n<li>maximum</li>\n<li>minimum</li>\n</ol>\n<p>we can seperate maximum and minimum cases</p>\n<ol>\n<li>positive</li>\n<li>negative\n<ul>\n<li>if previous calculation was positive\n<ul>\n<li>after calculation with negative value will be minimum</li>\n<li>negative value itself will be maximum</li>\n</ul>\n</li>\n<li>if previous calculation was negative\n<ul>\n<li>after calculation with negative value will be maximum</li>\n<li>negative value itself will be minimum</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>compare current maximum value and previous maximum value</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            ans = Math.max(ans, num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">1</span>, min = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                max = <span class=\"number\">1</span>;</span><br><span class=\"line\">                min = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nmax = max * n;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nmin = min * n;</span><br><span class=\"line\">            max = Math.max(Math.max(nmax, nmin), n);</span><br><span class=\"line\">            min = Math.min(Math.min(nmax, nmin), n);</span><br><span class=\"line\">            ans = Math.max(max, ans);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4605588c-5865-4608-b674-114838d38486/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>find a <strong>contiguous non-empty subarray</strong> within the array that has <strong>the largest product</strong></li>\n<li>and return <em>the product</em></li>\n<li>the answer will fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can start with brute force. but then its time complexity will be O(n*n)</p>\n<p>another option can be dynamic programming. Time complexity is O(n)</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a32b6443-e355-4ca5-a503-4c1e1dc63e96/379A741F-7B28-445A-A702-04CCF520CAF7.jpeg\" alt=\"379A741F-7B28-445A-A702-04CCF520CAF7.jpeg\"></p>\n<p>we have to consider two different cases, max and min. since there are positive and negative element in array, product can be positive or negative.</p>\n<ol>\n<li>maximum</li>\n<li>minimum</li>\n</ol>\n<p>we can seperate maximum and minimum cases</p>\n<ol>\n<li>positive</li>\n<li>negative\n<ul>\n<li>if previous calculation was positive\n<ul>\n<li>after calculation with negative value will be minimum</li>\n<li>negative value itself will be maximum</li>\n</ul>\n</li>\n<li>if previous calculation was negative\n<ul>\n<li>after calculation with negative value will be maximum</li>\n<li>negative value itself will be minimum</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>compare current maximum value and previous maximum value</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            ans = Math.max(ans, num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">1</span>, min = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                max = <span class=\"number\">1</span>;</span><br><span class=\"line\">                min = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nmax = max * n;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nmin = min * n;</span><br><span class=\"line\">            max = Math.max(Math.max(nmax, nmin), n);</span><br><span class=\"line\">            min = Math.min(Math.min(nmax, nmin), n);</span><br><span class=\"line\">            ans = Math.max(max, ans);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4605588c-5865-4608-b674-114838d38486/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n"},{"title":"153. Find Minimum in Rotated Sorted Array","catalog":true,"date":"2022-09-17T09:47:29.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- array was originally sorted by ascending order\n- rotate array between 1 to n times\n- array has unique element\n- return the minimum element of this array\n- algorithm has to run in O(logN)\n\n## Solve by hands first\n\n---\n\nIn array problem, if the algorithm has to run in O(logN), we can come up with Binary search initially. If the array supposed to be sorted in ascending order and rotate it to the right then sub arrays from pivot index has minimum value or **just find minimum value with Binary search**.\n\n![C4460C45-0244-485C-A8EA-9D400DCDF0BD.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90b7b3e8-4ab2-4e1f-b740-cbf933601239/C4460C45-0244-485C-A8EA-9D400DCDF0BD.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int findMin(int[] nums) {\n        \n        int l = 0, r = nums.length - 1;\n        \n        while(l < r) {\n            int m = l + (r - l)/2;\n            if(nums[m] > nums[r]) l = m + 1;\n            else r = m;\n        }\n        \n        return nums[r];\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3caae118-0fcc-4c6d-b4ee-cbd7b492a97e/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. **Choose the left or right index for answer**\n2. **One of the left or right index has to be the same as middle index in equals if statement**\n\n```java\nwhile(l < r) {\n    int m = l + (r - l)/2;\n\t\tif(nums[m] <= nums[r]) r = m;   // value at m and r is euqual, then r move to m\n    else l = m + 1;\n}\n```\n","source":"_posts/153-Find-Minimum-in-Rotated-Sorted-Array.md","raw":"---\ntitle: \"153.\\_Find Minimum in Rotated Sorted Array\"\ncatalog: true\ndate: 2022-09-17 18:47:29\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- array was originally sorted by ascending order\n- rotate array between 1 to n times\n- array has unique element\n- return the minimum element of this array\n- algorithm has to run in O(logN)\n\n## Solve by hands first\n\n---\n\nIn array problem, if the algorithm has to run in O(logN), we can come up with Binary search initially. If the array supposed to be sorted in ascending order and rotate it to the right then sub arrays from pivot index has minimum value or **just find minimum value with Binary search**.\n\n![C4460C45-0244-485C-A8EA-9D400DCDF0BD.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90b7b3e8-4ab2-4e1f-b740-cbf933601239/C4460C45-0244-485C-A8EA-9D400DCDF0BD.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int findMin(int[] nums) {\n        \n        int l = 0, r = nums.length - 1;\n        \n        while(l < r) {\n            int m = l + (r - l)/2;\n            if(nums[m] > nums[r]) l = m + 1;\n            else r = m;\n        }\n        \n        return nums[r];\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3caae118-0fcc-4c6d-b4ee-cbd7b492a97e/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. **Choose the left or right index for answer**\n2. **One of the left or right index has to be the same as middle index in equals if statement**\n\n```java\nwhile(l < r) {\n    int m = l + (r - l)/2;\n\t\tif(nums[m] <= nums[r]) r = m;   // value at m and r is euqual, then r move to m\n    else l = m + 1;\n}\n```\n","slug":"153-Find-Minimum-in-Rotated-Sorted-Array","published":1,"updated":"2022-09-17T09:48:52.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc16000jqkccb8punavh","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>array was originally sorted by ascending order</li>\n<li>rotate array between 1 to n times</li>\n<li>array has unique element</li>\n<li>return the minimum element of this array</li>\n<li>algorithm has to run in O(logN)</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>In array problem, if the algorithm has to run in O(logN), we can come up with Binary search initially. If the array supposed to be sorted in ascending order and rotate it to the right then sub arrays from pivot index has minimum value or <strong>just find minimum value with Binary search</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90b7b3e8-4ab2-4e1f-b740-cbf933601239/C4460C45-0244-485C-A8EA-9D400DCDF0BD.jpeg\" alt=\"C4460C45-0244-485C-A8EA-9D400DCDF0BD.jpeg\"></p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = l + (r - l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] &gt; nums[r]) l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> r = m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[r];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3caae118-0fcc-4c6d-b4ee-cbd7b492a97e/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li><strong>Choose the left or right index for answer</strong></li>\n<li><strong>One of the left or right index has to be the same as middle index in equals if statement</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = l + (r - l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[m] &lt;= nums[r]) r = m;   <span class=\"comment\">// value at m and r is euqual, then r move to m</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>array was originally sorted by ascending order</li>\n<li>rotate array between 1 to n times</li>\n<li>array has unique element</li>\n<li>return the minimum element of this array</li>\n<li>algorithm has to run in O(logN)</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>In array problem, if the algorithm has to run in O(logN), we can come up with Binary search initially. If the array supposed to be sorted in ascending order and rotate it to the right then sub arrays from pivot index has minimum value or <strong>just find minimum value with Binary search</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90b7b3e8-4ab2-4e1f-b740-cbf933601239/C4460C45-0244-485C-A8EA-9D400DCDF0BD.jpeg\" alt=\"C4460C45-0244-485C-A8EA-9D400DCDF0BD.jpeg\"></p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = l + (r - l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] &gt; nums[r]) l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> r = m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[r];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3caae118-0fcc-4c6d-b4ee-cbd7b492a97e/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li><strong>Choose the left or right index for answer</strong></li>\n<li><strong>One of the left or right index has to be the same as middle index in equals if statement</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = l + (r - l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[m] &lt;= nums[r]) r = m;   <span class=\"comment\">// value at m and r is euqual, then r move to m</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"15. 3Sum","catalog":true,"date":"2022-10-15T13:21:32.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\nFind the triplet which is not duplicated and sum of them is zero\n\nis input length is smaller than 3? → 3 <= nums.length <= 3000\n\nthe range of the element of array? → -105 <= nums[i] <= 105\n\norder of input tripet matters? →  no\n\n### **Edge cases**\n\n---\n\n[1, 2, -1, 0] → [[1,-1,0]]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nI can start with brute force way. Its time complexity is O(n^3)\n\n```java\npublic List<List<Integer>> threeSum(int[] nums) {\n        \n    Set<List<Integer>> ans = new HashSet();\n    \n    for(int i = 0; i < nums.length; i++) {\n        for(int j = i+1; j < nums.length; j++) {\n            for(int k = j+1; k < nums.length; k++) {\n                if(nums[i] + nums[j] + nums[k] == 0) {\n                    List<Integer> temp = Arrays.asList(nums[i], nums[j] ,nums[k]);\n                    Collections.sort(temp); // it doesn't affect much on time complexity\n                    ans.add(temp);\n                } \n            }\n        }\n    }\n    return new ArrayList(ans);\n}\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nIn the array question, sort could be a good option. In terms of sorting algorithm, I can come up with the binary search. Sort the array in ascending order first. we can start with the first index and iterate throught it. we will use the two pointer left and right. If sum of the value of starting index, left and right index is equals to 0 then add to the answer list. if the sum is less than 0, move the left pointer to right because we need the larger value. if the sum is greater than 0, then move th right point to left. \n\nFor optimization we can ignore the duplicated value. we can use the HashSet but since array is ordered, instead, if we visited the same value then skip it.\n\n### **Coding**\n\n---\n\n```java\npublic List<List<Integer>> threeSum(int[] nums) {\n\n    List<List<Integer>> ans = new ArrayList();\n    Arrays.sort(nums);\n    \n    for(int i = 0; i < nums.length; i++) {\n        if(i > 0 && nums[i] == nums[i-1]) continue; // if the visited value is the same value, then skip\n        \n        int l = i + 1, r = nums.length - 1; \n        while(l < r) {                \n            int sum = nums[i] + nums[l] + nums[r];\n            if(sum < 0) l++;\n            else if(sum > 0) r--;\n            else {\n                ans.add(Arrays.asList(nums[i], nums[l], nums[r]));\n                l++; r--;\n                while(nums[l] == nums[l-1] && l < r) l++; // only one of left or right can be skipped\n            }\n        }\n    }\n    return ans; \n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2c1715e-d76e-49b5-b4c2-55681805a404/Untitled.png)\n\n### What I learned\n\n---\n\n1. Sorting always helps in array problem, don’t be cocky just use them!\n2. Sorting algorithm comes with the binary search\n3. Java’s `*Arrays.sort`* uses ***dual-pivot Quicksort***. (***O(nlog(n)**)*\n4. Multiple pointer can be a good solution in array problem\n","source":"_posts/15-3Sum.md","raw":"---\ntitle: \"15.\\_3Sum\"\ncatalog: true\ndate: 2022-10-15 22:21:32\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\nFind the triplet which is not duplicated and sum of them is zero\n\nis input length is smaller than 3? → 3 <= nums.length <= 3000\n\nthe range of the element of array? → -105 <= nums[i] <= 105\n\norder of input tripet matters? →  no\n\n### **Edge cases**\n\n---\n\n[1, 2, -1, 0] → [[1,-1,0]]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nI can start with brute force way. Its time complexity is O(n^3)\n\n```java\npublic List<List<Integer>> threeSum(int[] nums) {\n        \n    Set<List<Integer>> ans = new HashSet();\n    \n    for(int i = 0; i < nums.length; i++) {\n        for(int j = i+1; j < nums.length; j++) {\n            for(int k = j+1; k < nums.length; k++) {\n                if(nums[i] + nums[j] + nums[k] == 0) {\n                    List<Integer> temp = Arrays.asList(nums[i], nums[j] ,nums[k]);\n                    Collections.sort(temp); // it doesn't affect much on time complexity\n                    ans.add(temp);\n                } \n            }\n        }\n    }\n    return new ArrayList(ans);\n}\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nIn the array question, sort could be a good option. In terms of sorting algorithm, I can come up with the binary search. Sort the array in ascending order first. we can start with the first index and iterate throught it. we will use the two pointer left and right. If sum of the value of starting index, left and right index is equals to 0 then add to the answer list. if the sum is less than 0, move the left pointer to right because we need the larger value. if the sum is greater than 0, then move th right point to left. \n\nFor optimization we can ignore the duplicated value. we can use the HashSet but since array is ordered, instead, if we visited the same value then skip it.\n\n### **Coding**\n\n---\n\n```java\npublic List<List<Integer>> threeSum(int[] nums) {\n\n    List<List<Integer>> ans = new ArrayList();\n    Arrays.sort(nums);\n    \n    for(int i = 0; i < nums.length; i++) {\n        if(i > 0 && nums[i] == nums[i-1]) continue; // if the visited value is the same value, then skip\n        \n        int l = i + 1, r = nums.length - 1; \n        while(l < r) {                \n            int sum = nums[i] + nums[l] + nums[r];\n            if(sum < 0) l++;\n            else if(sum > 0) r--;\n            else {\n                ans.add(Arrays.asList(nums[i], nums[l], nums[r]));\n                l++; r--;\n                while(nums[l] == nums[l-1] && l < r) l++; // only one of left or right can be skipped\n            }\n        }\n    }\n    return ans; \n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2c1715e-d76e-49b5-b4c2-55681805a404/Untitled.png)\n\n### What I learned\n\n---\n\n1. Sorting always helps in array problem, don’t be cocky just use them!\n2. Sorting algorithm comes with the binary search\n3. Java’s `*Arrays.sort`* uses ***dual-pivot Quicksort***. (***O(nlog(n)**)*\n4. Multiple pointer can be a good solution in array problem\n","slug":"15-3Sum","published":1,"updated":"2022-10-15T13:23:25.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc16000kqkcc0zig42w1","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<p>Find the triplet which is not duplicated and sum of them is zero</p>\n<p>is input length is smaller than 3? → 3 &lt;= nums.length &lt;= 3000</p>\n<p>the range of the element of array? → -105 &lt;= nums[i] &lt;= 105</p>\n<p>order of input tripet matters? →  no</p>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<p>[1, 2, -1, 0] → [[1,-1,0]]</p>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>I can start with brute force way. Its time complexity is O(n^3)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    Set&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = j+<span class=\"number\">1</span>; k &lt; nums.length; k++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i] + nums[j] + nums[k] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    List&lt;Integer&gt; temp = Arrays.asList(nums[i], nums[j] ,nums[k]);</span><br><span class=\"line\">                    Collections.sort(temp); <span class=\"comment\">// it doesn't affect much on time complexity</span></span><br><span class=\"line\">                    ans.add(temp);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList(ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>In the array question, sort could be a good option. In terms of sorting algorithm, I can come up with the binary search. Sort the array in ascending order first. we can start with the first index and iterate throught it. we will use the two pointer left and right. If sum of the value of starting index, left and right index is equals to 0 then add to the answer list. if the sum is less than 0, move the left pointer to right because we need the larger value. if the sum is greater than 0, then move th right point to left.</p>\n<p>For optimization we can ignore the duplicated value. we can use the HashSet but since array is ordered, instead, if we visited the same value then skip it.</p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i-<span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>; <span class=\"comment\">// if the visited value is the same value, then skip</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = i + <span class=\"number\">1</span>, r = nums.length - <span class=\"number\">1</span>; </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;                </span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = nums[i] + nums[l] + nums[r];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum &lt; <span class=\"number\">0</span>) l++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; <span class=\"number\">0</span>) r--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class=\"line\">                l++; r--;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(nums[l] == nums[l-<span class=\"number\">1</span>] &amp;&amp; l &lt; r) l++; <span class=\"comment\">// only one of left or right can be skipped</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2c1715e-d76e-49b5-b4c2-55681805a404/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>Sorting always helps in array problem, don’t be cocky just use them!</li>\n<li>Sorting algorithm comes with the binary search</li>\n<li>Java’s <code>*Arrays.sort</code>* uses <strong><em>dual-pivot Quicksort</em></strong>. (<em><strong>O(nlog(n)</strong>)</em></li>\n<li>Multiple pointer can be a good solution in array problem</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<p>Find the triplet which is not duplicated and sum of them is zero</p>\n<p>is input length is smaller than 3? → 3 &lt;= nums.length &lt;= 3000</p>\n<p>the range of the element of array? → -105 &lt;= nums[i] &lt;= 105</p>\n<p>order of input tripet matters? →  no</p>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<p>[1, 2, -1, 0] → [[1,-1,0]]</p>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>I can start with brute force way. Its time complexity is O(n^3)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    Set&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = j+<span class=\"number\">1</span>; k &lt; nums.length; k++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i] + nums[j] + nums[k] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    List&lt;Integer&gt; temp = Arrays.asList(nums[i], nums[j] ,nums[k]);</span><br><span class=\"line\">                    Collections.sort(temp); <span class=\"comment\">// it doesn't affect much on time complexity</span></span><br><span class=\"line\">                    ans.add(temp);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList(ans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>In the array question, sort could be a good option. In terms of sorting algorithm, I can come up with the binary search. Sort the array in ascending order first. we can start with the first index and iterate throught it. we will use the two pointer left and right. If sum of the value of starting index, left and right index is equals to 0 then add to the answer list. if the sum is less than 0, move the left pointer to right because we need the larger value. if the sum is greater than 0, then move th right point to left.</p>\n<p>For optimization we can ignore the duplicated value. we can use the HashSet but since array is ordered, instead, if we visited the same value then skip it.</p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i-<span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>; <span class=\"comment\">// if the visited value is the same value, then skip</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = i + <span class=\"number\">1</span>, r = nums.length - <span class=\"number\">1</span>; </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;                </span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = nums[i] + nums[l] + nums[r];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum &lt; <span class=\"number\">0</span>) l++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; <span class=\"number\">0</span>) r--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class=\"line\">                l++; r--;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(nums[l] == nums[l-<span class=\"number\">1</span>] &amp;&amp; l &lt; r) l++; <span class=\"comment\">// only one of left or right can be skipped</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2c1715e-d76e-49b5-b4c2-55681805a404/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>Sorting always helps in array problem, don’t be cocky just use them!</li>\n<li>Sorting algorithm comes with the binary search</li>\n<li>Java’s <code>*Arrays.sort</code>* uses <strong><em>dual-pivot Quicksort</em></strong>. (<em><strong>O(nlog(n)</strong>)</em></li>\n<li>Multiple pointer can be a good solution in array problem</li>\n</ol>\n"},{"title":"143. Reorder List","catalog":true,"date":"2022-10-03T02:30:27.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- You may not modify the values in the list's nodes.\n- Only nodes themselves may be changed.\n\n## Solve by hands first\n\n---\n\n1. split half\n    \n    ![075BA843-42AC-4CFA-B90C-7088A3C5E1F6.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1595618f-6e66-45ae-9031-819b766f5d2c/075BA843-42AC-4CFA-B90C-7088A3C5E1F6.jpeg)\n    \n2. reverse the second half\n    \n    ![F296F1B2-F6AE-470A-8202-93C5164ABBB9.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/19adefd7-34c8-4181-852e-25e94d19c81d/F296F1B2-F6AE-470A-8202-93C5164ABBB9.jpeg)\n    \n3. merge the first and second half\n    \n    ![D280446B-02F4-4316-9430-2F355EC395C5.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/304a1cc0-94e4-4c31-9adf-c409c30adb84/D280446B-02F4-4316-9430-2F355EC395C5.jpeg)\n    \n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public void reorderList(ListNode head) {\n        \n        if(head == null || head.next == null) return;\n        \n        ListNode pre = null, slow = head, fast = head, top = head;\n        \n        while(fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        // disconnect the half\n        pre.next = null;\n        \n        ListNode end = reverse(slow);\n        \n        merge(top, end);\n    }\n    \n    private ListNode reverse(ListNode head) {\n        ListNode prev = null, curr = head, next = null;\n        \n        while(curr != null) {\n            next = curr.next; // set next pointer\n            curr.next = prev; // reference next to prev\n            prev = curr; // prev -> curr\n            curr = next; // curr -> next\n        }\n        \n        return prev;\n    }\n    \n    private void merge(ListNode head, ListNode tail) {\n        \n        while(head != null) {\n            \n            ListNode nh = head.next, nt = tail.next;\n            \n            head.next = tail;\n            if(nh == null) break;\n            tail.next = nh;\n            \n            head = nh;\n            tail = nt;\n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/10083bc9-3e1d-4033-9fcf-eb5e041dfc20/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. utilize the pointer variable!\n    \n    ```java\n    ListNode prev = null, curr = head, next = null;\n    ```\n    \n2. edge case is important\n    \n    ```java\n    1 -> 2 -> null  3 <- 4 <- 5\n    \n    private void merge(ListNode head, ListNode tail) {\n        while(head != null) {\n            ListNode nh = head.next, nt = tail.next;\n            \n            head.next = tail;\n            if(nh == null) break; // next head can be null at node 2\n            tail.next = nh;\n            \n            head = nh;\n            tail = nt;\n        }\n    }\n    ```\n","source":"_posts/143-Reorder-List.md","raw":"---\ntitle: \"143.\\_Reorder List\"\ncatalog: true\ndate: 2022-10-03 11:30:27\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- You may not modify the values in the list's nodes.\n- Only nodes themselves may be changed.\n\n## Solve by hands first\n\n---\n\n1. split half\n    \n    ![075BA843-42AC-4CFA-B90C-7088A3C5E1F6.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1595618f-6e66-45ae-9031-819b766f5d2c/075BA843-42AC-4CFA-B90C-7088A3C5E1F6.jpeg)\n    \n2. reverse the second half\n    \n    ![F296F1B2-F6AE-470A-8202-93C5164ABBB9.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/19adefd7-34c8-4181-852e-25e94d19c81d/F296F1B2-F6AE-470A-8202-93C5164ABBB9.jpeg)\n    \n3. merge the first and second half\n    \n    ![D280446B-02F4-4316-9430-2F355EC395C5.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/304a1cc0-94e4-4c31-9adf-c409c30adb84/D280446B-02F4-4316-9430-2F355EC395C5.jpeg)\n    \n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public void reorderList(ListNode head) {\n        \n        if(head == null || head.next == null) return;\n        \n        ListNode pre = null, slow = head, fast = head, top = head;\n        \n        while(fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        // disconnect the half\n        pre.next = null;\n        \n        ListNode end = reverse(slow);\n        \n        merge(top, end);\n    }\n    \n    private ListNode reverse(ListNode head) {\n        ListNode prev = null, curr = head, next = null;\n        \n        while(curr != null) {\n            next = curr.next; // set next pointer\n            curr.next = prev; // reference next to prev\n            prev = curr; // prev -> curr\n            curr = next; // curr -> next\n        }\n        \n        return prev;\n    }\n    \n    private void merge(ListNode head, ListNode tail) {\n        \n        while(head != null) {\n            \n            ListNode nh = head.next, nt = tail.next;\n            \n            head.next = tail;\n            if(nh == null) break;\n            tail.next = nh;\n            \n            head = nh;\n            tail = nt;\n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/10083bc9-3e1d-4033-9fcf-eb5e041dfc20/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. utilize the pointer variable!\n    \n    ```java\n    ListNode prev = null, curr = head, next = null;\n    ```\n    \n2. edge case is important\n    \n    ```java\n    1 -> 2 -> null  3 <- 4 <- 5\n    \n    private void merge(ListNode head, ListNode tail) {\n        while(head != null) {\n            ListNode nh = head.next, nt = tail.next;\n            \n            head.next = tail;\n            if(nh == null) break; // next head can be null at node 2\n            tail.next = nh;\n            \n            head = nh;\n            tail = nt;\n        }\n    }\n    ```\n","slug":"143-Reorder-List","published":1,"updated":"2022-10-03T02:34:23.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc17000lqkcci85pkkko","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>You may not modify the values in the list’s nodes.</li>\n<li>Only nodes themselves may be changed.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<ol>\n<li>\n<p>split half</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1595618f-6e66-45ae-9031-819b766f5d2c/075BA843-42AC-4CFA-B90C-7088A3C5E1F6.jpeg\" alt=\"075BA843-42AC-4CFA-B90C-7088A3C5E1F6.jpeg\"></p>\n</li>\n<li>\n<p>reverse the second half</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/19adefd7-34c8-4181-852e-25e94d19c81d/F296F1B2-F6AE-470A-8202-93C5164ABBB9.jpeg\" alt=\"F296F1B2-F6AE-470A-8202-93C5164ABBB9.jpeg\"></p>\n</li>\n<li>\n<p>merge the first and second half</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/304a1cc0-94e4-4c31-9adf-c409c30adb84/D280446B-02F4-4316-9430-2F355EC395C5.jpeg\" alt=\"D280446B-02F4-4316-9430-2F355EC395C5.jpeg\"></p>\n</li>\n</ol>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reorderList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode pre = <span class=\"keyword\">null</span>, slow = head, fast = head, top = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            pre = slow;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// disconnect the half</span></span><br><span class=\"line\">        pre.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode end = reverse(slow);</span><br><span class=\"line\">        </span><br><span class=\"line\">        merge(top, end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">reverse</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode prev = <span class=\"keyword\">null</span>, curr = head, next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            next = curr.next; <span class=\"comment\">// set next pointer</span></span><br><span class=\"line\">            curr.next = prev; <span class=\"comment\">// reference next to prev</span></span><br><span class=\"line\">            prev = curr; <span class=\"comment\">// prev -&gt; curr</span></span><br><span class=\"line\">            curr = next; <span class=\"comment\">// curr -&gt; next</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            ListNode nh = head.next, nt = tail.next;</span><br><span class=\"line\">            </span><br><span class=\"line\">            head.next = tail;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nh == <span class=\"keyword\">null</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            tail.next = nh;</span><br><span class=\"line\">            </span><br><span class=\"line\">            head = nh;</span><br><span class=\"line\">            tail = nt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/10083bc9-3e1d-4033-9fcf-eb5e041dfc20/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>utilize the pointer variable!</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListNode prev = <span class=\"keyword\">null</span>, curr = head, next = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>edge case is important</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> -&gt; <span class=\"number\">2</span> -&gt; <span class=\"keyword\">null</span>  <span class=\"number\">3</span> &lt;- <span class=\"number\">4</span> &lt;- <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ListNode nh = head.next, nt = tail.next;</span><br><span class=\"line\">        </span><br><span class=\"line\">        head.next = tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nh == <span class=\"keyword\">null</span>) <span class=\"keyword\">break</span>; <span class=\"comment\">// next head can be null at node 2</span></span><br><span class=\"line\">        tail.next = nh;</span><br><span class=\"line\">        </span><br><span class=\"line\">        head = nh;</span><br><span class=\"line\">        tail = nt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>You may not modify the values in the list’s nodes.</li>\n<li>Only nodes themselves may be changed.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<ol>\n<li>\n<p>split half</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1595618f-6e66-45ae-9031-819b766f5d2c/075BA843-42AC-4CFA-B90C-7088A3C5E1F6.jpeg\" alt=\"075BA843-42AC-4CFA-B90C-7088A3C5E1F6.jpeg\"></p>\n</li>\n<li>\n<p>reverse the second half</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/19adefd7-34c8-4181-852e-25e94d19c81d/F296F1B2-F6AE-470A-8202-93C5164ABBB9.jpeg\" alt=\"F296F1B2-F6AE-470A-8202-93C5164ABBB9.jpeg\"></p>\n</li>\n<li>\n<p>merge the first and second half</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/304a1cc0-94e4-4c31-9adf-c409c30adb84/D280446B-02F4-4316-9430-2F355EC395C5.jpeg\" alt=\"D280446B-02F4-4316-9430-2F355EC395C5.jpeg\"></p>\n</li>\n</ol>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reorderList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode pre = <span class=\"keyword\">null</span>, slow = head, fast = head, top = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            pre = slow;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// disconnect the half</span></span><br><span class=\"line\">        pre.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode end = reverse(slow);</span><br><span class=\"line\">        </span><br><span class=\"line\">        merge(top, end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ListNode <span class=\"title\">reverse</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode prev = <span class=\"keyword\">null</span>, curr = head, next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            next = curr.next; <span class=\"comment\">// set next pointer</span></span><br><span class=\"line\">            curr.next = prev; <span class=\"comment\">// reference next to prev</span></span><br><span class=\"line\">            prev = curr; <span class=\"comment\">// prev -&gt; curr</span></span><br><span class=\"line\">            curr = next; <span class=\"comment\">// curr -&gt; next</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            ListNode nh = head.next, nt = tail.next;</span><br><span class=\"line\">            </span><br><span class=\"line\">            head.next = tail;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nh == <span class=\"keyword\">null</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            tail.next = nh;</span><br><span class=\"line\">            </span><br><span class=\"line\">            head = nh;</span><br><span class=\"line\">            tail = nt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/10083bc9-3e1d-4033-9fcf-eb5e041dfc20/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>utilize the pointer variable!</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListNode prev = <span class=\"keyword\">null</span>, curr = head, next = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>edge case is important</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> -&gt; <span class=\"number\">2</span> -&gt; <span class=\"keyword\">null</span>  <span class=\"number\">3</span> &lt;- <span class=\"number\">4</span> &lt;- <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ListNode nh = head.next, nt = tail.next;</span><br><span class=\"line\">        </span><br><span class=\"line\">        head.next = tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nh == <span class=\"keyword\">null</span>) <span class=\"keyword\">break</span>; <span class=\"comment\">// next head can be null at node 2</span></span><br><span class=\"line\">        tail.next = nh;</span><br><span class=\"line\">        </span><br><span class=\"line\">        head = nh;</span><br><span class=\"line\">        tail = nt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"1903. Largest Odd Number in String","catalog":true,"date":"2022-10-24T14:04:09.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- return the largest odd number from the non empty substring of input num\n\n### **Edge cases**\n\n---\n\n- 57 → [57, 7] → 57\n- 4206 → “”\n- 3570 → 357\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nTo determine odd number, check the last digit is odd (1,3,5,7,9). we wants to find the larest odd number so start from the whole number string and shift the lowest digit to the left. Time complexity is O(n) and space complexity is O(1)\n\n```java\nclass Solution {\n    public String largestOddNumber(String num) {\n        for(int i = num.length() - 1; i >= 0; i--) {\n            if(num.charAt(i) % 2 == 1) return num.substring(0, i+1);\n        }\n        return \"\";\n    }\n}\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public String largestOddNumber(String num) {\n        for(int i = num.length() - 1; i >= 0; i--) {\n            if(num.charAt(i) % 2 == 1) return num.substring(0, i+1);\n        }\n        return \"\";\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d577f1b-f44d-42e1-a7e1-f4b86ccefd4e/Untitled.png)\n\n### What I learned\n\n---\n\n1. This is longest and shortest substring problem. so it is important to determin the start and end pointer. in this case, **we start from 0, last index to 0, 0**\n2. I thought we need two pointer but\n","source":"_posts/1903-Largest-Odd-Number-in-String.md","raw":"---\ntitle: \"1903.\\_Largest Odd Number in String\"\ncatalog: true\ndate: 2022-10-24 23:04:09\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- return the largest odd number from the non empty substring of input num\n\n### **Edge cases**\n\n---\n\n- 57 → [57, 7] → 57\n- 4206 → “”\n- 3570 → 357\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nTo determine odd number, check the last digit is odd (1,3,5,7,9). we wants to find the larest odd number so start from the whole number string and shift the lowest digit to the left. Time complexity is O(n) and space complexity is O(1)\n\n```java\nclass Solution {\n    public String largestOddNumber(String num) {\n        for(int i = num.length() - 1; i >= 0; i--) {\n            if(num.charAt(i) % 2 == 1) return num.substring(0, i+1);\n        }\n        return \"\";\n    }\n}\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public String largestOddNumber(String num) {\n        for(int i = num.length() - 1; i >= 0; i--) {\n            if(num.charAt(i) % 2 == 1) return num.substring(0, i+1);\n        }\n        return \"\";\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d577f1b-f44d-42e1-a7e1-f4b86ccefd4e/Untitled.png)\n\n### What I learned\n\n---\n\n1. This is longest and shortest substring problem. so it is important to determin the start and end pointer. in this case, **we start from 0, last index to 0, 0**\n2. I thought we need two pointer but\n","slug":"1903-Largest-Odd-Number-in-String","published":1,"updated":"2022-10-24T14:04:25.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc17000mqkccf6apu01p","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>return the largest odd number from the non empty substring of input num</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>57 → [57, 7] → 57</li>\n<li>4206 → “”</li>\n<li>3570 → 357</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>To determine odd number, check the last digit is odd (1,3,5,7,9). we wants to find the larest odd number so start from the whole number string and shift the lowest digit to the left. Time complexity is O(n) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">largestOddNumber</span><span class=\"params\">(String num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = num.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num.charAt(i) % <span class=\"number\">2</span> == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> num.substring(<span class=\"number\">0</span>, i+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">largestOddNumber</span><span class=\"params\">(String num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = num.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num.charAt(i) % <span class=\"number\">2</span> == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> num.substring(<span class=\"number\">0</span>, i+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d577f1b-f44d-42e1-a7e1-f4b86ccefd4e/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>This is longest and shortest substring problem. so it is important to determin the start and end pointer. in this case, <strong>we start from 0, last index to 0, 0</strong></li>\n<li>I thought we need two pointer but</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>return the largest odd number from the non empty substring of input num</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>57 → [57, 7] → 57</li>\n<li>4206 → “”</li>\n<li>3570 → 357</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>To determine odd number, check the last digit is odd (1,3,5,7,9). we wants to find the larest odd number so start from the whole number string and shift the lowest digit to the left. Time complexity is O(n) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">largestOddNumber</span><span class=\"params\">(String num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = num.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num.charAt(i) % <span class=\"number\">2</span> == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> num.substring(<span class=\"number\">0</span>, i+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">largestOddNumber</span><span class=\"params\">(String num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = num.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num.charAt(i) % <span class=\"number\">2</span> == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> num.substring(<span class=\"number\">0</span>, i+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d577f1b-f44d-42e1-a7e1-f4b86ccefd4e/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>This is longest and shortest substring problem. so it is important to determin the start and end pointer. in this case, <strong>we start from 0, last index to 0, 0</strong></li>\n<li>I thought we need two pointer but</li>\n</ol>\n"},{"title":"1624. Largest Substring Between Two Equal Characters","catalog":true,"date":"2022-10-24T15:06:58.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- return the longest substring between two equal number\n- length of substring is greater than 2\n\n### **Edge cases**\n\n---\n\n- aa → 0\n- aba → 1\n- → -1\n- abba → 2\n- abcdsa → 4\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nI can start with two pointers. create left and right pointer with value 0 and s.length() - 1. but problem of the approach is that we can’t find the same value. if the left and right value is not equals we have to choose move both, left or right.\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nIn order to find the same value at certain index, we can cache the value and its index. since it only consists of lowercase English letter, we can create int array with length of 26. store the index at the ascii character of array. Time complexity is O(n) and space complexity is O(1)\n\n```java\nInteger[] tmp = new Integer[26];\nint max = 0;\nfor(int i = 0; i < s.length(); i++) {\n    int idx = s.charAt(i) - 'a';\n    if(tmp[idx] != null) {\n        max = Math.max(max, i - tmp[idx]);\n    } else {\n        tmp[idx] = i;\n    }\n}\nreturn max - 1;\n```\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    \n    public int maxLengthBetweenEqualCharacters(String s) {\n        Integer[] tmp = new Integer[26];\n        int max = 0;\n        for(int i = 0; i < s.length(); i++) {\n            int idx = s.charAt(i) - 'a';\n            if(tmp[idx] != null) {\n                max = Math.max(max, i - tmp[idx]);\n            } else {\n                tmp[idx] = i;\n            }\n        }\n        return max - 1;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5d3f499d-8b14-4bf0-b9ef-c7367af2ddd3/Untitled.png)\n\n### What I learned\n\n---\n\n1. Store the index at its ascii character is useful in longest and shortest problem \n\n```java\nInteger[] tmp = new Integer[26];\nfor(int i = 0; i < s.length(); i++) {\n    int idx = s.charAt(i) - 'a';\n    tmp[idx] = i; // store index at ascii character\n}\n```\n","source":"_posts/1624-Largest-Substring-Between-Two-Equal-Characters.md","raw":"---\ntitle: \"1624.\\_Largest Substring Between Two Equal Characters\"\ncatalog: true\ndate: 2022-10-25 00:06:58\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- return the longest substring between two equal number\n- length of substring is greater than 2\n\n### **Edge cases**\n\n---\n\n- aa → 0\n- aba → 1\n- → -1\n- abba → 2\n- abcdsa → 4\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nI can start with two pointers. create left and right pointer with value 0 and s.length() - 1. but problem of the approach is that we can’t find the same value. if the left and right value is not equals we have to choose move both, left or right.\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nIn order to find the same value at certain index, we can cache the value and its index. since it only consists of lowercase English letter, we can create int array with length of 26. store the index at the ascii character of array. Time complexity is O(n) and space complexity is O(1)\n\n```java\nInteger[] tmp = new Integer[26];\nint max = 0;\nfor(int i = 0; i < s.length(); i++) {\n    int idx = s.charAt(i) - 'a';\n    if(tmp[idx] != null) {\n        max = Math.max(max, i - tmp[idx]);\n    } else {\n        tmp[idx] = i;\n    }\n}\nreturn max - 1;\n```\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    \n    public int maxLengthBetweenEqualCharacters(String s) {\n        Integer[] tmp = new Integer[26];\n        int max = 0;\n        for(int i = 0; i < s.length(); i++) {\n            int idx = s.charAt(i) - 'a';\n            if(tmp[idx] != null) {\n                max = Math.max(max, i - tmp[idx]);\n            } else {\n                tmp[idx] = i;\n            }\n        }\n        return max - 1;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5d3f499d-8b14-4bf0-b9ef-c7367af2ddd3/Untitled.png)\n\n### What I learned\n\n---\n\n1. Store the index at its ascii character is useful in longest and shortest problem \n\n```java\nInteger[] tmp = new Integer[26];\nfor(int i = 0; i < s.length(); i++) {\n    int idx = s.charAt(i) - 'a';\n    tmp[idx] = i; // store index at ascii character\n}\n```\n","slug":"1624-Largest-Substring-Between-Two-Equal-Characters","published":1,"updated":"2022-10-24T15:07:14.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc17000nqkccpwb0m3z3","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>return the longest substring between two equal number</li>\n<li>length of substring is greater than 2</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>aa → 0</li>\n<li>aba → 1</li>\n<li>→ -1</li>\n<li>abba → 2</li>\n<li>abcdsa → 4</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>I can start with two pointers. create left and right pointer with value 0 and s.length() - 1. but problem of the approach is that we can’t find the same value. if the left and right value is not equals we have to choose move both, left or right.</p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>In order to find the same value at certain index, we can cache the value and its index. since it only consists of lowercase English letter, we can create int array with length of 26. store the index at the ascii character of array. Time complexity is O(n) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] tmp = <span class=\"keyword\">new</span> Integer[<span class=\"number\">26</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = s.charAt(i) - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp[idx] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        max = Math.max(max, i - tmp[idx]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        tmp[idx] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max - <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxLengthBetweenEqualCharacters</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Integer[] tmp = <span class=\"keyword\">new</span> Integer[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> idx = s.charAt(i) - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp[idx] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                max = Math.max(max, i - tmp[idx]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                tmp[idx] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5d3f499d-8b14-4bf0-b9ef-c7367af2ddd3/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>Store the index at its ascii character is useful in longest and shortest problem</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] tmp = <span class=\"keyword\">new</span> Integer[<span class=\"number\">26</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = s.charAt(i) - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">    tmp[idx] = i; <span class=\"comment\">// store index at ascii character</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>return the longest substring between two equal number</li>\n<li>length of substring is greater than 2</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>aa → 0</li>\n<li>aba → 1</li>\n<li>→ -1</li>\n<li>abba → 2</li>\n<li>abcdsa → 4</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>I can start with two pointers. create left and right pointer with value 0 and s.length() - 1. but problem of the approach is that we can’t find the same value. if the left and right value is not equals we have to choose move both, left or right.</p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>In order to find the same value at certain index, we can cache the value and its index. since it only consists of lowercase English letter, we can create int array with length of 26. store the index at the ascii character of array. Time complexity is O(n) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] tmp = <span class=\"keyword\">new</span> Integer[<span class=\"number\">26</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = s.charAt(i) - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp[idx] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        max = Math.max(max, i - tmp[idx]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        tmp[idx] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max - <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxLengthBetweenEqualCharacters</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Integer[] tmp = <span class=\"keyword\">new</span> Integer[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> idx = s.charAt(i) - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp[idx] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                max = Math.max(max, i - tmp[idx]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                tmp[idx] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5d3f499d-8b14-4bf0-b9ef-c7367af2ddd3/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>Store the index at its ascii character is useful in longest and shortest problem</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] tmp = <span class=\"keyword\">new</span> Integer[<span class=\"number\">26</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = s.charAt(i) - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">    tmp[idx] = i; <span class=\"comment\">// store index at ascii character</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"1143. Longest Common Subsequence","catalog":true,"date":"2022-09-11T07:39:47.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- find the longest subsequnce of both of text1 and text2\n- new string is generated from the original string **without change order**\n\n## Solve by hands first\n\n---\n\nwe will start from **Brute Force** algorithm with multi indices. we need 2 pointer for each String. if each character at pointer is not equal, then move the pointer to next index. **Problem of this solution is we can’t decide which index should we move first**. \n\nbut how can I decide which index should I move?\n\nis the distinct value in array?\n\ncan it be different order?\n\n- I can sort the string first then compare\n\nNext solution can be using **alphabet array**. initialize the integer array with size 26 with -1. increase the index value +1 with text1. **Problem of the solution is it doesn’t care of order**. so It ignore the order, then we will get unexpected result\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        return dp(text1, text2, 0, 0);\n    }\n    \n    int dp(String text1, String text2, int i, int j) {\n        if(i == text1.length() || j == text2.length()) return 0;\n        \n        if(text1.charAt(i) == text2.charAt(j)) return 1 + dp(text1, text2, i + 1, j + 1);\n        \n        else return Math.max(dp(text1, text2, i + 1, j), dp(text1, text2, i, j + 1));\n    }\n}\n```\n\n![67D53F86-2742-4880-8EBC-FAF283417715.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bcf39165-2848-4ed2-9275-e88183243f89/67D53F86-2742-4880-8EBC-FAF283417715.jpeg)\n\nI ended up used Dynamic Programing. the goal is to find the longest subsequence so we can divide into sub problem. **The sub problem can be defined by finding the longest subsequence and return the length of subsequence**. the we can compare the return value of sub problems since it only divided by 2 sub problems. If one of the sub problem returns longer subsequence\n\n### Top Down\n\n```java\nclass Solution {\n    \n    int[][] m;\n    \n    public int longestCommonSubsequence(String text1, String text2) {\n        m = new int[text1.length()][text2.length()];\n        \n        return dp(text1, text2, 0, 0);\n    }\n    \n    int dp(String text1, String text2, int i, int j) {\n        if(i == text1.length() || j == text2.length()) return 0;\n        \n        if(m[i][j] != 0) return m[i][j];\n        \n        if(text1.charAt(i) == text2.charAt(j)) {\n            return m[i][j] = 1 + dp(text1, text2, i + 1, j + 1);\n        } else {\n\t\t\t\t\t\treturn m[i][j] = Math.max(dp(text1, text2, i + 1, j), dp(text1, text2, i, j + 1));\n\t\t\t\t}\n    }\n}\n```\n\n**Problem of this solution is there are duplicate sub problems**. for instance, “ee” appears twice in dp. It can be appeared many time and ended up exceeding time limit. So **we have to use memoization to reduce i**t.\n\n![6326514A-69EC-4BD2-B5EB-00965F07EFC4.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/953f2d58-9a79-4c77-929b-e4afe73bcf00/6326514A-69EC-4BD2-B5EB-00965F07EFC4.jpeg)\n\nSince dp uses stack. it goes to one side and travel back to next sub problem \n\n```java\nreturn m[i][j] = Math.max(\n\t\tdp(text1, text2, i + 1, j), // check this method to the end\n\t\tdp(text1, text2, i, j + 1)  // travel back to this method\n);\n\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98518a7c-e9bb-4ae4-95b1-7917ca1e4ef7/Untitled.png)\n\n### Bottom Up\n\n```java\nclass Solution {\n    \n    int[][] m;\n    \n    public int longestCommonSubsequence(String text1, String text2) {\n        m = new int[text1.length()+1][text2.length()+1];\n        \n        for(int i = 1; i <= text1.length(); i++) {\n            for(int j = 1; j <= text2.length(); j++) {\n                if(text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    m[i][j] = 1 + m[i - 1][j - 1];\n                } else {\n                    m[i][j] = Math.max(m[i - 1][j], m[i][j - 1]);\n                }   \n            }\n        }\n        \n        return m[text1.length()][text2.length()];\n    }\n}\n```\n\n![C09A627F-47BF-4C8E-916D-378242C6247D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/adff9992-f002-4a32-9d83-4102ce293300/C09A627F-47BF-4C8E-916D-378242C6247D.jpeg)\n\nwe also can use bottom up way. it check the value at i = 1, j = 1 so It covers two different cases when it meets condition. the condition is whether the value at i = 0, j = 0 on both of letter in text1, text2 is the same or not \n\n1. **if it is the same** → retrieve value at **i = 0, j = 0**\n2. **if it is not the same** → retrieve value at **i = 1, j = 0** or **i = 0, j = 1**\n\nif it reaches to the last index, it will have to the longest length of the subsequence. **it is important that array m has extra space to store the calculated longest length**. so the size of array is bigger than length of each text which are `text1.length() + 1`, `text2.length() + 1` \n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa9eabc6-e550-4ebc-825f-cf5a2657de10/Untitled.png)\n\nWhy bottom up is faster than top down?\n\n- My initial thoguth was top down is faster than bottom up since we don’t need to loop throught whole array. But I assume that memory stack takes more time\n\n## Lesson I learnt\n\n---\n\n1. **Dynamic programing** is part of **Stack**.\n    - it goes **all the way down to the end of condition** and travel back up to the node has next branch.\n2. We need to **cache the value** and **return the cached value** for memoization \n    \n    ```java\n    int dp(String text1, String text2, int i, int j) {        \n        if(m[i][j] != 0) return m[i][j];\n        \n        if(text1.charAt(i) == text2.charAt(j)) {\n            return m[i][j] = 1 + dp(text1, text2, i + 1, j + 1); // caching and return\n        } else {\n    \t\t\t\treturn m[i][j] = Math.max(dp(text1, text2, i + 1, j), dp(text1, text2, i, j + 1));\n    \t\t}\n    }\n    ```\n    \n3. bottom up needs extra space\n    - The cache array needs to bigger than original array to store the return value at the last index\n    - it usually starts from the 1 more large index and compare to smaller index\n        - target = (1,1)\n        - compare = (0,0), (1,0), (0,1)\n    \n    ```java\n    class Solution {\n        \n        int[][] m;\n        \n        public int longestCommonSubsequence(String text1, String text2) {\n    \n            m = new int[text1.length()+1][text2.length()+1]; \n            \n            for(int i = 1; i <= text1.length(); i++) {\n                for(int j = 1; j <= text2.length(); j++) {\n                    if(text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                        m[i][j] = 1 + m[i - 1][j - 1];\n                    } else {\n                        m[i][j] = Math.max(m[i - 1][j], m[i][j - 1]);\n                    }   \n                }\n            }\n            \n            return m[text1.length()][text2.length()];\n        }\n    }\n    ```\n","source":"_posts/1143-Longest-Common-Subsequence.md","raw":"---\ntitle: \"1143.\\_Longest Common Subsequence\"\ncatalog: true\ndate: 2022-09-11 16:39:47\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- find the longest subsequnce of both of text1 and text2\n- new string is generated from the original string **without change order**\n\n## Solve by hands first\n\n---\n\nwe will start from **Brute Force** algorithm with multi indices. we need 2 pointer for each String. if each character at pointer is not equal, then move the pointer to next index. **Problem of this solution is we can’t decide which index should we move first**. \n\nbut how can I decide which index should I move?\n\nis the distinct value in array?\n\ncan it be different order?\n\n- I can sort the string first then compare\n\nNext solution can be using **alphabet array**. initialize the integer array with size 26 with -1. increase the index value +1 with text1. **Problem of the solution is it doesn’t care of order**. so It ignore the order, then we will get unexpected result\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        return dp(text1, text2, 0, 0);\n    }\n    \n    int dp(String text1, String text2, int i, int j) {\n        if(i == text1.length() || j == text2.length()) return 0;\n        \n        if(text1.charAt(i) == text2.charAt(j)) return 1 + dp(text1, text2, i + 1, j + 1);\n        \n        else return Math.max(dp(text1, text2, i + 1, j), dp(text1, text2, i, j + 1));\n    }\n}\n```\n\n![67D53F86-2742-4880-8EBC-FAF283417715.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bcf39165-2848-4ed2-9275-e88183243f89/67D53F86-2742-4880-8EBC-FAF283417715.jpeg)\n\nI ended up used Dynamic Programing. the goal is to find the longest subsequence so we can divide into sub problem. **The sub problem can be defined by finding the longest subsequence and return the length of subsequence**. the we can compare the return value of sub problems since it only divided by 2 sub problems. If one of the sub problem returns longer subsequence\n\n### Top Down\n\n```java\nclass Solution {\n    \n    int[][] m;\n    \n    public int longestCommonSubsequence(String text1, String text2) {\n        m = new int[text1.length()][text2.length()];\n        \n        return dp(text1, text2, 0, 0);\n    }\n    \n    int dp(String text1, String text2, int i, int j) {\n        if(i == text1.length() || j == text2.length()) return 0;\n        \n        if(m[i][j] != 0) return m[i][j];\n        \n        if(text1.charAt(i) == text2.charAt(j)) {\n            return m[i][j] = 1 + dp(text1, text2, i + 1, j + 1);\n        } else {\n\t\t\t\t\t\treturn m[i][j] = Math.max(dp(text1, text2, i + 1, j), dp(text1, text2, i, j + 1));\n\t\t\t\t}\n    }\n}\n```\n\n**Problem of this solution is there are duplicate sub problems**. for instance, “ee” appears twice in dp. It can be appeared many time and ended up exceeding time limit. So **we have to use memoization to reduce i**t.\n\n![6326514A-69EC-4BD2-B5EB-00965F07EFC4.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/953f2d58-9a79-4c77-929b-e4afe73bcf00/6326514A-69EC-4BD2-B5EB-00965F07EFC4.jpeg)\n\nSince dp uses stack. it goes to one side and travel back to next sub problem \n\n```java\nreturn m[i][j] = Math.max(\n\t\tdp(text1, text2, i + 1, j), // check this method to the end\n\t\tdp(text1, text2, i, j + 1)  // travel back to this method\n);\n\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98518a7c-e9bb-4ae4-95b1-7917ca1e4ef7/Untitled.png)\n\n### Bottom Up\n\n```java\nclass Solution {\n    \n    int[][] m;\n    \n    public int longestCommonSubsequence(String text1, String text2) {\n        m = new int[text1.length()+1][text2.length()+1];\n        \n        for(int i = 1; i <= text1.length(); i++) {\n            for(int j = 1; j <= text2.length(); j++) {\n                if(text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    m[i][j] = 1 + m[i - 1][j - 1];\n                } else {\n                    m[i][j] = Math.max(m[i - 1][j], m[i][j - 1]);\n                }   \n            }\n        }\n        \n        return m[text1.length()][text2.length()];\n    }\n}\n```\n\n![C09A627F-47BF-4C8E-916D-378242C6247D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/adff9992-f002-4a32-9d83-4102ce293300/C09A627F-47BF-4C8E-916D-378242C6247D.jpeg)\n\nwe also can use bottom up way. it check the value at i = 1, j = 1 so It covers two different cases when it meets condition. the condition is whether the value at i = 0, j = 0 on both of letter in text1, text2 is the same or not \n\n1. **if it is the same** → retrieve value at **i = 0, j = 0**\n2. **if it is not the same** → retrieve value at **i = 1, j = 0** or **i = 0, j = 1**\n\nif it reaches to the last index, it will have to the longest length of the subsequence. **it is important that array m has extra space to store the calculated longest length**. so the size of array is bigger than length of each text which are `text1.length() + 1`, `text2.length() + 1` \n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa9eabc6-e550-4ebc-825f-cf5a2657de10/Untitled.png)\n\nWhy bottom up is faster than top down?\n\n- My initial thoguth was top down is faster than bottom up since we don’t need to loop throught whole array. But I assume that memory stack takes more time\n\n## Lesson I learnt\n\n---\n\n1. **Dynamic programing** is part of **Stack**.\n    - it goes **all the way down to the end of condition** and travel back up to the node has next branch.\n2. We need to **cache the value** and **return the cached value** for memoization \n    \n    ```java\n    int dp(String text1, String text2, int i, int j) {        \n        if(m[i][j] != 0) return m[i][j];\n        \n        if(text1.charAt(i) == text2.charAt(j)) {\n            return m[i][j] = 1 + dp(text1, text2, i + 1, j + 1); // caching and return\n        } else {\n    \t\t\t\treturn m[i][j] = Math.max(dp(text1, text2, i + 1, j), dp(text1, text2, i, j + 1));\n    \t\t}\n    }\n    ```\n    \n3. bottom up needs extra space\n    - The cache array needs to bigger than original array to store the return value at the last index\n    - it usually starts from the 1 more large index and compare to smaller index\n        - target = (1,1)\n        - compare = (0,0), (1,0), (0,1)\n    \n    ```java\n    class Solution {\n        \n        int[][] m;\n        \n        public int longestCommonSubsequence(String text1, String text2) {\n    \n            m = new int[text1.length()+1][text2.length()+1]; \n            \n            for(int i = 1; i <= text1.length(); i++) {\n                for(int j = 1; j <= text2.length(); j++) {\n                    if(text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                        m[i][j] = 1 + m[i - 1][j - 1];\n                    } else {\n                        m[i][j] = Math.max(m[i - 1][j], m[i][j - 1]);\n                    }   \n                }\n            }\n            \n            return m[text1.length()][text2.length()];\n        }\n    }\n    ```\n","slug":"1143-Longest-Common-Subsequence","published":1,"updated":"2022-09-11T07:40:19.755Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc17000oqkcctya1h33d","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>find the longest subsequnce of both of text1 and text2</li>\n<li>new string is generated from the original string <strong>without change order</strong></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we will start from <strong>Brute Force</strong> algorithm with multi indices. we need 2 pointer for each String. if each character at pointer is not equal, then move the pointer to next index. <strong>Problem of this solution is we can’t decide which index should we move first</strong>.</p>\n<p>but how can I decide which index should I move?</p>\n<p>is the distinct value in array?</p>\n<p>can it be different order?</p>\n<ul>\n<li>I can sort the string first then compare</li>\n</ul>\n<p>Next solution can be using <strong>alphabet array</strong>. initialize the integer array with size 26 with -1. increase the index value +1 with text1. <strong>Problem of the solution is it doesn’t care of order</strong>. so It ignore the order, then we will get unexpected result</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(text1, text2, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dp</span><span class=\"params\">(String text1, String text2, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == text1.length() || j == text2.length()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(text1.charAt(i) == text2.charAt(j)) <span class=\"keyword\">return</span> <span class=\"number\">1</span> + dp(text1, text2, i + <span class=\"number\">1</span>, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> Math.max(dp(text1, text2, i + <span class=\"number\">1</span>, j), dp(text1, text2, i, j + <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bcf39165-2848-4ed2-9275-e88183243f89/67D53F86-2742-4880-8EBC-FAF283417715.jpeg\" alt=\"67D53F86-2742-4880-8EBC-FAF283417715.jpeg\"></p>\n<p>I ended up used Dynamic Programing. the goal is to find the longest subsequence so we can divide into sub problem. <strong>The sub problem can be defined by finding the longest subsequence and return the length of subsequence</strong>. the we can compare the return value of sub problems since it only divided by 2 sub problems. If one of the sub problem returns longer subsequence</p>\n<h3><span id=\"top-down\">Top Down</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] m;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> </span>&#123;</span><br><span class=\"line\">        m = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[text1.length()][text2.length()];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(text1, text2, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dp</span><span class=\"params\">(String text1, String text2, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == text1.length() || j == text2.length()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m[i][j] != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> m[i][j];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(text1.charAt(i) == text2.charAt(j)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m[i][j] = <span class=\"number\">1</span> + dp(text1, text2, i + <span class=\"number\">1</span>, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> m[i][j] = Math.max(dp(text1, text2, i + <span class=\"number\">1</span>, j), dp(text1, text2, i, j + <span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Problem of this solution is there are duplicate sub problems</strong>. for instance, “ee” appears twice in dp. It can be appeared many time and ended up exceeding time limit. So <strong>we have to use memoization to reduce i</strong>t.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/953f2d58-9a79-4c77-929b-e4afe73bcf00/6326514A-69EC-4BD2-B5EB-00965F07EFC4.jpeg\" alt=\"6326514A-69EC-4BD2-B5EB-00965F07EFC4.jpeg\"></p>\n<p>Since dp uses stack. it goes to one side and travel back to next sub problem</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> m[i][j] = Math.max(</span><br><span class=\"line\">\t\tdp(text1, text2, i + <span class=\"number\">1</span>, j), <span class=\"comment\">// check this method to the end</span></span><br><span class=\"line\">\t\tdp(text1, text2, i, j + <span class=\"number\">1</span>)  <span class=\"comment\">// travel back to this method</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98518a7c-e9bb-4ae4-95b1-7917ca1e4ef7/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"bottom-up\">Bottom Up</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] m;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> </span>&#123;</span><br><span class=\"line\">        m = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[text1.length()+<span class=\"number\">1</span>][text2.length()+<span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(text1.charAt(i - <span class=\"number\">1</span>) == text2.charAt(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    m[i][j] = <span class=\"number\">1</span> + m[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    m[i][j] = Math.max(m[i - <span class=\"number\">1</span>][j], m[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> m[text1.length()][text2.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/adff9992-f002-4a32-9d83-4102ce293300/C09A627F-47BF-4C8E-916D-378242C6247D.jpeg\" alt=\"C09A627F-47BF-4C8E-916D-378242C6247D.jpeg\"></p>\n<p>we also can use bottom up way. it check the value at i = 1, j = 1 so It covers two different cases when it meets condition. the condition is whether the value at i = 0, j = 0 on both of letter in text1, text2 is the same or not</p>\n<ol>\n<li><strong>if it is the same</strong> → retrieve value at <strong>i = 0, j = 0</strong></li>\n<li><strong>if it is not the same</strong> → retrieve value at <strong>i = 1, j = 0</strong> or <strong>i = 0, j = 1</strong></li>\n</ol>\n<p>if it reaches to the last index, it will have to the longest length of the subsequence. <strong>it is important that array m has extra space to store the calculated longest length</strong>. so the size of array is bigger than length of each text which are <code>text1.length() + 1</code>, <code>text2.length() + 1</code></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa9eabc6-e550-4ebc-825f-cf5a2657de10/Untitled.png\" alt=\"Untitled\"></p>\n<p>Why bottom up is faster than top down?</p>\n<ul>\n<li>My initial thoguth was top down is faster than bottom up since we don’t need to loop throught whole array. But I assume that memory stack takes more time</li>\n</ul>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p><strong>Dynamic programing</strong> is part of <strong>Stack</strong>.</p>\n<ul>\n<li>it goes <strong>all the way down to the end of condition</strong> and travel back up to the node has next branch.</li>\n</ul>\n</li>\n<li>\n<p>We need to <strong>cache the value</strong> and <strong>return the cached value</strong> for memoization</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dp</span><span class=\"params\">(String text1, String text2, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;        </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m[i][j] != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> m[i][j];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(text1.charAt(i) == text2.charAt(j)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m[i][j] = <span class=\"number\">1</span> + dp(text1, text2, i + <span class=\"number\">1</span>, j + <span class=\"number\">1</span>); <span class=\"comment\">// caching and return</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> m[i][j] = Math.max(dp(text1, text2, i + <span class=\"number\">1</span>, j), dp(text1, text2, i, j + <span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>bottom up needs extra space</p>\n<ul>\n<li>The cache array needs to bigger than original array to store the return value at the last index</li>\n<li>it usually starts from the 1 more large index and compare to smaller index\n<ul>\n<li>target = (1,1)</li>\n<li>compare = (0,0), (1,0), (0,1)</li>\n</ul>\n</li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] m;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        m = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[text1.length()+<span class=\"number\">1</span>][text2.length()+<span class=\"number\">1</span>]; </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(text1.charAt(i - <span class=\"number\">1</span>) == text2.charAt(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    m[i][j] = <span class=\"number\">1</span> + m[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    m[i][j] = Math.max(m[i - <span class=\"number\">1</span>][j], m[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> m[text1.length()][text2.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>find the longest subsequnce of both of text1 and text2</li>\n<li>new string is generated from the original string <strong>without change order</strong></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we will start from <strong>Brute Force</strong> algorithm with multi indices. we need 2 pointer for each String. if each character at pointer is not equal, then move the pointer to next index. <strong>Problem of this solution is we can’t decide which index should we move first</strong>.</p>\n<p>but how can I decide which index should I move?</p>\n<p>is the distinct value in array?</p>\n<p>can it be different order?</p>\n<ul>\n<li>I can sort the string first then compare</li>\n</ul>\n<p>Next solution can be using <strong>alphabet array</strong>. initialize the integer array with size 26 with -1. increase the index value +1 with text1. <strong>Problem of the solution is it doesn’t care of order</strong>. so It ignore the order, then we will get unexpected result</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(text1, text2, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dp</span><span class=\"params\">(String text1, String text2, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == text1.length() || j == text2.length()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(text1.charAt(i) == text2.charAt(j)) <span class=\"keyword\">return</span> <span class=\"number\">1</span> + dp(text1, text2, i + <span class=\"number\">1</span>, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> Math.max(dp(text1, text2, i + <span class=\"number\">1</span>, j), dp(text1, text2, i, j + <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bcf39165-2848-4ed2-9275-e88183243f89/67D53F86-2742-4880-8EBC-FAF283417715.jpeg\" alt=\"67D53F86-2742-4880-8EBC-FAF283417715.jpeg\"></p>\n<p>I ended up used Dynamic Programing. the goal is to find the longest subsequence so we can divide into sub problem. <strong>The sub problem can be defined by finding the longest subsequence and return the length of subsequence</strong>. the we can compare the return value of sub problems since it only divided by 2 sub problems. If one of the sub problem returns longer subsequence</p>\n<h3>Top Down</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] m;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> </span>&#123;</span><br><span class=\"line\">        m = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[text1.length()][text2.length()];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(text1, text2, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dp</span><span class=\"params\">(String text1, String text2, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == text1.length() || j == text2.length()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m[i][j] != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> m[i][j];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(text1.charAt(i) == text2.charAt(j)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m[i][j] = <span class=\"number\">1</span> + dp(text1, text2, i + <span class=\"number\">1</span>, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> m[i][j] = Math.max(dp(text1, text2, i + <span class=\"number\">1</span>, j), dp(text1, text2, i, j + <span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Problem of this solution is there are duplicate sub problems</strong>. for instance, “ee” appears twice in dp. It can be appeared many time and ended up exceeding time limit. So <strong>we have to use memoization to reduce i</strong>t.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/953f2d58-9a79-4c77-929b-e4afe73bcf00/6326514A-69EC-4BD2-B5EB-00965F07EFC4.jpeg\" alt=\"6326514A-69EC-4BD2-B5EB-00965F07EFC4.jpeg\"></p>\n<p>Since dp uses stack. it goes to one side and travel back to next sub problem</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> m[i][j] = Math.max(</span><br><span class=\"line\">\t\tdp(text1, text2, i + <span class=\"number\">1</span>, j), <span class=\"comment\">// check this method to the end</span></span><br><span class=\"line\">\t\tdp(text1, text2, i, j + <span class=\"number\">1</span>)  <span class=\"comment\">// travel back to this method</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98518a7c-e9bb-4ae4-95b1-7917ca1e4ef7/Untitled.png\" alt=\"Untitled\"></p>\n<h3>Bottom Up</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] m;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> </span>&#123;</span><br><span class=\"line\">        m = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[text1.length()+<span class=\"number\">1</span>][text2.length()+<span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(text1.charAt(i - <span class=\"number\">1</span>) == text2.charAt(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    m[i][j] = <span class=\"number\">1</span> + m[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    m[i][j] = Math.max(m[i - <span class=\"number\">1</span>][j], m[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> m[text1.length()][text2.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/adff9992-f002-4a32-9d83-4102ce293300/C09A627F-47BF-4C8E-916D-378242C6247D.jpeg\" alt=\"C09A627F-47BF-4C8E-916D-378242C6247D.jpeg\"></p>\n<p>we also can use bottom up way. it check the value at i = 1, j = 1 so It covers two different cases when it meets condition. the condition is whether the value at i = 0, j = 0 on both of letter in text1, text2 is the same or not</p>\n<ol>\n<li><strong>if it is the same</strong> → retrieve value at <strong>i = 0, j = 0</strong></li>\n<li><strong>if it is not the same</strong> → retrieve value at <strong>i = 1, j = 0</strong> or <strong>i = 0, j = 1</strong></li>\n</ol>\n<p>if it reaches to the last index, it will have to the longest length of the subsequence. <strong>it is important that array m has extra space to store the calculated longest length</strong>. so the size of array is bigger than length of each text which are <code>text1.length() + 1</code>, <code>text2.length() + 1</code></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa9eabc6-e550-4ebc-825f-cf5a2657de10/Untitled.png\" alt=\"Untitled\"></p>\n<p>Why bottom up is faster than top down?</p>\n<ul>\n<li>My initial thoguth was top down is faster than bottom up since we don’t need to loop throught whole array. But I assume that memory stack takes more time</li>\n</ul>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p><strong>Dynamic programing</strong> is part of <strong>Stack</strong>.</p>\n<ul>\n<li>it goes <strong>all the way down to the end of condition</strong> and travel back up to the node has next branch.</li>\n</ul>\n</li>\n<li>\n<p>We need to <strong>cache the value</strong> and <strong>return the cached value</strong> for memoization</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dp</span><span class=\"params\">(String text1, String text2, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;        </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m[i][j] != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> m[i][j];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(text1.charAt(i) == text2.charAt(j)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m[i][j] = <span class=\"number\">1</span> + dp(text1, text2, i + <span class=\"number\">1</span>, j + <span class=\"number\">1</span>); <span class=\"comment\">// caching and return</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> m[i][j] = Math.max(dp(text1, text2, i + <span class=\"number\">1</span>, j), dp(text1, text2, i, j + <span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>bottom up needs extra space</p>\n<ul>\n<li>The cache array needs to bigger than original array to store the return value at the last index</li>\n<li>it usually starts from the 1 more large index and compare to smaller index\n<ul>\n<li>target = (1,1)</li>\n<li>compare = (0,0), (1,0), (0,1)</li>\n</ul>\n</li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] m;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        m = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[text1.length()+<span class=\"number\">1</span>][text2.length()+<span class=\"number\">1</span>]; </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(text1.charAt(i - <span class=\"number\">1</span>) == text2.charAt(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    m[i][j] = <span class=\"number\">1</span> + m[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    m[i][j] = Math.max(m[i - <span class=\"number\">1</span>][j], m[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> m[text1.length()][text2.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"19. Remove Nth Node From End of List","catalog":true,"date":"2022-10-08T08:16:30.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- remove the `nth` node from the end of the list\n\n## Solve by hands first\n\n---\n\nI was thinking of using backtracking at first but there is no way to pass [1], 1 case.\n\nWe can use the two pointer and dummy node. move the fast node to the right until n is zero. it helps us not to make the reverse linked list. and then make dummy node connecting to head. The slow node will reference dummy node and move slow and fast node together until fast node is null\n\n![D2A30D41-1F0D-4ACD-A9F2-C9E507AE9BB3.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85ee2cc1-4beb-415f-a7a5-30b5b34b88b0/D2A30D41-1F0D-4ACD-A9F2-C9E507AE9BB3.jpeg)\n\nTime complexity is O(n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        \n        ListNode dummy = new ListNode(0, head);\n        ListNode slow = dummy, fast = head;\n        \n        while(n-- > 0) fast = fast.next;\n        while(fast != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        return dummy.next;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/872ce9c3-bde6-4f56-b9b5-cfd83acfdf48/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Two pointer is good for Linked list\n2. Dummy node can help\n\n```java\nNode dummy = new Node(0)\ndummy.next = head;\n\nreturn dummy.next // is equals to head;\n```\n\n1. Concat the node with only one node by using pointer\n\n```java\n// ~~slow.next = fast.next~~;\nslow.next = slow.next.next;\n```\n\n1. Backtracking is not a good option for linked list\n","source":"_posts/19-Remove-Nth-Node-From-End-of-List.md","raw":"---\ntitle: \"19.\\_Remove Nth Node From End of List\"\ncatalog: true\ndate: 2022-10-08 17:16:30\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- remove the `nth` node from the end of the list\n\n## Solve by hands first\n\n---\n\nI was thinking of using backtracking at first but there is no way to pass [1], 1 case.\n\nWe can use the two pointer and dummy node. move the fast node to the right until n is zero. it helps us not to make the reverse linked list. and then make dummy node connecting to head. The slow node will reference dummy node and move slow and fast node together until fast node is null\n\n![D2A30D41-1F0D-4ACD-A9F2-C9E507AE9BB3.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85ee2cc1-4beb-415f-a7a5-30b5b34b88b0/D2A30D41-1F0D-4ACD-A9F2-C9E507AE9BB3.jpeg)\n\nTime complexity is O(n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        \n        ListNode dummy = new ListNode(0, head);\n        ListNode slow = dummy, fast = head;\n        \n        while(n-- > 0) fast = fast.next;\n        while(fast != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        return dummy.next;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/872ce9c3-bde6-4f56-b9b5-cfd83acfdf48/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Two pointer is good for Linked list\n2. Dummy node can help\n\n```java\nNode dummy = new Node(0)\ndummy.next = head;\n\nreturn dummy.next // is equals to head;\n```\n\n1. Concat the node with only one node by using pointer\n\n```java\n// ~~slow.next = fast.next~~;\nslow.next = slow.next.next;\n```\n\n1. Backtracking is not a good option for linked list\n","slug":"19-Remove-Nth-Node-From-End-of-List","published":1,"updated":"2022-10-08T08:16:46.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc17000pqkccgncj4n1d","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>remove the <code>nth</code> node from the end of the list</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>I was thinking of using backtracking at first but there is no way to pass [1], 1 case.</p>\n<p>We can use the two pointer and dummy node. move the fast node to the right until n is zero. it helps us not to make the reverse linked list. and then make dummy node connecting to head. The slow node will reference dummy node and move slow and fast node together until fast node is null</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85ee2cc1-4beb-415f-a7a5-30b5b34b88b0/D2A30D41-1F0D-4ACD-A9F2-C9E507AE9BB3.jpeg\" alt=\"D2A30D41-1F0D-4ACD-A9F2-C9E507AE9BB3.jpeg\"></p>\n<p>Time complexity is O(n)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode dummy = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>, head);</span><br><span class=\"line\">        ListNode slow = dummy, fast = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n-- &gt; <span class=\"number\">0</span>) fast = fast.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        slow.next = slow.next.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/872ce9c3-bde6-4f56-b9b5-cfd83acfdf48/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>Two pointer is good for Linked list</li>\n<li>Dummy node can help</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node dummy = <span class=\"keyword\">new</span> Node(<span class=\"number\">0</span>)</span><br><span class=\"line\">dummy.next = head;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> dummy.next <span class=\"comment\">// is equals to head;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>Concat the node with only one node by using pointer</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ~~slow.next = fast.next~~;</span></span><br><span class=\"line\">slow.next = slow.next.next;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Backtracking is not a good option for linked list</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>remove the <code>nth</code> node from the end of the list</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>I was thinking of using backtracking at first but there is no way to pass [1], 1 case.</p>\n<p>We can use the two pointer and dummy node. move the fast node to the right until n is zero. it helps us not to make the reverse linked list. and then make dummy node connecting to head. The slow node will reference dummy node and move slow and fast node together until fast node is null</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85ee2cc1-4beb-415f-a7a5-30b5b34b88b0/D2A30D41-1F0D-4ACD-A9F2-C9E507AE9BB3.jpeg\" alt=\"D2A30D41-1F0D-4ACD-A9F2-C9E507AE9BB3.jpeg\"></p>\n<p>Time complexity is O(n)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode dummy = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>, head);</span><br><span class=\"line\">        ListNode slow = dummy, fast = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n-- &gt; <span class=\"number\">0</span>) fast = fast.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        slow.next = slow.next.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/872ce9c3-bde6-4f56-b9b5-cfd83acfdf48/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>Two pointer is good for Linked list</li>\n<li>Dummy node can help</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node dummy = <span class=\"keyword\">new</span> Node(<span class=\"number\">0</span>)</span><br><span class=\"line\">dummy.next = head;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> dummy.next <span class=\"comment\">// is equals to head;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>Concat the node with only one node by using pointer</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ~~slow.next = fast.next~~;</span></span><br><span class=\"line\">slow.next = slow.next.next;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Backtracking is not a good option for linked list</li>\n</ol>\n"},{"title":"191. Number of 1 Bits","catalog":true,"date":"2022-09-24T06:09:17.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- Write a function that takes an unsigned integer\n- returns the number of '1' bits\n\n## Solve by hands first\n\n---\n\nwe can use one of bit manipulation operator. we can shift input bits to right and compare with AND operator. if result is 1 then we can count them\n\n| a | b | a & b (AND) | a | b (OR) | a ^ b (XOR) |\n| --- | --- | --- | --- | --- |\n| 0 | 0 | 0 | 0 | 1 |\n| 0 | 1 | 0 | 1 | 0 |\n| 1 | 0 | 0 | 1 | 0 |\n| 1 | 1 | 1 | 1 | 1 |\n\n## Solution\n\n---\n\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n      int count = 0;\n        while(n != 0) {\n            if((n & 1) == 1) count++;\n            n = n >>> 1;\n        }\n        return count;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/31e66524-1c64-4167-b3d4-e033f26dda44/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n- there is **no unsigned integer** type in Java\n- In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement)\n- **2’s completement notation**\n    - to get negative value in java there are two steps\n        1. **switch every 0 to 1 and 1 to 0 (complementation)**\n        2. **add 1 (&)**\n    - for instance to make -7 from 7\n    \n    ```java\n    \t\t\t\t\t0111 -> 4 + 2 + 1 = 7\n    switch    1000\n    add 1        1\n    --------------\n              1001 -> -8 + 1 = 7 \n    ```\n    \n- `>>` vs `>>>`\n    - `>>` : signed right shift\n    - `>>>` : unsigned right shift\n    - [https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html)\n- what is signed and unsigned number?\n    - **signed value** : postive or negative\n        - left most bit is signbit\n        - `0` : positive\n        - `1` : negative\n    - **unsigned value** : only positive\n- why do we need signed and unsgined number?\n    - \n\n| name | value | range | operator | java support |\n| --- | --- | --- | --- | --- |\n| signed | positive (0) & negative (1) | -2^32-1 ~ 2^32-1  | >> | o |\n| unsigned | positive | 0 ~ 2^32-1 | >>> | x |\n- how to handle minus bits\n","source":"_posts/191-Number-of-1-Bits.md","raw":"---\ntitle: \"191.\\_Number of 1 Bits\"\ncatalog: true\ndate: 2022-09-24 15:09:17\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- Write a function that takes an unsigned integer\n- returns the number of '1' bits\n\n## Solve by hands first\n\n---\n\nwe can use one of bit manipulation operator. we can shift input bits to right and compare with AND operator. if result is 1 then we can count them\n\n| a | b | a & b (AND) | a | b (OR) | a ^ b (XOR) |\n| --- | --- | --- | --- | --- |\n| 0 | 0 | 0 | 0 | 1 |\n| 0 | 1 | 0 | 1 | 0 |\n| 1 | 0 | 0 | 1 | 0 |\n| 1 | 1 | 1 | 1 | 1 |\n\n## Solution\n\n---\n\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n      int count = 0;\n        while(n != 0) {\n            if((n & 1) == 1) count++;\n            n = n >>> 1;\n        }\n        return count;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/31e66524-1c64-4167-b3d4-e033f26dda44/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n- there is **no unsigned integer** type in Java\n- In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement)\n- **2’s completement notation**\n    - to get negative value in java there are two steps\n        1. **switch every 0 to 1 and 1 to 0 (complementation)**\n        2. **add 1 (&)**\n    - for instance to make -7 from 7\n    \n    ```java\n    \t\t\t\t\t0111 -> 4 + 2 + 1 = 7\n    switch    1000\n    add 1        1\n    --------------\n              1001 -> -8 + 1 = 7 \n    ```\n    \n- `>>` vs `>>>`\n    - `>>` : signed right shift\n    - `>>>` : unsigned right shift\n    - [https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html)\n- what is signed and unsigned number?\n    - **signed value** : postive or negative\n        - left most bit is signbit\n        - `0` : positive\n        - `1` : negative\n    - **unsigned value** : only positive\n- why do we need signed and unsgined number?\n    - \n\n| name | value | range | operator | java support |\n| --- | --- | --- | --- | --- |\n| signed | positive (0) & negative (1) | -2^32-1 ~ 2^32-1  | >> | o |\n| unsigned | positive | 0 ~ 2^32-1 | >>> | x |\n- how to handle minus bits\n","slug":"191-Number-of-1-Bits","published":1,"updated":"2022-09-24T06:09:35.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc18000qqkccsaq53lcq","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>Write a function that takes an unsigned integer</li>\n<li>returns the number of ‘1’ bits</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can use one of bit manipulation operator. we can shift input bits to right and compare with AND operator. if result is 1 then we can count them</p>\n<p>| a | b | a &amp; b (AND) | a | b (OR) | a ^ b (XOR) |<br>\n| — | — | — | — | — |<br>\n| 0 | 0 | 0 | 0 | 1 |<br>\n| 0 | 1 | 0 | 1 | 0 |<br>\n| 1 | 0 | 0 | 1 | 0 |<br>\n| 1 | 1 | 1 | 1 | 1 |</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need to treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) count++;</span><br><span class=\"line\">            n = n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/31e66524-1c64-4167-b3d4-e033f26dda44/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ul>\n<li>\n<p>there is <strong>no unsigned integer</strong> type in Java</p>\n</li>\n<li>\n<p>In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\" rel=\"noopener\">2’s complement notation</a></p>\n</li>\n<li>\n<p><strong>2’s completement notation</strong></p>\n<ul>\n<li>to get negative value in java there are two steps\n<ol>\n<li><strong>switch every 0 to 1 and 1 to 0 (complementation)</strong></li>\n<li><strong>add 1 (&amp;)</strong></li>\n</ol>\n</li>\n<li>for instance to make -7 from 7</li>\n</ul>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\t<span class=\"number\">0111</span> -&gt; <span class=\"number\">4</span> + <span class=\"number\">2</span> + <span class=\"number\">1</span> = <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span>    <span class=\"number\">1000</span></span><br><span class=\"line\">add <span class=\"number\">1</span>        <span class=\"number\">1</span></span><br><span class=\"line\">--------------</span><br><span class=\"line\">          <span class=\"number\">1001</span> -&gt; -<span class=\"number\">8</span> + <span class=\"number\">1</span> = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><code>&gt;&gt;</code> vs <code>&gt;&gt;&gt;</code>\n<ul>\n<li><code>&gt;&gt;</code> : signed right shift</li>\n<li><code>&gt;&gt;&gt;</code> : unsigned right shift</li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html</a></li>\n</ul>\n</li>\n<li>what is signed and unsigned number?\n<ul>\n<li><strong>signed value</strong> : postive or negative\n<ul>\n<li>left most bit is signbit</li>\n<li><code>0</code> : positive</li>\n<li><code>1</code> : negative</li>\n</ul>\n</li>\n<li><strong>unsigned value</strong> : only positive</li>\n</ul>\n</li>\n<li>\n<h2><span id=\"why-do-we-need-signed-and-unsgined-number\">why do we need signed and unsgined number?</span></h2>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>value</th>\n<th>range</th>\n<th>operator</th>\n<th>java support</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>signed</td>\n<td>positive (0) &amp; negative (1)</td>\n<td>-2^32-1 ~ 2^32-1</td>\n<td>&gt;&gt;</td>\n<td>o</td>\n</tr>\n<tr>\n<td>unsigned</td>\n<td>positive</td>\n<td>0 ~ 2^32-1</td>\n<td>&gt;&gt;&gt;</td>\n<td>x</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>how to handle minus bits</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>Write a function that takes an unsigned integer</li>\n<li>returns the number of ‘1’ bits</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can use one of bit manipulation operator. we can shift input bits to right and compare with AND operator. if result is 1 then we can count them</p>\n<p>| a | b | a &amp; b (AND) | a | b (OR) | a ^ b (XOR) |<br>\n| — | — | — | — | — |<br>\n| 0 | 0 | 0 | 0 | 1 |<br>\n| 0 | 1 | 0 | 1 | 0 |<br>\n| 1 | 0 | 0 | 1 | 0 |<br>\n| 1 | 1 | 1 | 1 | 1 |</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need to treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) count++;</span><br><span class=\"line\">            n = n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/31e66524-1c64-4167-b3d4-e033f26dda44/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ul>\n<li>\n<p>there is <strong>no unsigned integer</strong> type in Java</p>\n</li>\n<li>\n<p>In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\" rel=\"noopener\">2’s complement notation</a></p>\n</li>\n<li>\n<p><strong>2’s completement notation</strong></p>\n<ul>\n<li>to get negative value in java there are two steps\n<ol>\n<li><strong>switch every 0 to 1 and 1 to 0 (complementation)</strong></li>\n<li><strong>add 1 (&amp;)</strong></li>\n</ol>\n</li>\n<li>for instance to make -7 from 7</li>\n</ul>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t\t\t<span class=\"number\">0111</span> -&gt; <span class=\"number\">4</span> + <span class=\"number\">2</span> + <span class=\"number\">1</span> = <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span>    <span class=\"number\">1000</span></span><br><span class=\"line\">add <span class=\"number\">1</span>        <span class=\"number\">1</span></span><br><span class=\"line\">--------------</span><br><span class=\"line\">          <span class=\"number\">1001</span> -&gt; -<span class=\"number\">8</span> + <span class=\"number\">1</span> = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><code>&gt;&gt;</code> vs <code>&gt;&gt;&gt;</code>\n<ul>\n<li><code>&gt;&gt;</code> : signed right shift</li>\n<li><code>&gt;&gt;&gt;</code> : unsigned right shift</li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html</a></li>\n</ul>\n</li>\n<li>what is signed and unsigned number?\n<ul>\n<li><strong>signed value</strong> : postive or negative\n<ul>\n<li>left most bit is signbit</li>\n<li><code>0</code> : positive</li>\n<li><code>1</code> : negative</li>\n</ul>\n</li>\n<li><strong>unsigned value</strong> : only positive</li>\n</ul>\n</li>\n<li>\n<h2>why do we need signed and unsgined number?</h2>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>value</th>\n<th>range</th>\n<th>operator</th>\n<th>java support</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>signed</td>\n<td>positive (0) &amp; negative (1)</td>\n<td>-2^32-1 ~ 2^32-1</td>\n<td>&gt;&gt;</td>\n<td>o</td>\n</tr>\n<tr>\n<td>unsigned</td>\n<td>positive</td>\n<td>0 ~ 2^32-1</td>\n<td>&gt;&gt;&gt;</td>\n<td>x</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>how to handle minus bits</li>\n</ul>\n"},{"title":"190. Reverse Bits","catalog":true,"date":"2022-10-02T05:59:46.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- 32 bits unsigned integer.\n\n## Solve by hands first\n\n---\n\n1. do `&` with the given 32 bits integer and 1\n2. shift right the given integer\n3. do `&` for cache\n4. shift left the cache\n\nFor instance, the given 32 bits is 10111\n\n1. 10111 & 1 = 1\n2. c = c | 1 (1)\n3. n >>> 1 (1011)\n4. c << 1 (10)\n\n![88F3E09B-0242-46D2-9D89-87F3960C7F59.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1cff6777-2773-4017-a30c-60f35db8304c/88F3E09B-0242-46D2-9D89-87F3960C7F59.jpeg)\n\nProblem is there is no unsigned shift left(`<<<`) operation in java\n\nso we need to get sign bit from the given bits\n\n```java\nint sign = n & (1 << 32);\n```\n\n## Solution\n\n---\n\n```java\npublic class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int sign = n & (1 << 32);\n        \n        int c = 0;\n        for(int i = 0; i < 32; i++) {\n            if((n & 1) == 1) c |= 1;\n            n = n >>> 1;\n            c = c << 1;\n        }\n        \n        return (c >>> 1) | (sign << 31);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/713c2c04-6f8a-46b9-94d0-b9b8187e14e6/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. cache will help for any reverse problem\n2. there is **no unsign shift left in java**\n    - [https://stackoverflow.com/questions/26246078/difficulty-in-understanding-and-correcting-error-messages](https://stackoverflow.com/questions/26246078/difficulty-in-understanding-and-correcting-error-messages)\n","source":"_posts/190-Reverse-Bits.md","raw":"---\ntitle: \"190.\\_Reverse Bits\"\ncatalog: true\ndate: 2022-10-02 14:59:46\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- 32 bits unsigned integer.\n\n## Solve by hands first\n\n---\n\n1. do `&` with the given 32 bits integer and 1\n2. shift right the given integer\n3. do `&` for cache\n4. shift left the cache\n\nFor instance, the given 32 bits is 10111\n\n1. 10111 & 1 = 1\n2. c = c | 1 (1)\n3. n >>> 1 (1011)\n4. c << 1 (10)\n\n![88F3E09B-0242-46D2-9D89-87F3960C7F59.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1cff6777-2773-4017-a30c-60f35db8304c/88F3E09B-0242-46D2-9D89-87F3960C7F59.jpeg)\n\nProblem is there is no unsigned shift left(`<<<`) operation in java\n\nso we need to get sign bit from the given bits\n\n```java\nint sign = n & (1 << 32);\n```\n\n## Solution\n\n---\n\n```java\npublic class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int sign = n & (1 << 32);\n        \n        int c = 0;\n        for(int i = 0; i < 32; i++) {\n            if((n & 1) == 1) c |= 1;\n            n = n >>> 1;\n            c = c << 1;\n        }\n        \n        return (c >>> 1) | (sign << 31);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/713c2c04-6f8a-46b9-94d0-b9b8187e14e6/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. cache will help for any reverse problem\n2. there is **no unsign shift left in java**\n    - [https://stackoverflow.com/questions/26246078/difficulty-in-understanding-and-correcting-error-messages](https://stackoverflow.com/questions/26246078/difficulty-in-understanding-and-correcting-error-messages)\n","slug":"190-Reverse-Bits","published":1,"updated":"2022-10-02T05:59:57.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc18000rqkccmq1og1pu","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>32 bits unsigned integer.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<ol>\n<li>do <code>&amp;</code> with the given 32 bits integer and 1</li>\n<li>shift right the given integer</li>\n<li>do <code>&amp;</code> for cache</li>\n<li>shift left the cache</li>\n</ol>\n<p>For instance, the given 32 bits is 10111</p>\n<ol>\n<li>10111 &amp; 1 = 1</li>\n<li>c = c | 1 (1)</li>\n<li>n &gt;&gt;&gt; 1 (1011)</li>\n<li>c &lt;&lt; 1 (10)</li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1cff6777-2773-4017-a30c-60f35db8304c/88F3E09B-0242-46D2-9D89-87F3960C7F59.jpeg\" alt=\"88F3E09B-0242-46D2-9D89-87F3960C7F59.jpeg\"></p>\n<p>Problem is there is no unsigned shift left(<code>&lt;&lt;&lt;</code>) operation in java</p>\n<p>so we need to get sign bit from the given bits</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sign = n &amp; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">32</span>);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sign = n &amp; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">32</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) c |= <span class=\"number\">1</span>;</span><br><span class=\"line\">            n = n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            c = c &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (c &gt;&gt;&gt; <span class=\"number\">1</span>) | (sign &lt;&lt; <span class=\"number\">31</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/713c2c04-6f8a-46b9-94d0-b9b8187e14e6/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>cache will help for any reverse problem</li>\n<li>there is <strong>no unsign shift left in java</strong>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/26246078/difficulty-in-understanding-and-correcting-error-messages\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/26246078/difficulty-in-understanding-and-correcting-error-messages</a></li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>32 bits unsigned integer.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<ol>\n<li>do <code>&amp;</code> with the given 32 bits integer and 1</li>\n<li>shift right the given integer</li>\n<li>do <code>&amp;</code> for cache</li>\n<li>shift left the cache</li>\n</ol>\n<p>For instance, the given 32 bits is 10111</p>\n<ol>\n<li>10111 &amp; 1 = 1</li>\n<li>c = c | 1 (1)</li>\n<li>n &gt;&gt;&gt; 1 (1011)</li>\n<li>c &lt;&lt; 1 (10)</li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1cff6777-2773-4017-a30c-60f35db8304c/88F3E09B-0242-46D2-9D89-87F3960C7F59.jpeg\" alt=\"88F3E09B-0242-46D2-9D89-87F3960C7F59.jpeg\"></p>\n<p>Problem is there is no unsigned shift left(<code>&lt;&lt;&lt;</code>) operation in java</p>\n<p>so we need to get sign bit from the given bits</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sign = n &amp; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">32</span>);</span><br></pre></td></tr></table></figure>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sign = n &amp; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">32</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) c |= <span class=\"number\">1</span>;</span><br><span class=\"line\">            n = n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            c = c &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (c &gt;&gt;&gt; <span class=\"number\">1</span>) | (sign &lt;&lt; <span class=\"number\">31</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/713c2c04-6f8a-46b9-94d0-b9b8187e14e6/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>cache will help for any reverse problem</li>\n<li>there is <strong>no unsign shift left in java</strong>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/26246078/difficulty-in-understanding-and-correcting-error-messages\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/26246078/difficulty-in-understanding-and-correcting-error-messages</a></li>\n</ul>\n</li>\n</ol>\n"},{"title":"198. House Robber","catalog":true,"date":"2022-10-01T15:41:19.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- **it will automatically contact the police if two adjacent houses were broken into on the same night**\n- return ***the maximum amount of money** you can rob tonight **without alerting the police***\n\n## Solve by hands first\n\n---\n\nit’s dynamic programming + memoization problem. Time complexity is O(n) and space complexity is O(n)\n\n## Solution\n\n---\n\n### top-down\n\n```java\nclass Solution {\n    \n    int[] dp;\n    \n    public int rob(int[] nums) {\n        dp = new int[nums.length];\n        Arrays.fill(dp, -1);\n        \n        return dfs(nums, nums.length-1);\n    }\n    \n    private int dfs(int[] nums, int i) { \n        if(i < 0) return 0;\n        if(dp[i] != -1) return dp[i];\n        \n        return dp[i] = Math.max(dfs(nums, i - 2) + nums[i], dfs(nums, i - 1));\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c9d36ba0-fb69-4459-9339-656af4969d12/Untitled.png)\n\n![999401C1-FE13-48F2-9187-866676E614F9.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c93822ee-eed1-4881-8021-a0bfebd15105/999401C1-FE13-48F2-9187-866676E614F9.jpeg)\n\n![F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b400338-072b-44fd-a807-ec376ccec8e8/F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg)\n\nin order to find maximum amount of money at house `i` , we have to compare the cumumlative amount of money at house `i-1` as well. because there we can’t rob the adjacent house so we have to decide which house has more amount money between `i` and `i-1` even tho house at `i`\n\nthere are 2 options to rob\n\n1. rob current house `i` \n2. don’t rob current house\n\nfirst option means that add current money `i` to an cumulative money `i-2`\n\nsecodn option is that choose the an cumulative money `i-1` houses\n\n```java\nMath.max(dfs(i - 2) + nums[i], dfs(i - 1));\n```\n\n### bottom-up\n\n```java\nclass Solution {\n    \n    int[] dp;\n    \n    public int rob(int[] nums) {\n        dp = new int[nums.length + 1];\n        \n        dp[0] = 0;\n        dp[1] = nums[0];\n        for(int i = 2; i < dp.length; i++) {\n            dp[i] = Math.max(dp[i-2] + nums[i-1], dp[i - 1]);\n        }\n        return dp[dp.length - 1];\n    }\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e03378ed-1277-4b21-a795-4b0632ffb016/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. dynamic programming can be start from length to 0\n2. relationship between sub problem and current problem\n    \n    ```java\n    Math.max(dfs(i-2) + nums[i]\n    ```\n    \n3. use Arrays method to fill with -1\n    \n    ```java\n    Arrays.fill(dp, -1);\n    ```\n    \n4. value of node can be element of memoization\n    \n    ![F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b400338-072b-44fd-a807-ec376ccec8e8/F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg)\n    \n5. need extra space for bottom up memoization\n    - I thought I was able to reuse `nums` array but it cause the out of bound at `i-2`\n    - so I create `dp` with size of nums.length + 1 and set 0 at index 0 for `i-2`\n    \n    ```java\n    int[] dp;\n      \n    public int rob(int[] nums) {\n        dp = new int[nums.length + 1];\n        \n        dp[0] = 0;\n        dp[1] = nums[0];\n        for(int i = 2; i < dp.length; i++) {\n            dp[i] = Math.max(dp[i-2] + nums[i-1], dp[i - 1]);\n        }\n        return dp[dp.length - 1];\n    }\n    ```\n","source":"_posts/198-House-Robber.md","raw":"---\ntitle: \"198.\\_House Robber\"\ncatalog: true\ndate: 2022-10-02 00:41:19\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- **it will automatically contact the police if two adjacent houses were broken into on the same night**\n- return ***the maximum amount of money** you can rob tonight **without alerting the police***\n\n## Solve by hands first\n\n---\n\nit’s dynamic programming + memoization problem. Time complexity is O(n) and space complexity is O(n)\n\n## Solution\n\n---\n\n### top-down\n\n```java\nclass Solution {\n    \n    int[] dp;\n    \n    public int rob(int[] nums) {\n        dp = new int[nums.length];\n        Arrays.fill(dp, -1);\n        \n        return dfs(nums, nums.length-1);\n    }\n    \n    private int dfs(int[] nums, int i) { \n        if(i < 0) return 0;\n        if(dp[i] != -1) return dp[i];\n        \n        return dp[i] = Math.max(dfs(nums, i - 2) + nums[i], dfs(nums, i - 1));\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c9d36ba0-fb69-4459-9339-656af4969d12/Untitled.png)\n\n![999401C1-FE13-48F2-9187-866676E614F9.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c93822ee-eed1-4881-8021-a0bfebd15105/999401C1-FE13-48F2-9187-866676E614F9.jpeg)\n\n![F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b400338-072b-44fd-a807-ec376ccec8e8/F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg)\n\nin order to find maximum amount of money at house `i` , we have to compare the cumumlative amount of money at house `i-1` as well. because there we can’t rob the adjacent house so we have to decide which house has more amount money between `i` and `i-1` even tho house at `i`\n\nthere are 2 options to rob\n\n1. rob current house `i` \n2. don’t rob current house\n\nfirst option means that add current money `i` to an cumulative money `i-2`\n\nsecodn option is that choose the an cumulative money `i-1` houses\n\n```java\nMath.max(dfs(i - 2) + nums[i], dfs(i - 1));\n```\n\n### bottom-up\n\n```java\nclass Solution {\n    \n    int[] dp;\n    \n    public int rob(int[] nums) {\n        dp = new int[nums.length + 1];\n        \n        dp[0] = 0;\n        dp[1] = nums[0];\n        for(int i = 2; i < dp.length; i++) {\n            dp[i] = Math.max(dp[i-2] + nums[i-1], dp[i - 1]);\n        }\n        return dp[dp.length - 1];\n    }\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e03378ed-1277-4b21-a795-4b0632ffb016/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. dynamic programming can be start from length to 0\n2. relationship between sub problem and current problem\n    \n    ```java\n    Math.max(dfs(i-2) + nums[i]\n    ```\n    \n3. use Arrays method to fill with -1\n    \n    ```java\n    Arrays.fill(dp, -1);\n    ```\n    \n4. value of node can be element of memoization\n    \n    ![F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b400338-072b-44fd-a807-ec376ccec8e8/F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg)\n    \n5. need extra space for bottom up memoization\n    - I thought I was able to reuse `nums` array but it cause the out of bound at `i-2`\n    - so I create `dp` with size of nums.length + 1 and set 0 at index 0 for `i-2`\n    \n    ```java\n    int[] dp;\n      \n    public int rob(int[] nums) {\n        dp = new int[nums.length + 1];\n        \n        dp[0] = 0;\n        dp[1] = nums[0];\n        for(int i = 2; i < dp.length; i++) {\n            dp[i] = Math.max(dp[i-2] + nums[i-1], dp[i - 1]);\n        }\n        return dp[dp.length - 1];\n    }\n    ```\n","slug":"198-House-Robber","published":1,"updated":"2022-10-01T15:41:52.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc18000sqkccq7w62r7o","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li><strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong></li>\n<li>return <em><strong>the maximum amount of money</strong> you can rob tonight <strong>without alerting the police</strong></em></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>it’s dynamic programming + memoization problem. Time complexity is O(n) and space complexity is O(n)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<h3><span id=\"top-down\">top-down</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length];</span><br><span class=\"line\">        Arrays.fill(dp, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(nums, nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i)</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[i] != -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> dp[i];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[i] = Math.max(dfs(nums, i - <span class=\"number\">2</span>) + nums[i], dfs(nums, i - <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c9d36ba0-fb69-4459-9339-656af4969d12/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c93822ee-eed1-4881-8021-a0bfebd15105/999401C1-FE13-48F2-9187-866676E614F9.jpeg\" alt=\"999401C1-FE13-48F2-9187-866676E614F9.jpeg\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b400338-072b-44fd-a807-ec376ccec8e8/F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg\" alt=\"F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg\"></p>\n<p>in order to find maximum amount of money at house <code>i</code> , we have to compare the cumumlative amount of money at house <code>i-1</code> as well. because there we can’t rob the adjacent house so we have to decide which house has more amount money between <code>i</code> and <code>i-1</code> even tho house at <code>i</code></p>\n<p>there are 2 options to rob</p>\n<ol>\n<li>rob current house <code>i</code></li>\n<li>don’t rob current house</li>\n</ol>\n<p>first option means that add current money <code>i</code> to an cumulative money <code>i-2</code></p>\n<p>secodn option is that choose the an cumulative money <code>i-1</code> houses</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.max(dfs(i - <span class=\"number\">2</span>) + nums[i], dfs(i - <span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n<h3><span id=\"bottom-up\">bottom-up</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class=\"line\">            dp[i] = Math.max(dp[i-<span class=\"number\">2</span>] + nums[i-<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[dp.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e03378ed-1277-4b21-a795-4b0632ffb016/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>dynamic programming can be start from length to 0</p>\n</li>\n<li>\n<p>relationship between sub problem and current problem</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.max(dfs(i-<span class=\"number\">2</span>) + nums[i]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>use Arrays method to fill with -1</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.fill(dp, -<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p>value of node can be element of memoization</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b400338-072b-44fd-a807-ec376ccec8e8/F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg\" alt=\"F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg\"></p>\n</li>\n<li>\n<p>need extra space for bottom up memoization</p>\n<ul>\n<li>I thought I was able to reuse <code>nums</code> array but it cause the out of bound at <code>i-2</code></li>\n<li>so I create <code>dp</code> with size of nums.length + 1 and set 0 at index 0 for <code>i-2</code></li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] dp;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class=\"line\">        dp[i] = Math.max(dp[i-<span class=\"number\">2</span>] + nums[i-<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[dp.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li><strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong></li>\n<li>return <em><strong>the maximum amount of money</strong> you can rob tonight <strong>without alerting the police</strong></em></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>it’s dynamic programming + memoization problem. Time complexity is O(n) and space complexity is O(n)</p>\n<h2>Solution</h2>\n<hr>\n<h3>top-down</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length];</span><br><span class=\"line\">        Arrays.fill(dp, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(nums, nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i)</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[i] != -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> dp[i];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[i] = Math.max(dfs(nums, i - <span class=\"number\">2</span>) + nums[i], dfs(nums, i - <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c9d36ba0-fb69-4459-9339-656af4969d12/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c93822ee-eed1-4881-8021-a0bfebd15105/999401C1-FE13-48F2-9187-866676E614F9.jpeg\" alt=\"999401C1-FE13-48F2-9187-866676E614F9.jpeg\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b400338-072b-44fd-a807-ec376ccec8e8/F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg\" alt=\"F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg\"></p>\n<p>in order to find maximum amount of money at house <code>i</code> , we have to compare the cumumlative amount of money at house <code>i-1</code> as well. because there we can’t rob the adjacent house so we have to decide which house has more amount money between <code>i</code> and <code>i-1</code> even tho house at <code>i</code></p>\n<p>there are 2 options to rob</p>\n<ol>\n<li>rob current house <code>i</code></li>\n<li>don’t rob current house</li>\n</ol>\n<p>first option means that add current money <code>i</code> to an cumulative money <code>i-2</code></p>\n<p>secodn option is that choose the an cumulative money <code>i-1</code> houses</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.max(dfs(i - <span class=\"number\">2</span>) + nums[i], dfs(i - <span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n<h3>bottom-up</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class=\"line\">            dp[i] = Math.max(dp[i-<span class=\"number\">2</span>] + nums[i-<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[dp.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e03378ed-1277-4b21-a795-4b0632ffb016/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>dynamic programming can be start from length to 0</p>\n</li>\n<li>\n<p>relationship between sub problem and current problem</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.max(dfs(i-<span class=\"number\">2</span>) + nums[i]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>use Arrays method to fill with -1</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.fill(dp, -<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p>value of node can be element of memoization</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b400338-072b-44fd-a807-ec376ccec8e8/F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg\" alt=\"F93EAE72-6D07-4C5F-913A-E55CC0C43572.jpeg\"></p>\n</li>\n<li>\n<p>need extra space for bottom up memoization</p>\n<ul>\n<li>I thought I was able to reuse <code>nums</code> array but it cause the out of bound at <code>i-2</code></li>\n<li>so I create <code>dp</code> with size of nums.length + 1 and set 0 at index 0 for <code>i-2</code></li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] dp;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class=\"line\">        dp[i] = Math.max(dp[i-<span class=\"number\">2</span>] + nums[i-<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[dp.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"200. Number of Islands","catalog":true,"date":"2022-09-21T11:39:28.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- m == grid.length\n- n == grid[i].length\n- island is surrounded by water\n- is formed by connecting adjacent lands horizontally or vertically\n\n## Solve by hands first\n\n---\n\nwe can start with bfs algorithm. since we have to check the adjacent cells at a time. if every cells is within boundary and there is no other land left in horizon and vertical direction. Count the number of island. Time complexity will be O(m*n)\n\n**we also can use dfs algorithm!**\n\n## Solution\n\n---\n\n### bfs\n\n```java\nclass Solution {\n    \n    Queue<Point> q = new LinkedList();\n    \n    int count = 0;\n\n    int[] dx = new int[]{1,-1,0,0};\n    int[] dy = new int[]{0,0,1,-1};\n    \n    class Point {\n        \n        int x;\n        int y;\n        \n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public int numIslands(char[][] grid) {\n                \n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == '1') {\n                    q.add(new Point(i, j));\n                    bfs(grid, i, j);\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    private void bfs(char[][] grid, int i, int j) {\n        while(!q.isEmpty()) {\n            Point p = q.poll();\n            \n            for(int z = 0; z < 4; z++) {\n                int nx = p.x + dx[z];\n                int ny = p.y + dy[z];\n                \n                if(nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length || grid[nx][ny] == '0') continue;\n                \n                q.add(new Point(nx, ny));\n                grid[nx][ny] = '0';\n            }\n        }\n        count++;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7dd86d16-519e-4e61-875a-4ab995711e17/Untitled.png)\n\n### bfs\n\n```java\nclass Solution {\n    \n  public int numIslands(char[][] grid) {\n      int count = 0;\n      for(int i = 0; i < grid.length; i++) {\n          for(int j = 0; j < grid[0].length; j++) {\n              if(grid[i][j] == '1') {\n                  dfs(grid, i, j);\n                  count++;\n              }\n          }\n      }\n      return count;\n  }\n  \n  private void dfs(char[][] grid, int i, int j) {\n      if(i < 0 || j <i >= g                }\n                \n                for(int x = 0; x < 4; x++) {\n                    int nx = p.x + dx[x];\n                    int ny = p.y + dy[x];\n                    \n                    if(nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length || visited[nx][ny]) continue;\n                    \n                    if(grid[nx][ny] == '1') {\n                        q.add(new Point(nx, ny)); // snapshot\n                    }\n                }\n            }\n            count++;\n        }\n    ```\n    \n2. stop double check uncessary condition\n    \n    ```java\n    \tprivate void bfs(char[][] grid, int i, int j) {\n            Queue<Point> q = new ArrayDeque();\n            \n            q.add(new Point(i, j)); // snapshot\n            while(!q.isEmpty()) {\n                Point p = q.poll();\n                \n    \t\t\t\t\t\t// uncessary condition\n                if(grid[p.x][p.y] == '1' && !visited[p.x][p.y]) {\n                    visited[p.x][p.y] = true;\n                }\n                \n                for(int x = 0; x < 4; x++) {\n                    int nx = p.x + dx[x];\n                    int ny = p.y + dy[x];\n                    \n                    if(nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length || visited[nx][ny]) continue;\n                    \n    \t\t\t\t\t\t\t\t// instead enable to check all at once\n                    if(grid[nx][ny] == '1') {\n                        q.add(new Point(nx, ny)); // snapshot\n                    }\n                }\n            }\n            count++;\n        }\n    ```\n    \n3. If we use the queue for bfs, it can cause memory limit when the size of queue become too large. so we need proper filter.\n    \n    ```java\n    private void bfs(char[][] grid, int i, int j) {\n        while(!q.isEmpty()) {\n            Point p = q.poll();\n            \n            for(int z = 0; z < 4; z++) {\n                int nx = p.x + dx[z];\n                int ny = p.y + dy[z];\n                \n                if(nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length || grid[nx][ny] == '0') continue; // filter\n                \n                q.add(new Point(nx, ny));\n                grid[nx][ny] = '0';\n            }\n        }\n        count++;\n    }\n    ```\n    \n4. If we can replace value with other value, we don’t need to consume the space boolean[][] visited \n    \n    ```java\n    visited[nx][ny] = true // before\n    grid[nx][ny] = '0'; // after\n    ```\n    \n5. dfs in metrix can be simple!\n    \n    ```java\n    private void dfs(char[][] grid, int i, int j) {\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == '0') return;\n        grid[i][j] = '0';\n        dfs(grid, i-1, j);\n        dfs(grid, i, j-1);\n        dfs(grid, i+1, j);\n        dfs(grid, i, j+1);\n    }\n    ```rid.length || j >= grid[0].length || grid[i][j] == '0') return;\n      grid[i][j] = '0';\n      dfs(grid, i-1, j);\n      dfs(grid, i, j-1);\n      dfs(grid, i+1, j);\n      dfs(grid, i, j+1);\n  }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a44a90b-42df-4611-bf56-884c4090b7a2/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. save the snapshot at each element\n    \n    ```java\n    \tprivate void bfs(char[][] grid, int i, int j) {\n            Queue<Point> q = new ArrayDeque();\n            \n            q.add(new Point(i, j)); // snapshot\n            while(!q.isEmpty()) {\n                Point p = q.poll();\n                \n                if(grid[p.x][p.y] == '1' && !visited[p.x][p.y]) {\n                    visited[p.x][p.y] = true;\n 0 || \n","source":"_posts/200-Number-of-Islands.md","raw":"---\ntitle: \"200.\\_Number of Islands\"\ncatalog: true\ndate: 2022-09-21 20:39:28\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- m == grid.length\n- n == grid[i].length\n- island is surrounded by water\n- is formed by connecting adjacent lands horizontally or vertically\n\n## Solve by hands first\n\n---\n\nwe can start with bfs algorithm. since we have to check the adjacent cells at a time. if every cells is within boundary and there is no other land left in horizon and vertical direction. Count the number of island. Time complexity will be O(m*n)\n\n**we also can use dfs algorithm!**\n\n## Solution\n\n---\n\n### bfs\n\n```java\nclass Solution {\n    \n    Queue<Point> q = new LinkedList();\n    \n    int count = 0;\n\n    int[] dx = new int[]{1,-1,0,0};\n    int[] dy = new int[]{0,0,1,-1};\n    \n    class Point {\n        \n        int x;\n        int y;\n        \n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public int numIslands(char[][] grid) {\n                \n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == '1') {\n                    q.add(new Point(i, j));\n                    bfs(grid, i, j);\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    private void bfs(char[][] grid, int i, int j) {\n        while(!q.isEmpty()) {\n            Point p = q.poll();\n            \n            for(int z = 0; z < 4; z++) {\n                int nx = p.x + dx[z];\n                int ny = p.y + dy[z];\n                \n                if(nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length || grid[nx][ny] == '0') continue;\n                \n                q.add(new Point(nx, ny));\n                grid[nx][ny] = '0';\n            }\n        }\n        count++;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7dd86d16-519e-4e61-875a-4ab995711e17/Untitled.png)\n\n### bfs\n\n```java\nclass Solution {\n    \n  public int numIslands(char[][] grid) {\n      int count = 0;\n      for(int i = 0; i < grid.length; i++) {\n          for(int j = 0; j < grid[0].length; j++) {\n              if(grid[i][j] == '1') {\n                  dfs(grid, i, j);\n                  count++;\n              }\n          }\n      }\n      return count;\n  }\n  \n  private void dfs(char[][] grid, int i, int j) {\n      if(i < 0 || j <i >= g                }\n                \n                for(int x = 0; x < 4; x++) {\n                    int nx = p.x + dx[x];\n                    int ny = p.y + dy[x];\n                    \n                    if(nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length || visited[nx][ny]) continue;\n                    \n                    if(grid[nx][ny] == '1') {\n                        q.add(new Point(nx, ny)); // snapshot\n                    }\n                }\n            }\n            count++;\n        }\n    ```\n    \n2. stop double check uncessary condition\n    \n    ```java\n    \tprivate void bfs(char[][] grid, int i, int j) {\n            Queue<Point> q = new ArrayDeque();\n            \n            q.add(new Point(i, j)); // snapshot\n            while(!q.isEmpty()) {\n                Point p = q.poll();\n                \n    \t\t\t\t\t\t// uncessary condition\n                if(grid[p.x][p.y] == '1' && !visited[p.x][p.y]) {\n                    visited[p.x][p.y] = true;\n                }\n                \n                for(int x = 0; x < 4; x++) {\n                    int nx = p.x + dx[x];\n                    int ny = p.y + dy[x];\n                    \n                    if(nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length || visited[nx][ny]) continue;\n                    \n    \t\t\t\t\t\t\t\t// instead enable to check all at once\n                    if(grid[nx][ny] == '1') {\n                        q.add(new Point(nx, ny)); // snapshot\n                    }\n                }\n            }\n            count++;\n        }\n    ```\n    \n3. If we use the queue for bfs, it can cause memory limit when the size of queue become too large. so we need proper filter.\n    \n    ```java\n    private void bfs(char[][] grid, int i, int j) {\n        while(!q.isEmpty()) {\n            Point p = q.poll();\n            \n            for(int z = 0; z < 4; z++) {\n                int nx = p.x + dx[z];\n                int ny = p.y + dy[z];\n                \n                if(nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length || grid[nx][ny] == '0') continue; // filter\n                \n                q.add(new Point(nx, ny));\n                grid[nx][ny] = '0';\n            }\n        }\n        count++;\n    }\n    ```\n    \n4. If we can replace value with other value, we don’t need to consume the space boolean[][] visited \n    \n    ```java\n    visited[nx][ny] = true // before\n    grid[nx][ny] = '0'; // after\n    ```\n    \n5. dfs in metrix can be simple!\n    \n    ```java\n    private void dfs(char[][] grid, int i, int j) {\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == '0') return;\n        grid[i][j] = '0';\n        dfs(grid, i-1, j);\n        dfs(grid, i, j-1);\n        dfs(grid, i+1, j);\n        dfs(grid, i, j+1);\n    }\n    ```rid.length || j >= grid[0].length || grid[i][j] == '0') return;\n      grid[i][j] = '0';\n      dfs(grid, i-1, j);\n      dfs(grid, i, j-1);\n      dfs(grid, i+1, j);\n      dfs(grid, i, j+1);\n  }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a44a90b-42df-4611-bf56-884c4090b7a2/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. save the snapshot at each element\n    \n    ```java\n    \tprivate void bfs(char[][] grid, int i, int j) {\n            Queue<Point> q = new ArrayDeque();\n            \n            q.add(new Point(i, j)); // snapshot\n            while(!q.isEmpty()) {\n                Point p = q.poll();\n                \n                if(grid[p.x][p.y] == '1' && !visited[p.x][p.y]) {\n                    visited[p.x][p.y] = true;\n 0 || \n","slug":"200-Number-of-Islands","published":1,"updated":"2022-09-21T11:39:54.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc18000tqkccp7wphcx3","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>m == grid.length</li>\n<li>n == grid[i].length</li>\n<li>island is surrounded by water</li>\n<li>is formed by connecting adjacent lands horizontally or vertically</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can start with bfs algorithm. since we have to check the adjacent cells at a time. if every cells is within boundary and there is no other land left in horizon and vertical direction. Count the number of island. Time complexity will be O(m*n)</p>\n<p><strong>we also can use dfs algorithm!</strong></p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<h3><span id=\"bfs\">bfs</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Queue&lt;Point&gt; q = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>,-<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,-<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numIslands</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; grid[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(grid[i][j] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">                    q.add(<span class=\"keyword\">new</span> Point(i, j));</span><br><span class=\"line\">                    bfs(grid, i, j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">            Point p = q.poll();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">4</span>; z++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nx = p.x + dx[z];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ny = p.y + dy[z];</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= grid.length || ny &gt;= grid[<span class=\"number\">0</span>].length || grid[nx][ny] == <span class=\"string\">'0'</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">                q.add(<span class=\"keyword\">new</span> Point(nx, ny));</span><br><span class=\"line\">                grid[nx][ny] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7dd86d16-519e-4e61-875a-4ab995711e17/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"bfs\">bfs</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numIslands</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; grid[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(grid[i][j] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">                  dfs(grid, i, j);</span><br><span class=\"line\">                  count++;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || j &lt;i &gt;= g                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt; <span class=\"number\">4</span>; x++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> nx = p.x + dx[x];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> ny = p.y + dy[x];</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= grid.length || ny &gt;= grid[<span class=\"number\">0</span>].length || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(grid[nx][ny] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">                        q.add(<span class=\"keyword\">new</span> Point(nx, ny)); <span class=\"comment\">// snapshot</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<p>stop double check uncessary condition</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">       Queue&lt;Point&gt; q = <span class=\"keyword\">new</span> ArrayDeque();</span><br><span class=\"line\">       </span><br><span class=\"line\">       q.add(<span class=\"keyword\">new</span> Point(i, j)); <span class=\"comment\">// snapshot</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">           Point p = q.poll();</span><br><span class=\"line\">           </span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// uncessary condition</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(grid[p.x][p.y] == <span class=\"string\">'1'</span> &amp;&amp; !visited[p.x][p.y]) &#123;</span><br><span class=\"line\">               visited[p.x][p.y] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           </span><br><span class=\"line\">           <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt; <span class=\"number\">4</span>; x++) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> nx = p.x + dx[x];</span><br><span class=\"line\">               <span class=\"keyword\">int</span> ny = p.y + dy[x];</span><br><span class=\"line\">               </span><br><span class=\"line\">               <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= grid.length || ny &gt;= grid[<span class=\"number\">0</span>].length || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">               </span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">// instead enable to check all at once</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span>(grid[nx][ny] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">                   q.add(<span class=\"keyword\">new</span> Point(nx, ny)); <span class=\"comment\">// snapshot</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       count++;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>If we use the queue for bfs, it can cause memory limit when the size of queue become too large. so we need proper filter.</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">        Point p = q.poll();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">4</span>; z++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nx = p.x + dx[z];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ny = p.y + dy[z];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= grid.length || ny &gt;= grid[<span class=\"number\">0</span>].length || grid[nx][ny] == <span class=\"string\">'0'</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">// filter</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            q.add(<span class=\"keyword\">new</span> Point(nx, ny));</span><br><span class=\"line\">            grid[nx][ny] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p>If we can replace value with other value, we don’t need to consume the space boolean[][] visited</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visited[nx][ny] = <span class=\"keyword\">true</span> <span class=\"comment\">// before</span></span><br><span class=\"line\">grid[nx][ny] = <span class=\"string\">'0'</span>; <span class=\"comment\">// after</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"5\">\n<li>\n<p>dfs in metrix can be simple!</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || j &lt; <span class=\"number\">0</span> || i &gt;= grid.length || j &gt;= grid[<span class=\"number\">0</span>].length || grid[i][j] == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        grid[i][j] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        dfs(grid, i-<span class=\"number\">1</span>, j);</span><br><span class=\"line\">        dfs(grid, i, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">        dfs(grid, i+<span class=\"number\">1</span>, j);</span><br><span class=\"line\">        dfs(grid, i, j+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ```rid.length || j &gt;= grid[<span class=\"number\">0</span>].length || grid[i][j] == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      grid[i][j] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">      dfs(grid, i-<span class=\"number\">1</span>, j);</span><br><span class=\"line\">      dfs(grid, i, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">      dfs(grid, i+<span class=\"number\">1</span>, j);</span><br><span class=\"line\">      dfs(grid, i, j+<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a44a90b-42df-4611-bf56-884c4090b7a2/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>save the snapshot at each element</p>\n<pre><code class=\"language-java\">\tprivate void bfs(char[][] grid, int i, int j) {\n        Queue&lt;Point&gt; q = new ArrayDeque();\n        \n        q.add(new Point(i, j)); // snapshot\n        while(!q.isEmpty()) {\n            Point p = q.poll();\n            \n            if(grid[p.x][p.y] == '1' &amp;&amp; !visited[p.x][p.y]) {\n                visited[p.x][p.y] = true;\n</code></pre>\n</li>\n</ol>\n<p>0 ||</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>m == grid.length</li>\n<li>n == grid[i].length</li>\n<li>island is surrounded by water</li>\n<li>is formed by connecting adjacent lands horizontally or vertically</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can start with bfs algorithm. since we have to check the adjacent cells at a time. if every cells is within boundary and there is no other land left in horizon and vertical direction. Count the number of island. Time complexity will be O(m*n)</p>\n<p><strong>we also can use dfs algorithm!</strong></p>\n<h2>Solution</h2>\n<hr>\n<h3>bfs</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Queue&lt;Point&gt; q = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>,-<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,-<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numIslands</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; grid[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(grid[i][j] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">                    q.add(<span class=\"keyword\">new</span> Point(i, j));</span><br><span class=\"line\">                    bfs(grid, i, j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">            Point p = q.poll();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">4</span>; z++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nx = p.x + dx[z];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ny = p.y + dy[z];</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= grid.length || ny &gt;= grid[<span class=\"number\">0</span>].length || grid[nx][ny] == <span class=\"string\">'0'</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">                q.add(<span class=\"keyword\">new</span> Point(nx, ny));</span><br><span class=\"line\">                grid[nx][ny] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7dd86d16-519e-4e61-875a-4ab995711e17/Untitled.png\" alt=\"Untitled\"></p>\n<h3>bfs</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numIslands</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; grid[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(grid[i][j] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">                  dfs(grid, i, j);</span><br><span class=\"line\">                  count++;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || j &lt;i &gt;= g                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt; <span class=\"number\">4</span>; x++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> nx = p.x + dx[x];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> ny = p.y + dy[x];</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= grid.length || ny &gt;= grid[<span class=\"number\">0</span>].length || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(grid[nx][ny] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">                        q.add(<span class=\"keyword\">new</span> Point(nx, ny)); <span class=\"comment\">// snapshot</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<p>stop double check uncessary condition</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">       Queue&lt;Point&gt; q = <span class=\"keyword\">new</span> ArrayDeque();</span><br><span class=\"line\">       </span><br><span class=\"line\">       q.add(<span class=\"keyword\">new</span> Point(i, j)); <span class=\"comment\">// snapshot</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">           Point p = q.poll();</span><br><span class=\"line\">           </span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// uncessary condition</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(grid[p.x][p.y] == <span class=\"string\">'1'</span> &amp;&amp; !visited[p.x][p.y]) &#123;</span><br><span class=\"line\">               visited[p.x][p.y] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           </span><br><span class=\"line\">           <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt; <span class=\"number\">4</span>; x++) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> nx = p.x + dx[x];</span><br><span class=\"line\">               <span class=\"keyword\">int</span> ny = p.y + dy[x];</span><br><span class=\"line\">               </span><br><span class=\"line\">               <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= grid.length || ny &gt;= grid[<span class=\"number\">0</span>].length || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">               </span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">// instead enable to check all at once</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span>(grid[nx][ny] == <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">                   q.add(<span class=\"keyword\">new</span> Point(nx, ny)); <span class=\"comment\">// snapshot</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       count++;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>If we use the queue for bfs, it can cause memory limit when the size of queue become too large. so we need proper filter.</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">        Point p = q.poll();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">4</span>; z++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nx = p.x + dx[z];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ny = p.y + dy[z];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= grid.length || ny &gt;= grid[<span class=\"number\">0</span>].length || grid[nx][ny] == <span class=\"string\">'0'</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">// filter</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            q.add(<span class=\"keyword\">new</span> Point(nx, ny));</span><br><span class=\"line\">            grid[nx][ny] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p>If we can replace value with other value, we don’t need to consume the space boolean[][] visited</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visited[nx][ny] = <span class=\"keyword\">true</span> <span class=\"comment\">// before</span></span><br><span class=\"line\">grid[nx][ny] = <span class=\"string\">'0'</span>; <span class=\"comment\">// after</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"5\">\n<li>\n<p>dfs in metrix can be simple!</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || j &lt; <span class=\"number\">0</span> || i &gt;= grid.length || j &gt;= grid[<span class=\"number\">0</span>].length || grid[i][j] == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        grid[i][j] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        dfs(grid, i-<span class=\"number\">1</span>, j);</span><br><span class=\"line\">        dfs(grid, i, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">        dfs(grid, i+<span class=\"number\">1</span>, j);</span><br><span class=\"line\">        dfs(grid, i, j+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ```rid.length || j &gt;= grid[<span class=\"number\">0</span>].length || grid[i][j] == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      grid[i][j] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">      dfs(grid, i-<span class=\"number\">1</span>, j);</span><br><span class=\"line\">      dfs(grid, i, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">      dfs(grid, i+<span class=\"number\">1</span>, j);</span><br><span class=\"line\">      dfs(grid, i, j+<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a44a90b-42df-4611-bf56-884c4090b7a2/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>save the snapshot at each element</p>\n<pre><code class=\"language-java\">\tprivate void bfs(char[][] grid, int i, int j) {\n        Queue&lt;Point&gt; q = new ArrayDeque();\n        \n        q.add(new Point(i, j)); // snapshot\n        while(!q.isEmpty()) {\n            Point p = q.poll();\n            \n            if(grid[p.x][p.y] == '1' &amp;&amp; !visited[p.x][p.y]) {\n                visited[p.x][p.y] = true;\n</code></pre>\n</li>\n</ol>\n<p>0 ||</p>\n"},{"title":"206. Reverse Linked List","catalog":true,"date":"2022-10-01T03:46:42.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- singly linked list\n- return *the reversed list*\n.\n\n## Solve by hands first\n\n---\n\nSimply store the node values in Stack and create the reversed linked list\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head == null) return null;\n        \n        Stack<Integer> s = new Stack();\n        while(head != null) {\n            s.push(head.val);\n            head = head.next;\n        }\n        \n        ListNode node = new ListNode(s.pop());\n        head = node;\n        while(!s.isEmpty()) {\n            ListNode cn = new ListNode(s.pop());\n            head.next = cn;\n            head = cn;\n        }\n        \n        return node;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b2415ecc-1eb0-4bd1-a52b-cf0dc92f4473/Untitled.png)\n\n## Lesson I learnt\n\n---\n","source":"_posts/206-Reverse-Linked-List.md","raw":"---\ntitle: \"206.\\_Reverse Linked List\"\ncatalog: true\ndate: 2022-10-01 12:46:42\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- singly linked list\n- return *the reversed list*\n.\n\n## Solve by hands first\n\n---\n\nSimply store the node values in Stack and create the reversed linked list\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head == null) return null;\n        \n        Stack<Integer> s = new Stack();\n        while(head != null) {\n            s.push(head.val);\n            head = head.next;\n        }\n        \n        ListNode node = new ListNode(s.pop());\n        head = node;\n        while(!s.isEmpty()) {\n            ListNode cn = new ListNode(s.pop());\n            head.next = cn;\n            head = cn;\n        }\n        \n        return node;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b2415ecc-1eb0-4bd1-a52b-cf0dc92f4473/Untitled.png)\n\n## Lesson I learnt\n\n---\n","slug":"206-Reverse-Linked-List","published":1,"updated":"2022-10-01T03:46:56.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc18000uqkccn23aywz5","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>singly linked list</li>\n<li>return <em>the reversed list</em><br>\n.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>Simply store the node values in Stack and create the reversed linked list</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Stack&lt;Integer&gt; s = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            s.push(head.val);</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode node = <span class=\"keyword\">new</span> ListNode(s.pop());</span><br><span class=\"line\">        head = node;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!s.isEmpty()) &#123;</span><br><span class=\"line\">            ListNode cn = <span class=\"keyword\">new</span> ListNode(s.pop());</span><br><span class=\"line\">            head.next = cn;</span><br><span class=\"line\">            head = cn;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b2415ecc-1eb0-4bd1-a52b-cf0dc92f4473/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>singly linked list</li>\n<li>return <em>the reversed list</em><br>\n.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>Simply store the node values in Stack and create the reversed linked list</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Stack&lt;Integer&gt; s = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            s.push(head.val);</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode node = <span class=\"keyword\">new</span> ListNode(s.pop());</span><br><span class=\"line\">        head = node;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!s.isEmpty()) &#123;</span><br><span class=\"line\">            ListNode cn = <span class=\"keyword\">new</span> ListNode(s.pop());</span><br><span class=\"line\">            head.next = cn;</span><br><span class=\"line\">            head = cn;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b2415ecc-1eb0-4bd1-a52b-cf0dc92f4473/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n"},{"title":"211. Design Add and Search Words Data Structure","catalog":true,"date":"2022-09-26T12:21:26.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- data structure adding new words\n- data structure finding if a string matches any previous added string\n\n## Solve by hands first\n\n---\n\nThis is typical Trie problem I would say. since we will keep adding up the string into Trie, we need to create the root Trie node as instance variable. we will keep tracking of base on root node. \n\nfor addWord method, create local variable with root node. add the each letters into Trie.\n\nfor search method, iterate throught each character in string. if the letter matches Trie then move the pointer to next Trie. \n\n## Solution\n\n---\n\n```java\nclass WordDictionary {\n    \n    Trie root = new Trie();\n    \n    class Trie {\n        Trie[] next = new Trie[26];\n        boolean isLast = false;   \n    }\n    \n    public void addWord(String word) {\n        Trie cur = root;\n        \n        for(char c : word.toCharArray()) {\n            if(cur.next[c - 'a'] == null) {\n                cur.next[c - 'a'] = new Trie();\n            }\n            cur = cur.next[c - 'a'];\n        }\n        cur.isLast = true;\n    }\n    \n    public boolean search(String word) {\n        return dfs(root, word, 0);\n    }\n    \n    private boolean dfs(Trie node, String word, int idx) {\n        if(word.length() == idx) return node.isLast;\n\n        char c = word.charAt(idx);\n        if(c == '.') {\n           for(Trie tc : node.next) {\n                if(tc != null && dfs(tc, word, idx + 1)) return true;\n            }\n        } else if(node.next[c - 'a'] != null){\n           return dfs(node.next[c - 'a'], word, idx + 1);\n        }\n        return false;\n    }\n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3480f671-625a-4b8c-a932-e225085ee284/Untitled.png)\n\nthere are two conditions\n\n1. If Trie has the letter, move on to next Trie node at character and next charatecr\n2. if the letter is `.` , it can match any characters in Trie but when it’s not null. but it can only be true when it matches the word.\n\n**then what is the valid last node?** \n\nwhen we reaches to the length of word and its index is equals to that length, If Trie is the complete word. then it is the word that we search for. \n\n**question is why the current index is equals to length of word not length - 1?** \n\nbecause last Trie node always has the empty array and marker of last node which in this case isLast = true\n\n## Lesson I learnt\n\n---\n\n1. when creating Trie, don’t forget to check null at each letter\n2. last node of Trie has alway with **empty array** and **isLast = true**\n    \n    ```java\n     [b,   d,   m]   0\n     /     |     \\\n    [a]   [a]   [a]  1\n     |     |     |\n    [d]   [d]   [d]  2\n     |     |     |\n    [ ]   [ ]   [ ]  3\n    true  true  true\n    ```\n    \n3. DFS structure in Tree\n    \n    ```java\n    private void dfs() {\n    \t// 1. return at the end of node\n    \n    \t// 2. conditions to the next node\n    \n    \t// 3. (optional) backtracking if you need\n    }\n    ```\n","source":"_posts/211-Design-Add-and-Search-Words-Data-Structure.md","raw":"---\ntitle: \"211.\\_Design Add and Search Words Data Structure\"\ncatalog: true\ndate: 2022-09-26 21:21:26\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- data structure adding new words\n- data structure finding if a string matches any previous added string\n\n## Solve by hands first\n\n---\n\nThis is typical Trie problem I would say. since we will keep adding up the string into Trie, we need to create the root Trie node as instance variable. we will keep tracking of base on root node. \n\nfor addWord method, create local variable with root node. add the each letters into Trie.\n\nfor search method, iterate throught each character in string. if the letter matches Trie then move the pointer to next Trie. \n\n## Solution\n\n---\n\n```java\nclass WordDictionary {\n    \n    Trie root = new Trie();\n    \n    class Trie {\n        Trie[] next = new Trie[26];\n        boolean isLast = false;   \n    }\n    \n    public void addWord(String word) {\n        Trie cur = root;\n        \n        for(char c : word.toCharArray()) {\n            if(cur.next[c - 'a'] == null) {\n                cur.next[c - 'a'] = new Trie();\n            }\n            cur = cur.next[c - 'a'];\n        }\n        cur.isLast = true;\n    }\n    \n    public boolean search(String word) {\n        return dfs(root, word, 0);\n    }\n    \n    private boolean dfs(Trie node, String word, int idx) {\n        if(word.length() == idx) return node.isLast;\n\n        char c = word.charAt(idx);\n        if(c == '.') {\n           for(Trie tc : node.next) {\n                if(tc != null && dfs(tc, word, idx + 1)) return true;\n            }\n        } else if(node.next[c - 'a'] != null){\n           return dfs(node.next[c - 'a'], word, idx + 1);\n        }\n        return false;\n    }\n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3480f671-625a-4b8c-a932-e225085ee284/Untitled.png)\n\nthere are two conditions\n\n1. If Trie has the letter, move on to next Trie node at character and next charatecr\n2. if the letter is `.` , it can match any characters in Trie but when it’s not null. but it can only be true when it matches the word.\n\n**then what is the valid last node?** \n\nwhen we reaches to the length of word and its index is equals to that length, If Trie is the complete word. then it is the word that we search for. \n\n**question is why the current index is equals to length of word not length - 1?** \n\nbecause last Trie node always has the empty array and marker of last node which in this case isLast = true\n\n## Lesson I learnt\n\n---\n\n1. when creating Trie, don’t forget to check null at each letter\n2. last node of Trie has alway with **empty array** and **isLast = true**\n    \n    ```java\n     [b,   d,   m]   0\n     /     |     \\\n    [a]   [a]   [a]  1\n     |     |     |\n    [d]   [d]   [d]  2\n     |     |     |\n    [ ]   [ ]   [ ]  3\n    true  true  true\n    ```\n    \n3. DFS structure in Tree\n    \n    ```java\n    private void dfs() {\n    \t// 1. return at the end of node\n    \n    \t// 2. conditions to the next node\n    \n    \t// 3. (optional) backtracking if you need\n    }\n    ```\n","slug":"211-Design-Add-and-Search-Words-Data-Structure","published":1,"updated":"2022-09-26T12:24:03.558Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc18000vqkcc7j71x9rp","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>data structure adding new words</li>\n<li>data structure finding if a string matches any previous added string</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>This is typical Trie problem I would say. since we will keep adding up the string into Trie, we need to create the root Trie node as instance variable. we will keep tracking of base on root node.</p>\n<p>for addWord method, create local variable with root node. add the each letters into Trie.</p>\n<p>for search method, iterate throught each character in string. if the letter matches Trie then move the pointer to next Trie.</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordDictionary</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Trie root = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">        Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isLast = <span class=\"keyword\">false</span>;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addWord</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">        Trie cur = root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : word.toCharArray()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur.next[c - <span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                cur.next[c - <span class=\"string\">'a'</span>] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next[c - <span class=\"string\">'a'</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.isLast = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">search</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(root, word, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(Trie node, String word, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(word.length() == idx) <span class=\"keyword\">return</span> node.isLast;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = word.charAt(idx);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c == <span class=\"string\">'.'</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(Trie tc : node.next) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tc != <span class=\"keyword\">null</span> &amp;&amp; dfs(tc, word, idx + <span class=\"number\">1</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(node.next[c - <span class=\"string\">'a'</span>] != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> dfs(node.next[c - <span class=\"string\">'a'</span>], word, idx + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * WordDictionary obj = new WordDictionary();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.addWord(word);</span></span><br><span class=\"line\"><span class=\"comment\"> * boolean param_2 = obj.search(word);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3480f671-625a-4b8c-a932-e225085ee284/Untitled.png\" alt=\"Untitled\"></p>\n<p>there are two conditions</p>\n<ol>\n<li>If Trie has the letter, move on to next Trie node at character and next charatecr</li>\n<li>if the letter is <code>.</code> , it can match any characters in Trie but when it’s not null. but it can only be true when it matches the word.</li>\n</ol>\n<p><strong>then what is the valid last node?</strong></p>\n<p>when we reaches to the length of word and its index is equals to that length, If Trie is the complete word. then it is the word that we search for.</p>\n<p><strong>question is why the current index is equals to length of word not length - 1?</strong></p>\n<p>because last Trie node always has the empty array and marker of last node which in this case isLast = true</p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>when creating Trie, don’t forget to check null at each letter</p>\n</li>\n<li>\n<p>last node of Trie has alway with <strong>empty array</strong> and <strong>isLast = true</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> [b,   d,   m]   <span class=\"number\">0</span></span><br><span class=\"line\"> /     |     \\</span><br><span class=\"line\">[a]   [a]   [a]  <span class=\"number\">1</span></span><br><span class=\"line\"> |     |     |</span><br><span class=\"line\">[d]   [d]   [d]  <span class=\"number\">2</span></span><br><span class=\"line\"> |     |     |</span><br><span class=\"line\">[ ]   [ ]   [ ]  <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">true</span>  <span class=\"keyword\">true</span>  <span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>DFS structure in Tree</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 1. return at the end of node</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 2. conditions to the next node</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 3. (optional) backtracking if you need</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>data structure adding new words</li>\n<li>data structure finding if a string matches any previous added string</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>This is typical Trie problem I would say. since we will keep adding up the string into Trie, we need to create the root Trie node as instance variable. we will keep tracking of base on root node.</p>\n<p>for addWord method, create local variable with root node. add the each letters into Trie.</p>\n<p>for search method, iterate throught each character in string. if the letter matches Trie then move the pointer to next Trie.</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordDictionary</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Trie root = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">        Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isLast = <span class=\"keyword\">false</span>;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addWord</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">        Trie cur = root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : word.toCharArray()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur.next[c - <span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                cur.next[c - <span class=\"string\">'a'</span>] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next[c - <span class=\"string\">'a'</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.isLast = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">search</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(root, word, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(Trie node, String word, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(word.length() == idx) <span class=\"keyword\">return</span> node.isLast;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = word.charAt(idx);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c == <span class=\"string\">'.'</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(Trie tc : node.next) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tc != <span class=\"keyword\">null</span> &amp;&amp; dfs(tc, word, idx + <span class=\"number\">1</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(node.next[c - <span class=\"string\">'a'</span>] != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> dfs(node.next[c - <span class=\"string\">'a'</span>], word, idx + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * WordDictionary obj = new WordDictionary();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.addWord(word);</span></span><br><span class=\"line\"><span class=\"comment\"> * boolean param_2 = obj.search(word);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3480f671-625a-4b8c-a932-e225085ee284/Untitled.png\" alt=\"Untitled\"></p>\n<p>there are two conditions</p>\n<ol>\n<li>If Trie has the letter, move on to next Trie node at character and next charatecr</li>\n<li>if the letter is <code>.</code> , it can match any characters in Trie but when it’s not null. but it can only be true when it matches the word.</li>\n</ol>\n<p><strong>then what is the valid last node?</strong></p>\n<p>when we reaches to the length of word and its index is equals to that length, If Trie is the complete word. then it is the word that we search for.</p>\n<p><strong>question is why the current index is equals to length of word not length - 1?</strong></p>\n<p>because last Trie node always has the empty array and marker of last node which in this case isLast = true</p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>when creating Trie, don’t forget to check null at each letter</p>\n</li>\n<li>\n<p>last node of Trie has alway with <strong>empty array</strong> and <strong>isLast = true</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> [b,   d,   m]   <span class=\"number\">0</span></span><br><span class=\"line\"> /     |     \\</span><br><span class=\"line\">[a]   [a]   [a]  <span class=\"number\">1</span></span><br><span class=\"line\"> |     |     |</span><br><span class=\"line\">[d]   [d]   [d]  <span class=\"number\">2</span></span><br><span class=\"line\"> |     |     |</span><br><span class=\"line\">[ ]   [ ]   [ ]  <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">true</span>  <span class=\"keyword\">true</span>  <span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>DFS structure in Tree</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 1. return at the end of node</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 2. conditions to the next node</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 3. (optional) backtracking if you need</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"207. Course Schedule","catalog":true,"date":"2022-09-25T06:43:46.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- Return `true` if you can finish all courses. Otherwise, return `false`\n- All the pairs prerequisites[i] are **unique**.\n\n## Solve by hands first\n\n---\n\nwe should check the prerequisites are in the course first. if it’s existed, then we can take a course. false case is when it has cycle in between prerequisities course and the course wants to take. if there is cycle then return false otherwise return true. **how do I express the cycle with algorithm**? Graph! we can use DFS algorithm to search the Graph\n\nProblem is how we can detect the cycle in graph? \n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    Map<Integer, List<Integer>> m;\n    Set<Integer> visited;\n    \n    public boolean canFinish(int nc, int[][] prerequisites) {\n        \n        m = new HashMap();\n        visited = new HashSet();\n        \n        for(int i = 0; i < nc; i++) {\n            m.put(i, new ArrayList());\n        }\n        \n        for(int[] pre : prerequisites) {\n            List<Integer> l = m.get(pre[0]);\n            l.add(pre[1]);\n            m.put(pre[0], l);\n        }\n        \n        for(int i = 0; i < nc; i++) {\n            if(!dfs(i)) return false;\n        }\n        \n        return true;\n    }\n    \n    private boolean dfs(int k) {\n        if(visited.contains(k)) return false;\n        if(m.get(k) == null || m.get(k).isEmpty()) return true;\n        \n        visited.add(k);\n        for(int l : m.get(k)) {\n            if(!dfs(l)) return false;\n        }\n        visited.remove(k);\n        m.put(k, new ArrayList());\n        return true;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8da69891-2aca-4e68-b46b-2410a32d5406/Untitled.png)\n\n1. **Problem was how to detect loop in graph**. \n    - solution is **Set**\n    - every iteration**, insert the current node into Set and after checking all of the children node then remove the current node from Set**.\n    - **when revisit the node, if it’s in the Set which mean it’s cycle**\n2. **Another problem is how to check if the node has no cycle**\n    - we can remove the childrent nodes after visiting all the childrent nodes\n    - **if there is emtpy child node which mean the node won’t be able to make loop in Graph**\n\n![31F9E96C-D597-4B0D-9EB7-2B3BF30995AF.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7558abdc-3248-4299-8f5d-79b10bf67f2a/31F9E96C-D597-4B0D-9EB7-2B3BF30995AF.jpeg)\n\n![9679588C-CCBB-46E0-AC71-92CB4B3F1E90.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c4d854ce-457f-4842-87a6-5bebfcb0c136/9679588C-CCBB-46E0-AC71-92CB4B3F1E90.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. BFS, DFS (Backtracking)  is the way of searching in Tree, Graph\n2. Graph or Tree can be Map with node as key and list of child nodes as value! it doesn’t actually need to be \n3. to detect the loop in graph, we can use **Set.**\n    - **add the node in Set** when entry the node\n    - **remove the node in Set** after visiting childrent nodes\n","source":"_posts/207-Course-Schedule.md","raw":"---\ntitle: \"207.\\_Course Schedule\"\ncatalog: true\ndate: 2022-09-25 15:43:46\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- Return `true` if you can finish all courses. Otherwise, return `false`\n- All the pairs prerequisites[i] are **unique**.\n\n## Solve by hands first\n\n---\n\nwe should check the prerequisites are in the course first. if it’s existed, then we can take a course. false case is when it has cycle in between prerequisities course and the course wants to take. if there is cycle then return false otherwise return true. **how do I express the cycle with algorithm**? Graph! we can use DFS algorithm to search the Graph\n\nProblem is how we can detect the cycle in graph? \n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    Map<Integer, List<Integer>> m;\n    Set<Integer> visited;\n    \n    public boolean canFinish(int nc, int[][] prerequisites) {\n        \n        m = new HashMap();\n        visited = new HashSet();\n        \n        for(int i = 0; i < nc; i++) {\n            m.put(i, new ArrayList());\n        }\n        \n        for(int[] pre : prerequisites) {\n            List<Integer> l = m.get(pre[0]);\n            l.add(pre[1]);\n            m.put(pre[0], l);\n        }\n        \n        for(int i = 0; i < nc; i++) {\n            if(!dfs(i)) return false;\n        }\n        \n        return true;\n    }\n    \n    private boolean dfs(int k) {\n        if(visited.contains(k)) return false;\n        if(m.get(k) == null || m.get(k).isEmpty()) return true;\n        \n        visited.add(k);\n        for(int l : m.get(k)) {\n            if(!dfs(l)) return false;\n        }\n        visited.remove(k);\n        m.put(k, new ArrayList());\n        return true;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8da69891-2aca-4e68-b46b-2410a32d5406/Untitled.png)\n\n1. **Problem was how to detect loop in graph**. \n    - solution is **Set**\n    - every iteration**, insert the current node into Set and after checking all of the children node then remove the current node from Set**.\n    - **when revisit the node, if it’s in the Set which mean it’s cycle**\n2. **Another problem is how to check if the node has no cycle**\n    - we can remove the childrent nodes after visiting all the childrent nodes\n    - **if there is emtpy child node which mean the node won’t be able to make loop in Graph**\n\n![31F9E96C-D597-4B0D-9EB7-2B3BF30995AF.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7558abdc-3248-4299-8f5d-79b10bf67f2a/31F9E96C-D597-4B0D-9EB7-2B3BF30995AF.jpeg)\n\n![9679588C-CCBB-46E0-AC71-92CB4B3F1E90.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c4d854ce-457f-4842-87a6-5bebfcb0c136/9679588C-CCBB-46E0-AC71-92CB4B3F1E90.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. BFS, DFS (Backtracking)  is the way of searching in Tree, Graph\n2. Graph or Tree can be Map with node as key and list of child nodes as value! it doesn’t actually need to be \n3. to detect the loop in graph, we can use **Set.**\n    - **add the node in Set** when entry the node\n    - **remove the node in Set** after visiting childrent nodes\n","slug":"207-Course-Schedule","published":1,"updated":"2022-09-25T06:44:08.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc19000wqkccrznlj85d","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code></li>\n<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we should check the prerequisites are in the course first. if it’s existed, then we can take a course. false case is when it has cycle in between prerequisities course and the course wants to take. if there is cycle then return false otherwise return true. <strong>how do I express the cycle with algorithm</strong>? Graph! we can use DFS algorithm to search the Graph</p>\n<p>Problem is how we can detect the cycle in graph?</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Map&lt;Integer, List&lt;Integer&gt;&gt; m;</span><br><span class=\"line\">    Set&lt;Integer&gt; visited;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canFinish</span><span class=\"params\">(<span class=\"keyword\">int</span> nc, <span class=\"keyword\">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nc; i++) &#123;</span><br><span class=\"line\">            m.put(i, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>[] pre : prerequisites) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; l = m.get(pre[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            l.add(pre[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            m.put(pre[<span class=\"number\">0</span>], l);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nc; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!dfs(i)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(visited.contains(k)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m.get(k) == <span class=\"keyword\">null</span> || m.get(k).isEmpty()) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        visited.add(k);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l : m.get(k)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!dfs(l)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visited.remove(k);</span><br><span class=\"line\">        m.put(k, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8da69891-2aca-4e68-b46b-2410a32d5406/Untitled.png\" alt=\"Untitled\"></p>\n<ol>\n<li><strong>Problem was how to detect loop in graph</strong>.\n<ul>\n<li>solution is <strong>Set</strong></li>\n<li>every iteration**, insert the current node into Set and after checking all of the children node then remove the current node from Set**.</li>\n<li><strong>when revisit the node, if it’s in the Set which mean it’s cycle</strong></li>\n</ul>\n</li>\n<li><strong>Another problem is how to check if the node has no cycle</strong>\n<ul>\n<li>we can remove the childrent nodes after visiting all the childrent nodes</li>\n<li><strong>if there is emtpy child node which mean the node won’t be able to make loop in Graph</strong></li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7558abdc-3248-4299-8f5d-79b10bf67f2a/31F9E96C-D597-4B0D-9EB7-2B3BF30995AF.jpeg\" alt=\"31F9E96C-D597-4B0D-9EB7-2B3BF30995AF.jpeg\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c4d854ce-457f-4842-87a6-5bebfcb0c136/9679588C-CCBB-46E0-AC71-92CB4B3F1E90.jpeg\" alt=\"9679588C-CCBB-46E0-AC71-92CB4B3F1E90.jpeg\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>BFS, DFS (Backtracking)  is the way of searching in Tree, Graph</li>\n<li>Graph or Tree can be Map with node as key and list of child nodes as value! it doesn’t actually need to be</li>\n<li>to detect the loop in graph, we can use <strong>Set.</strong>\n<ul>\n<li><strong>add the node in Set</strong> when entry the node</li>\n<li><strong>remove the node in Set</strong> after visiting childrent nodes</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code></li>\n<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we should check the prerequisites are in the course first. if it’s existed, then we can take a course. false case is when it has cycle in between prerequisities course and the course wants to take. if there is cycle then return false otherwise return true. <strong>how do I express the cycle with algorithm</strong>? Graph! we can use DFS algorithm to search the Graph</p>\n<p>Problem is how we can detect the cycle in graph?</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Map&lt;Integer, List&lt;Integer&gt;&gt; m;</span><br><span class=\"line\">    Set&lt;Integer&gt; visited;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canFinish</span><span class=\"params\">(<span class=\"keyword\">int</span> nc, <span class=\"keyword\">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nc; i++) &#123;</span><br><span class=\"line\">            m.put(i, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>[] pre : prerequisites) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; l = m.get(pre[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            l.add(pre[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            m.put(pre[<span class=\"number\">0</span>], l);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nc; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!dfs(i)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(visited.contains(k)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m.get(k) == <span class=\"keyword\">null</span> || m.get(k).isEmpty()) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        visited.add(k);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l : m.get(k)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!dfs(l)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visited.remove(k);</span><br><span class=\"line\">        m.put(k, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8da69891-2aca-4e68-b46b-2410a32d5406/Untitled.png\" alt=\"Untitled\"></p>\n<ol>\n<li><strong>Problem was how to detect loop in graph</strong>.\n<ul>\n<li>solution is <strong>Set</strong></li>\n<li>every iteration**, insert the current node into Set and after checking all of the children node then remove the current node from Set**.</li>\n<li><strong>when revisit the node, if it’s in the Set which mean it’s cycle</strong></li>\n</ul>\n</li>\n<li><strong>Another problem is how to check if the node has no cycle</strong>\n<ul>\n<li>we can remove the childrent nodes after visiting all the childrent nodes</li>\n<li><strong>if there is emtpy child node which mean the node won’t be able to make loop in Graph</strong></li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7558abdc-3248-4299-8f5d-79b10bf67f2a/31F9E96C-D597-4B0D-9EB7-2B3BF30995AF.jpeg\" alt=\"31F9E96C-D597-4B0D-9EB7-2B3BF30995AF.jpeg\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c4d854ce-457f-4842-87a6-5bebfcb0c136/9679588C-CCBB-46E0-AC71-92CB4B3F1E90.jpeg\" alt=\"9679588C-CCBB-46E0-AC71-92CB4B3F1E90.jpeg\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>BFS, DFS (Backtracking)  is the way of searching in Tree, Graph</li>\n<li>Graph or Tree can be Map with node as key and list of child nodes as value! it doesn’t actually need to be</li>\n<li>to detect the loop in graph, we can use <strong>Set.</strong>\n<ul>\n<li><strong>add the node in Set</strong> when entry the node</li>\n<li><strong>remove the node in Set</strong> after visiting childrent nodes</li>\n</ul>\n</li>\n</ol>\n"},{"title":"208. Implement Trie (Prefix Tree)","catalog":true,"date":"2022-10-02T05:00:48.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- `word` and `prefix` consist only of lowercase English letters.\n\n## Solve by hands first\n\n---\n\nThis is basic Trie data structure\n\n## Solution\n\n---\n\n```java\nclass Trie {\n    \n    Trie[] next;\n    boolean end;\n\n    public Trie() {\n        this.next = new Trie[26];\n        this.end = false;\n    }\n    \n    public void insert(String word) {\n        Trie trie = this;\n        for(int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            if(trie.next[c - 'a'] == null) trie.next[c - 'a'] = new Trie();\n            trie = trie.next[c - 'a'];\n        }\n        trie.end = true;\n    }\n    \n    public boolean search(String word) {\n        Trie trie = this;\n        for(int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            \n            if(trie.next[c - 'a'] == null) return false; // letter is not stored\n\n            trie = trie.next[c - 'a'];    \n        }\n        return trie.end;\n    }\n    \n    public boolean startsWith(String prefix) {\n        Trie trie = this;\n        for(int i = 0; i < prefix.length(); i++) {\n            char c = prefix.charAt(i);\n            \n            if(trie.next[c - 'a'] == null) return false;  // letter is not stored\n            \n            trie = trie.next[c - 'a'];    \n        }\n        return true;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5a1556a0-38ec-44c0-8c91-7b5cd2aa8239/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n- Trie is prefix tree\n- Trie is for autocomplete and spellchecker\n- we can only check if the letter is in Trie or not\n    \n    ```java\n    if(trie.next[c - 'a'] == null) return false; // letter is not stored\n    ```\n","source":"_posts/208-Implement-Trie-Prefix-Tree.md","raw":"---\ntitle: \"208.\\_Implement Trie (Prefix Tree)\"\ncatalog: true\ndate: 2022-10-02 14:00:48\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- `word` and `prefix` consist only of lowercase English letters.\n\n## Solve by hands first\n\n---\n\nThis is basic Trie data structure\n\n## Solution\n\n---\n\n```java\nclass Trie {\n    \n    Trie[] next;\n    boolean end;\n\n    public Trie() {\n        this.next = new Trie[26];\n        this.end = false;\n    }\n    \n    public void insert(String word) {\n        Trie trie = this;\n        for(int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            if(trie.next[c - 'a'] == null) trie.next[c - 'a'] = new Trie();\n            trie = trie.next[c - 'a'];\n        }\n        trie.end = true;\n    }\n    \n    public boolean search(String word) {\n        Trie trie = this;\n        for(int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            \n            if(trie.next[c - 'a'] == null) return false; // letter is not stored\n\n            trie = trie.next[c - 'a'];    \n        }\n        return trie.end;\n    }\n    \n    public boolean startsWith(String prefix) {\n        Trie trie = this;\n        for(int i = 0; i < prefix.length(); i++) {\n            char c = prefix.charAt(i);\n            \n            if(trie.next[c - 'a'] == null) return false;  // letter is not stored\n            \n            trie = trie.next[c - 'a'];    \n        }\n        return true;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5a1556a0-38ec-44c0-8c91-7b5cd2aa8239/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n- Trie is prefix tree\n- Trie is for autocomplete and spellchecker\n- we can only check if the letter is in Trie or not\n    \n    ```java\n    if(trie.next[c - 'a'] == null) return false; // letter is not stored\n    ```\n","slug":"208-Implement-Trie-Prefix-Tree","published":1,"updated":"2022-10-02T05:01:03.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc19000xqkcc4mx7oi6e","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>This is basic Trie data structure</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Trie[] next;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> end;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Trie</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[c - <span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>) trie.next[c - <span class=\"string\">'a'</span>] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">            trie = trie.next[c - <span class=\"string\">'a'</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trie.end = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">search</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[c - <span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">// letter is not stored</span></span><br><span class=\"line\"></span><br><span class=\"line\">            trie = trie.next[c - <span class=\"string\">'a'</span>];    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trie.end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startsWith</span><span class=\"params\">(String prefix)</span> </span>&#123;</span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = prefix.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[c - <span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  <span class=\"comment\">// letter is not stored</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            trie = trie.next[c - <span class=\"string\">'a'</span>];    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5a1556a0-38ec-44c0-8c91-7b5cd2aa8239/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ul>\n<li>\n<p>Trie is prefix tree</p>\n</li>\n<li>\n<p>Trie is for autocomplete and spellchecker</p>\n</li>\n<li>\n<p>we can only check if the letter is in Trie or not</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(trie.next[c - <span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">// letter is not stored</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>This is basic Trie data structure</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Trie[] next;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> end;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Trie</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[c - <span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>) trie.next[c - <span class=\"string\">'a'</span>] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">            trie = trie.next[c - <span class=\"string\">'a'</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trie.end = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">search</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[c - <span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">// letter is not stored</span></span><br><span class=\"line\"></span><br><span class=\"line\">            trie = trie.next[c - <span class=\"string\">'a'</span>];    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trie.end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startsWith</span><span class=\"params\">(String prefix)</span> </span>&#123;</span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = prefix.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[c - <span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  <span class=\"comment\">// letter is not stored</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            trie = trie.next[c - <span class=\"string\">'a'</span>];    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5a1556a0-38ec-44c0-8c91-7b5cd2aa8239/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ul>\n<li>\n<p>Trie is prefix tree</p>\n</li>\n<li>\n<p>Trie is for autocomplete and spellchecker</p>\n</li>\n<li>\n<p>we can only check if the letter is in Trie or not</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(trie.next[c - <span class=\"string\">'a'</span>] == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">// letter is not stored</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"21. Merge Two Sorted Lists","catalog":true,"date":"2022-10-08T04:57:14.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- sorted linked lists `list1` and `list2`\n- Return *the head of the merged linked list*\n- Both `list1` and `list2` are sorted in **non-decreasing** order.\n\n## Solve by hands first\n\n---\n\nThe problem is which node should I pick up. we can solve this issue by passing one of each node to method at a time. if the value of node1 is less than node2, then we move the pointer of node1 to the next node. so we can choose the smaller value as next node of node1. \n\n![6DB1070C-FB47-4726-AE3C-3EC0FCB3D54A.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b1d79ad-9eb1-485c-813d-5888e05d7c6c/6DB1070C-FB47-4726-AE3C-3EC0FCB3D54A.jpeg)\n\nwhen it gets to the last node which will be null then return the non null node. otherwise it will be pointing to null \n\n![72D9C3E1-FEB2-4F88-9C6F-7C835AAEC175.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/537875f4-e6d4-400b-93dc-80138926e603/72D9C3E1-FEB2-4F88-9C6F-7C835AAEC175.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode n1, ListNode n2) {\n        if(n1 == null) return n2;\n        if(n2 == null) return n1;\n        if(n1.val <= n2.val) {\n            n1.next = mergeTwoLists(n1.next, n2);\n            return n1;\n        } else {\n            n2.next = mergeTwoLists(n1, n2.next);\n            return n2;\n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2e988140-fabd-49ce-9f65-441882cc48f7/Untitled.png)\n\n![0346DEB9-8B32-4EA5-B64D-07819821B006.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e893057-1502-4d21-b1c2-077d28cceb8d/0346DEB9-8B32-4EA5-B64D-07819821B006.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. I don’t need to move the two node at the same time. move the one node at a time and compare them. setting a right base case is important in this case\n\n```java\npublic ListNode mergeTwoLists(ListNode n1, ListNode n2) {\n        if(n1 == null) return n2;\n        if(n2 == null) return n1;\n        if(n1.val <= n2.val) {\n            n1.next = mergeTwoLists(n1.next, n2);\n            return n1;\n        } else {\n            n2.next = mergeTwoLists(n1, n2.next);\n            return n2;\n        }\n    }\n```\n\n1. reference the next node to return value\n    - I can reference the return value as next node\n    - also consider return node itself\n\n```java\nn1.next = mergeTwoLists(n1.next, n2);\nreturn n1;\n```\n","source":"_posts/21-Merge-Two-Sorted-Lists.md","raw":"---\ntitle: \"21.\\_Merge Two Sorted Lists\"\ncatalog: true\ndate: 2022-10-08 13:57:14\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- sorted linked lists `list1` and `list2`\n- Return *the head of the merged linked list*\n- Both `list1` and `list2` are sorted in **non-decreasing** order.\n\n## Solve by hands first\n\n---\n\nThe problem is which node should I pick up. we can solve this issue by passing one of each node to method at a time. if the value of node1 is less than node2, then we move the pointer of node1 to the next node. so we can choose the smaller value as next node of node1. \n\n![6DB1070C-FB47-4726-AE3C-3EC0FCB3D54A.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b1d79ad-9eb1-485c-813d-5888e05d7c6c/6DB1070C-FB47-4726-AE3C-3EC0FCB3D54A.jpeg)\n\nwhen it gets to the last node which will be null then return the non null node. otherwise it will be pointing to null \n\n![72D9C3E1-FEB2-4F88-9C6F-7C835AAEC175.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/537875f4-e6d4-400b-93dc-80138926e603/72D9C3E1-FEB2-4F88-9C6F-7C835AAEC175.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode n1, ListNode n2) {\n        if(n1 == null) return n2;\n        if(n2 == null) return n1;\n        if(n1.val <= n2.val) {\n            n1.next = mergeTwoLists(n1.next, n2);\n            return n1;\n        } else {\n            n2.next = mergeTwoLists(n1, n2.next);\n            return n2;\n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2e988140-fabd-49ce-9f65-441882cc48f7/Untitled.png)\n\n![0346DEB9-8B32-4EA5-B64D-07819821B006.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e893057-1502-4d21-b1c2-077d28cceb8d/0346DEB9-8B32-4EA5-B64D-07819821B006.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. I don’t need to move the two node at the same time. move the one node at a time and compare them. setting a right base case is important in this case\n\n```java\npublic ListNode mergeTwoLists(ListNode n1, ListNode n2) {\n        if(n1 == null) return n2;\n        if(n2 == null) return n1;\n        if(n1.val <= n2.val) {\n            n1.next = mergeTwoLists(n1.next, n2);\n            return n1;\n        } else {\n            n2.next = mergeTwoLists(n1, n2.next);\n            return n2;\n        }\n    }\n```\n\n1. reference the next node to return value\n    - I can reference the return value as next node\n    - also consider return node itself\n\n```java\nn1.next = mergeTwoLists(n1.next, n2);\nreturn n1;\n```\n","slug":"21-Merge-Two-Sorted-Lists","published":1,"updated":"2022-10-08T04:57:37.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc19000yqkcc3iyunsxz","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>sorted linked lists <code>list1</code> and <code>list2</code></li>\n<li>Return <em>the head of the merged linked list</em></li>\n<li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>The problem is which node should I pick up. we can solve this issue by passing one of each node to method at a time. if the value of node1 is less than node2, then we move the pointer of node1 to the next node. so we can choose the smaller value as next node of node1.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b1d79ad-9eb1-485c-813d-5888e05d7c6c/6DB1070C-FB47-4726-AE3C-3EC0FCB3D54A.jpeg\" alt=\"6DB1070C-FB47-4726-AE3C-3EC0FCB3D54A.jpeg\"></p>\n<p>when it gets to the last node which will be null then return the non null node. otherwise it will be pointing to null</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/537875f4-e6d4-400b-93dc-80138926e603/72D9C3E1-FEB2-4F88-9C6F-7C835AAEC175.jpeg\" alt=\"72D9C3E1-FEB2-4F88-9C6F-7C835AAEC175.jpeg\"></p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode n1, ListNode n2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n1.val &lt;= n2.val) &#123;</span><br><span class=\"line\">            n1.next = mergeTwoLists(n1.next, n2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            n2.next = mergeTwoLists(n1, n2.next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2e988140-fabd-49ce-9f65-441882cc48f7/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e893057-1502-4d21-b1c2-077d28cceb8d/0346DEB9-8B32-4EA5-B64D-07819821B006.jpeg\" alt=\"0346DEB9-8B32-4EA5-B64D-07819821B006.jpeg\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>I don’t need to move the two node at the same time. move the one node at a time and compare them. setting a right base case is important in this case</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode n1, ListNode n2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n1.val &lt;= n2.val) &#123;</span><br><span class=\"line\">            n1.next = mergeTwoLists(n1.next, n2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            n2.next = mergeTwoLists(n1, n2.next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>reference the next node to return value\n<ul>\n<li>I can reference the return value as next node</li>\n<li>also consider return node itself</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1.next = mergeTwoLists(n1.next, n2);</span><br><span class=\"line\"><span class=\"keyword\">return</span> n1;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>sorted linked lists <code>list1</code> and <code>list2</code></li>\n<li>Return <em>the head of the merged linked list</em></li>\n<li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>The problem is which node should I pick up. we can solve this issue by passing one of each node to method at a time. if the value of node1 is less than node2, then we move the pointer of node1 to the next node. so we can choose the smaller value as next node of node1.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b1d79ad-9eb1-485c-813d-5888e05d7c6c/6DB1070C-FB47-4726-AE3C-3EC0FCB3D54A.jpeg\" alt=\"6DB1070C-FB47-4726-AE3C-3EC0FCB3D54A.jpeg\"></p>\n<p>when it gets to the last node which will be null then return the non null node. otherwise it will be pointing to null</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/537875f4-e6d4-400b-93dc-80138926e603/72D9C3E1-FEB2-4F88-9C6F-7C835AAEC175.jpeg\" alt=\"72D9C3E1-FEB2-4F88-9C6F-7C835AAEC175.jpeg\"></p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode n1, ListNode n2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n1.val &lt;= n2.val) &#123;</span><br><span class=\"line\">            n1.next = mergeTwoLists(n1.next, n2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            n2.next = mergeTwoLists(n1, n2.next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2e988140-fabd-49ce-9f65-441882cc48f7/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e893057-1502-4d21-b1c2-077d28cceb8d/0346DEB9-8B32-4EA5-B64D-07819821B006.jpeg\" alt=\"0346DEB9-8B32-4EA5-B64D-07819821B006.jpeg\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>I don’t need to move the two node at the same time. move the one node at a time and compare them. setting a right base case is important in this case</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode n1, ListNode n2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n1.val &lt;= n2.val) &#123;</span><br><span class=\"line\">            n1.next = mergeTwoLists(n1.next, n2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            n2.next = mergeTwoLists(n1, n2.next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>reference the next node to return value\n<ul>\n<li>I can reference the return value as next node</li>\n<li>also consider return node itself</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1.next = mergeTwoLists(n1.next, n2);</span><br><span class=\"line\"><span class=\"keyword\">return</span> n1;</span><br></pre></td></tr></table></figure>\n"},{"title":"22. Generate Parentheses","catalog":true,"date":"2022-11-01T11:10:35.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- write a function to *generate all combinations of well-formed parentheses with n pair of parentheses*\n\n### **Edge cases**\n\n---\n\n- 2 → [(()),()()]\n- 3 → [((())),(())(),()(()),()()()]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nMost of combination problem can be solved either dynamic programming or dfs. given n means pairs of parentheses. so we have n number of open bracket and close bracket each. we can make combination of open and close bracket pair with dfs algorithm. we can start with n open bracket and n close bracket first. Adding open bracket is only possible when open bracket is remaining (open > 0) and ***number of open is less than number of close bracket because if there are more open bracket, there is no way to close!*** The base case is when both open and close bracket is 0. Time complexity is O(2^n) and space complexity is O(1)\n\n![684B2A94-DDD9-4914-B4D7-106982420C50.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0730331e-4d23-4785-b67a-7040c5811b6e/684B2A94-DDD9-4914-B4D7-106982420C50.jpeg)\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n*the interviewer can provide you with some hints to unblock you*\n\n*it’s okay to ask the interviewer for direction.*\n\n### **Coding**\n\n---\n\n```java\nList<String> res = new ArrayList();\n\npublic List<String> generateParenthesis(int n) {\n    dfs(\"\", n, n);\n    return res;\n}\n\nprivate void dfs(String s, int open, int close) {\n\t\tif(open > close) return;\n\t\tif(open > 0) dfs(s + \"(\", open - 1, close);\n\t\tif(close > 0) dfs(s + \")\", open, close - 1);\n\t\tif(open == 0 && close == 0) {\n        res.add(s);\n        return;\n\t\t}\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cad1d62b-8223-4517-8366-dcb5fa0077da/Untitled.png)\n\n### What I learned\n\n---\n\n1. In bracket problem, number of open brackets is always bigger than number of close brackets\n\n```java\n(() // there is no way to make complete bracket\n```\n","source":"_posts/22-Generate-Parentheses.md","raw":"---\ntitle: \"22.\\_Generate Parentheses\"\ncatalog: true\ndate: 2022-11-01 20:10:35\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- write a function to *generate all combinations of well-formed parentheses with n pair of parentheses*\n\n### **Edge cases**\n\n---\n\n- 2 → [(()),()()]\n- 3 → [((())),(())(),()(()),()()()]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nMost of combination problem can be solved either dynamic programming or dfs. given n means pairs of parentheses. so we have n number of open bracket and close bracket each. we can make combination of open and close bracket pair with dfs algorithm. we can start with n open bracket and n close bracket first. Adding open bracket is only possible when open bracket is remaining (open > 0) and ***number of open is less than number of close bracket because if there are more open bracket, there is no way to close!*** The base case is when both open and close bracket is 0. Time complexity is O(2^n) and space complexity is O(1)\n\n![684B2A94-DDD9-4914-B4D7-106982420C50.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0730331e-4d23-4785-b67a-7040c5811b6e/684B2A94-DDD9-4914-B4D7-106982420C50.jpeg)\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n*the interviewer can provide you with some hints to unblock you*\n\n*it’s okay to ask the interviewer for direction.*\n\n### **Coding**\n\n---\n\n```java\nList<String> res = new ArrayList();\n\npublic List<String> generateParenthesis(int n) {\n    dfs(\"\", n, n);\n    return res;\n}\n\nprivate void dfs(String s, int open, int close) {\n\t\tif(open > close) return;\n\t\tif(open > 0) dfs(s + \"(\", open - 1, close);\n\t\tif(close > 0) dfs(s + \")\", open, close - 1);\n\t\tif(open == 0 && close == 0) {\n        res.add(s);\n        return;\n\t\t}\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cad1d62b-8223-4517-8366-dcb5fa0077da/Untitled.png)\n\n### What I learned\n\n---\n\n1. In bracket problem, number of open brackets is always bigger than number of close brackets\n\n```java\n(() // there is no way to make complete bracket\n```\n","slug":"22-Generate-Parentheses","published":1,"updated":"2022-11-01T11:10:54.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc19000zqkccto5jb5bs","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>write a function to <em>generate all combinations of well-formed parentheses with n pair of parentheses</em></li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>2 → [(()),()()]</li>\n<li>3 → [((())),(())(),()(()),()()()]</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>Most of combination problem can be solved either dynamic programming or dfs. given n means pairs of parentheses. so we have n number of open bracket and close bracket each. we can make combination of open and close bracket pair with dfs algorithm. we can start with n open bracket and n close bracket first. Adding open bracket is only possible when open bracket is remaining (open &gt; 0) and <strong><em>number of open is less than number of close bracket because if there are more open bracket, there is no way to close!</em></strong> The base case is when both open and close bracket is 0. Time complexity is O(2^n) and space complexity is O(1)</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0730331e-4d23-4785-b67a-7040c5811b6e/684B2A94-DDD9-4914-B4D7-106982420C50.jpeg\" alt=\"684B2A94-DDD9-4914-B4D7-106982420C50.jpeg\"></p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p><em>the interviewer can provide you with some hints to unblock you</em></p>\n<p><em>it’s okay to ask the interviewer for direction.</em></p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">generateParenthesis</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    dfs(<span class=\"string\">\"\"</span>, n, n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> open, <span class=\"keyword\">int</span> close)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(open &gt; close) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(open &gt; <span class=\"number\">0</span>) dfs(s + <span class=\"string\">\"(\"</span>, open - <span class=\"number\">1</span>, close);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(close &gt; <span class=\"number\">0</span>) dfs(s + <span class=\"string\">\")\"</span>, open, close - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(open == <span class=\"number\">0</span> &amp;&amp; close == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        res.add(s);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cad1d62b-8223-4517-8366-dcb5fa0077da/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>In bracket problem, number of open brackets is always bigger than number of close brackets</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(() <span class=\"comment\">// there is no way to make complete bracket</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>write a function to <em>generate all combinations of well-formed parentheses with n pair of parentheses</em></li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>2 → [(()),()()]</li>\n<li>3 → [((())),(())(),()(()),()()()]</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>Most of combination problem can be solved either dynamic programming or dfs. given n means pairs of parentheses. so we have n number of open bracket and close bracket each. we can make combination of open and close bracket pair with dfs algorithm. we can start with n open bracket and n close bracket first. Adding open bracket is only possible when open bracket is remaining (open &gt; 0) and <strong><em>number of open is less than number of close bracket because if there are more open bracket, there is no way to close!</em></strong> The base case is when both open and close bracket is 0. Time complexity is O(2^n) and space complexity is O(1)</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0730331e-4d23-4785-b67a-7040c5811b6e/684B2A94-DDD9-4914-B4D7-106982420C50.jpeg\" alt=\"684B2A94-DDD9-4914-B4D7-106982420C50.jpeg\"></p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p><em>the interviewer can provide you with some hints to unblock you</em></p>\n<p><em>it’s okay to ask the interviewer for direction.</em></p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">generateParenthesis</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    dfs(<span class=\"string\">\"\"</span>, n, n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> open, <span class=\"keyword\">int</span> close)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(open &gt; close) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(open &gt; <span class=\"number\">0</span>) dfs(s + <span class=\"string\">\"(\"</span>, open - <span class=\"number\">1</span>, close);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(close &gt; <span class=\"number\">0</span>) dfs(s + <span class=\"string\">\")\"</span>, open, close - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(open == <span class=\"number\">0</span> &amp;&amp; close == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        res.add(s);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cad1d62b-8223-4517-8366-dcb5fa0077da/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>In bracket problem, number of open brackets is always bigger than number of close brackets</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(() <span class=\"comment\">// there is no way to make complete bracket</span></span><br></pre></td></tr></table></figure>\n"},{"title":"217. Contains Duplicate","catalog":true,"date":"2022-10-18T09:25:17.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- return true if any value appears at least twice in the array\n- return false if every element is distinct\n- length of nums array is greater eqauls to 1 and less than equals to 10^5\n- value of array is greater than equals to -10^9 and less than equals to 10^9\n\n### **Edge cases**\n\n---\n\n- [1,2,3,4] → false\n- [1,2,2,4] → true\n- [] → true\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nI can simply using Set data structure and compare the length of input array. if the length of set is equals length of input array, it returns false since it’s distinct \n\n```java\nSet<Integer> s = new HashSet();\nfor(int n : nums) s.add(n);\nreturn nums.length == s.size() ? false : true;\n```\n\nTime complexity is O(n) since it needs to create the Set. Space complexity is O(n) in order to store the size of input array\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nThere is way we can optimize the space complexity using sort. It definitely has trade off. Sort the array first and compare to next value. if the value is equals to next value then return true. otherwise return false.\n\nTime complexity is O(nlogn) which is dual pivot quick sort in java Arrays.sort method. and space complexity is O(1)\n\n```java\nArrays.sort(nums);\nint f = nums[0];\nfor(int i = 1; i < nums.length; i++) {\n    if(f == nums[i]) return true;\n    f = nums[i];\n}\nreturn false;\n```\n\nThere is way we can optimize the solution. we don’t need to store all of arrays in HashMap, instead compare every element in node and value in set. if we find the same value in set, we can immediately return true. otherewise return false. it helps us to save time depends on how much we can find the duplicated value. but total Time complexity can be the same as previous solution\n\n```java\nSet<Integer> s = new HashSet();\nfor(int i = 0; i < nums.length; i++) {\n    if(s.contains(nums[i])) return true;\n    s.add(nums[i]);\n}\nreturn false;\n```\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer> s = new HashSet();\n        for(int i = 0; i < nums.length; i++) {\n            if(s.contains(nums[i])) return true;\n            s.add(nums[i]);\n        }\n        return false;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/935f4cfa-bd73-4aea-8dc4-b2661b069238/Untitled.png)\n\n### What I learned\n\n---\n\n1. Time complexity and space complexity of `*Arrays.sort()*` in java\n    - Time complexity : O(nlog(n))\n    - Spack complexity : O(1)\n2. Time complexity and space complexity of `*HashSet*` in java\n    - Time complexity on add : O(1)\n","source":"_posts/217-Contains-Duplicate.md","raw":"---\ntitle: \"217.\\_Contains Duplicate\"\ncatalog: true\ndate: 2022-10-18 18:25:17\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- return true if any value appears at least twice in the array\n- return false if every element is distinct\n- length of nums array is greater eqauls to 1 and less than equals to 10^5\n- value of array is greater than equals to -10^9 and less than equals to 10^9\n\n### **Edge cases**\n\n---\n\n- [1,2,3,4] → false\n- [1,2,2,4] → true\n- [] → true\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nI can simply using Set data structure and compare the length of input array. if the length of set is equals length of input array, it returns false since it’s distinct \n\n```java\nSet<Integer> s = new HashSet();\nfor(int n : nums) s.add(n);\nreturn nums.length == s.size() ? false : true;\n```\n\nTime complexity is O(n) since it needs to create the Set. Space complexity is O(n) in order to store the size of input array\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nThere is way we can optimize the space complexity using sort. It definitely has trade off. Sort the array first and compare to next value. if the value is equals to next value then return true. otherwise return false.\n\nTime complexity is O(nlogn) which is dual pivot quick sort in java Arrays.sort method. and space complexity is O(1)\n\n```java\nArrays.sort(nums);\nint f = nums[0];\nfor(int i = 1; i < nums.length; i++) {\n    if(f == nums[i]) return true;\n    f = nums[i];\n}\nreturn false;\n```\n\nThere is way we can optimize the solution. we don’t need to store all of arrays in HashMap, instead compare every element in node and value in set. if we find the same value in set, we can immediately return true. otherewise return false. it helps us to save time depends on how much we can find the duplicated value. but total Time complexity can be the same as previous solution\n\n```java\nSet<Integer> s = new HashSet();\nfor(int i = 0; i < nums.length; i++) {\n    if(s.contains(nums[i])) return true;\n    s.add(nums[i]);\n}\nreturn false;\n```\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer> s = new HashSet();\n        for(int i = 0; i < nums.length; i++) {\n            if(s.contains(nums[i])) return true;\n            s.add(nums[i]);\n        }\n        return false;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/935f4cfa-bd73-4aea-8dc4-b2661b069238/Untitled.png)\n\n### What I learned\n\n---\n\n1. Time complexity and space complexity of `*Arrays.sort()*` in java\n    - Time complexity : O(nlog(n))\n    - Spack complexity : O(1)\n2. Time complexity and space complexity of `*HashSet*` in java\n    - Time complexity on add : O(1)\n","slug":"217-Contains-Duplicate","published":1,"updated":"2022-10-18T09:25:30.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc190010qkcccc6fq2kg","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>return true if any value appears at least twice in the array</li>\n<li>return false if every element is distinct</li>\n<li>length of nums array is greater eqauls to 1 and less than equals to 10^5</li>\n<li>value of array is greater than equals to -10^9 and less than equals to 10^9</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>[1,2,3,4] → false</li>\n<li>[1,2,2,4] → true</li>\n<li>[] → true</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>I can simply using Set data structure and compare the length of input array. if the length of set is equals length of input array, it returns false since it’s distinct</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Integer&gt; s = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) s.add(n);</span><br><span class=\"line\"><span class=\"keyword\">return</span> nums.length == s.size() ? <span class=\"keyword\">false</span> : <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>Time complexity is O(n) since it needs to create the Set. Space complexity is O(n) in order to store the size of input array</p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>There is way we can optimize the space complexity using sort. It definitely has trade off. Sort the array first and compare to next value. if the value is equals to next value then return true. otherwise return false.</p>\n<p>Time complexity is O(nlogn) which is dual pivot quick sort in java Arrays.sort method. and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.sort(nums);</span><br><span class=\"line\"><span class=\"keyword\">int</span> f = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(f == nums[i]) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    f = nums[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>There is way we can optimize the solution. we don’t need to store all of arrays in HashMap, instead compare every element in node and value in set. if we find the same value in set, we can immediately return true. otherewise return false. it helps us to save time depends on how much we can find the duplicated value. but total Time complexity can be the same as previous solution</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Integer&gt; s = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.contains(nums[i])) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    s.add(nums[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; s = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.contains(nums[i])) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            s.add(nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/935f4cfa-bd73-4aea-8dc4-b2661b069238/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>Time complexity and space complexity of <code>*Arrays.sort()*</code> in java\n<ul>\n<li>Time complexity : O(nlog(n))</li>\n<li>Spack complexity : O(1)</li>\n</ul>\n</li>\n<li>Time complexity and space complexity of <code>*HashSet*</code> in java\n<ul>\n<li>Time complexity on add : O(1)</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>return true if any value appears at least twice in the array</li>\n<li>return false if every element is distinct</li>\n<li>length of nums array is greater eqauls to 1 and less than equals to 10^5</li>\n<li>value of array is greater than equals to -10^9 and less than equals to 10^9</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>[1,2,3,4] → false</li>\n<li>[1,2,2,4] → true</li>\n<li>[] → true</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>I can simply using Set data structure and compare the length of input array. if the length of set is equals length of input array, it returns false since it’s distinct</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Integer&gt; s = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) s.add(n);</span><br><span class=\"line\"><span class=\"keyword\">return</span> nums.length == s.size() ? <span class=\"keyword\">false</span> : <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>Time complexity is O(n) since it needs to create the Set. Space complexity is O(n) in order to store the size of input array</p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>There is way we can optimize the space complexity using sort. It definitely has trade off. Sort the array first and compare to next value. if the value is equals to next value then return true. otherwise return false.</p>\n<p>Time complexity is O(nlogn) which is dual pivot quick sort in java Arrays.sort method. and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.sort(nums);</span><br><span class=\"line\"><span class=\"keyword\">int</span> f = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(f == nums[i]) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    f = nums[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>There is way we can optimize the solution. we don’t need to store all of arrays in HashMap, instead compare every element in node and value in set. if we find the same value in set, we can immediately return true. otherewise return false. it helps us to save time depends on how much we can find the duplicated value. but total Time complexity can be the same as previous solution</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Integer&gt; s = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.contains(nums[i])) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    s.add(nums[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; s = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.contains(nums[i])) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            s.add(nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/935f4cfa-bd73-4aea-8dc4-b2661b069238/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>Time complexity and space complexity of <code>*Arrays.sort()*</code> in java\n<ul>\n<li>Time complexity : O(nlog(n))</li>\n<li>Spack complexity : O(1)</li>\n</ul>\n</li>\n<li>Time complexity and space complexity of <code>*HashSet*</code> in java\n<ul>\n<li>Time complexity on add : O(1)</li>\n</ul>\n</li>\n</ol>\n"},{"title":"20. Valid Parentheses","catalog":true,"date":"2022-09-13T10:27:35.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- Open brackets must be closed by the same type of brackets.\n- Open brackets must be closed in the correct order.\n- Every close bracket has a corresponding open bracket of the same type.\n\n## Solve by hands first\n\n---\n\nValid parentheses questions can be solve by using **Stack**. Store the pair of parenthese as key and value of the map which can have an advantages on time complexity (O(1)). Total time complexity is O(n) and space complexity is O(6)\n\n## Solution\n\n---\n\n```java\npublic boolean isValid(String s) {\n        \n\t\t\t// store the parentheses\n      Map<Character, Character> sm = new HashMap();\n      sm.put('[', ']');\n      sm.put('{', '}');\n      sm.put('(', ')');\n      \n      Stack<Character> cs = new Stack();\n\n\t\t\t// O(n)      \n      for(int i = 0; i < s.length(); i++) {            \n          char c = s.charAt(i);\n          \n          if(cs.isEmpty()) cs.push(c);\n          else if(!cs.isEmpty() && sm.get(cs.peek()) != null && sm.get(cs.peek()) == c) cs.pop();\n          else cs.push(c);\n      }        \n      \n      return cs.size() == 0;\n  }\n```\n\n## Lesson I learnt\n\n---\n\n1. `peek()` of stack can be useful when validate the value before poping.\n2. Store the pair of parentheses as key and value in map\n","source":"_posts/20-Valid-Parentheses.md","raw":"---\ntitle: \"20.\\_Valid Parentheses\"\ncatalog: true\ndate: 2022-09-13 19:27:35\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- Open brackets must be closed by the same type of brackets.\n- Open brackets must be closed in the correct order.\n- Every close bracket has a corresponding open bracket of the same type.\n\n## Solve by hands first\n\n---\n\nValid parentheses questions can be solve by using **Stack**. Store the pair of parenthese as key and value of the map which can have an advantages on time complexity (O(1)). Total time complexity is O(n) and space complexity is O(6)\n\n## Solution\n\n---\n\n```java\npublic boolean isValid(String s) {\n        \n\t\t\t// store the parentheses\n      Map<Character, Character> sm = new HashMap();\n      sm.put('[', ']');\n      sm.put('{', '}');\n      sm.put('(', ')');\n      \n      Stack<Character> cs = new Stack();\n\n\t\t\t// O(n)      \n      for(int i = 0; i < s.length(); i++) {            \n          char c = s.charAt(i);\n          \n          if(cs.isEmpty()) cs.push(c);\n          else if(!cs.isEmpty() && sm.get(cs.peek()) != null && sm.get(cs.peek()) == c) cs.pop();\n          else cs.push(c);\n      }        \n      \n      return cs.size() == 0;\n  }\n```\n\n## Lesson I learnt\n\n---\n\n1. `peek()` of stack can be useful when validate the value before poping.\n2. Store the pair of parentheses as key and value in map\n","slug":"20-Valid-Parentheses","published":1,"updated":"2022-09-13T10:27:53.500Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc190011qkccxiq9gz0o","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>Open brackets must be closed by the same type of brackets.</li>\n<li>Open brackets must be closed in the correct order.</li>\n<li>Every close bracket has a corresponding open bracket of the same type.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>Valid parentheses questions can be solve by using <strong>Stack</strong>. Store the pair of parenthese as key and value of the map which can have an advantages on time complexity (O(1)). Total time complexity is O(n) and space complexity is O(6)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// store the parentheses</span></span><br><span class=\"line\">      Map&lt;Character, Character&gt; sm = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">      sm.put(<span class=\"string\">'['</span>, <span class=\"string\">']'</span>);</span><br><span class=\"line\">      sm.put(<span class=\"string\">'&#123;'</span>, <span class=\"string\">'&#125;'</span>);</span><br><span class=\"line\">      sm.put(<span class=\"string\">'('</span>, <span class=\"string\">')'</span>);</span><br><span class=\"line\">      </span><br><span class=\"line\">      Stack&lt;Character&gt; cs = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// O(n)      </span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;            </span><br><span class=\"line\">          <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">          </span><br><span class=\"line\">          <span class=\"keyword\">if</span>(cs.isEmpty()) cs.push(c);</span><br><span class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!cs.isEmpty() &amp;&amp; sm.get(cs.peek()) != <span class=\"keyword\">null</span> &amp;&amp; sm.get(cs.peek()) == c) cs.pop();</span><br><span class=\"line\">          <span class=\"keyword\">else</span> cs.push(c);</span><br><span class=\"line\">      &#125;        </span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> cs.size() == <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li><code>peek()</code> of stack can be useful when validate the value before poping.</li>\n<li>Store the pair of parentheses as key and value in map</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>Open brackets must be closed by the same type of brackets.</li>\n<li>Open brackets must be closed in the correct order.</li>\n<li>Every close bracket has a corresponding open bracket of the same type.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>Valid parentheses questions can be solve by using <strong>Stack</strong>. Store the pair of parenthese as key and value of the map which can have an advantages on time complexity (O(1)). Total time complexity is O(n) and space complexity is O(6)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// store the parentheses</span></span><br><span class=\"line\">      Map&lt;Character, Character&gt; sm = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">      sm.put(<span class=\"string\">'['</span>, <span class=\"string\">']'</span>);</span><br><span class=\"line\">      sm.put(<span class=\"string\">'&#123;'</span>, <span class=\"string\">'&#125;'</span>);</span><br><span class=\"line\">      sm.put(<span class=\"string\">'('</span>, <span class=\"string\">')'</span>);</span><br><span class=\"line\">      </span><br><span class=\"line\">      Stack&lt;Character&gt; cs = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// O(n)      </span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;            </span><br><span class=\"line\">          <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">          </span><br><span class=\"line\">          <span class=\"keyword\">if</span>(cs.isEmpty()) cs.push(c);</span><br><span class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!cs.isEmpty() &amp;&amp; sm.get(cs.peek()) != <span class=\"keyword\">null</span> &amp;&amp; sm.get(cs.peek()) == c) cs.pop();</span><br><span class=\"line\">          <span class=\"keyword\">else</span> cs.push(c);</span><br><span class=\"line\">      &#125;        </span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> cs.size() == <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li><code>peek()</code> of stack can be useful when validate the value before poping.</li>\n<li>Store the pair of parentheses as key and value in map</li>\n</ol>\n"},{"title":"212. Word Search II","catalog":true,"date":"2022-09-19T14:39:54.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- all lowercase english letter\n- all the strings of words are unique\n- word is constructed from letters of sequentially adjacent cells which neiboring horizontally or vertically\n- the same cells are not used more than once in a word\n\n## Solve by hands first\n\n---\n\nWe can start with Brute Force way. Iterate though every input `words` (length ≤ 10) and matches the each letters (length ≤ 3 * 10^4) in `words`. with `board` array (length ≤ 12 ^ 2). so Time complexity will be approximately O(w*l*m*n) = O(n^4). It will takes around 10 x 3 x 10^3 x 12 x 12 = 4,320,000 second which is not efficient\n\nWe can also come up with Trie data structure. Create Trie with input `words` and iterate `board` through adjacent cells horizontally and vertically. if node in Trie has the letter in cell then check the adjacent cell if it matches next node in Trie. Since we are only enable to check adjacent cells, use BFS to check the adjacent cell around the target letter.\n\n**So, this question is combination of Trie + BFS + Backtracking algorithm**\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    class Trie {\n        Trie[] next = new Trie[26];\n        String word;\n    }\n    \n    int[] dx = new int[] {1,-1,0,0};\n    int[] dy = new int[] {0,0,1,-1};\n    \n    class Cell {\n        int x;\n        int y;\n        \n        Cell(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public List<String> findWords(char[][] board, String[] words) {\n        \n        List<String> ans = new ArrayList();\n        Stack<Cell> q = new Stack();\n        \n        Trie trie = new Trie();\n        for(int i = 0; i < words.length; i++) {\n            build(words[i], trie);\n        }\n        \n        Trie root = trie;\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[i].length; j++) {\n            \n                // initialze the trie\n                trie = root;\n                q.push(new Cell(i, j));\n                \n                while(!q.isEmpty()) {\n                    Cell cc = q.pop();\n                    char c = board[cc.x][cc.y];\n                    \n                    int idx = c - 'a';\n                    \n                    // if there is no letter in trie then skip\n                    if(trie.next[idx] == null) continue;\n                    \n                    // move to next node\n                    trie = trie.next[idx];\n                        \n                    // add if it's last\n                    if(trie.word != null) {\n                        ans.add(trie.word);\n                        trie.word = null; // initialize the last word otherwise it will keep iterate\n                    }\n                                        \n                    for(int z = 0; z < 4; z++) {\n                        int cx = cc.x + dx[z];\n                        int cy = cc.y + dy[z];\n\n                        if(cx < 0 || cy < 0 || cx >= board.length || cy >= board[i].length) continue;\n                        \n                        q.push(new Cell(cx, cy));\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n    \n    private void build(String word, Trie trie) {\n        \n        // 1. create Trie data structure\n        for(int i = 0; i < word.length(); i++) {    \n            char c = word.charAt(i);\n            int idx = c - 'a';\n            \n            if(trie.next[idx] == null) {\n                trie.next[idx] = new Trie();\n            }\n            \n            trie = trie.next[idx];\n        }\n        \n        // 2. caches the words at the last trie \n        trie.word = word;\n    }\n}\n```\n\n1. create **Trie** with input words\n2. visit every cell and find the word in Trie by **DFS**\n3. switch visited cell to temp word and recover it by **Backtracking**\n\n**The mistake that I made was that I use BFS not DFS**. I can switch Queue to Stack but still needed backtracking but it seems impossible to backtrack with Stack.\n\nMore than one word in Trie can be started from the same cell. For instance words “hklf” and “hf” is from the same cell “h”. In “hf”, f is already visited so “hklf” can’t access to f\n\n```java\n\n      l   pop  \nh pop f        f\n```\n\n## Lesson I learnt\n\n---\n\n1. How to build trie\n    \n    **In Trie, each index represent the alphat letter.** If the value in index of array is null, it means there is no next letter in Trie.\n    \n    ```java\n    class Trie {\n    \n    \tTrie[] next = new Trie[26];\n    \tString word;\n    }\n    \n    void build() {\n    \tTrie trie = new Trie();\n    \n    \tfor(int i = 0; i < word.length(); i++) {    \n    \t\t// 1. create Trie\n    \t\tchar c = word.charAt(i);\n    \t\tint idx = c - 'a';\n    \t\t\n    \t\tif(trie.next[idx] == null) {\n    \t\t\ttrie.next[idx] = new Trie();\n    \t\t}\n    \t\t\n    \t\ttrie = trie.next[idx];\n    \t}\n    \n    \t  // 2. caches the words at the last trie \n    \ttrie.word = word;\n    }\n    ```\n    \n    Trie data structure to make word “bb”\n    \n    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b2855d5-cb2b-4c95-b90d-f3fac6bf3ba7/Untitled.png)\n    \n2. **initialize the trie node when other words start** \n    \n    ```java\n    Trie root = trie;\n    for(int i = 0; i < board.length; i++) {\n        for(int j = 0; j < board[i].length; j++) {\n        \n            // initialze the trie\n            trie = root;\n    \t}\n    }\n    ```\n    \n3. **intialize the trie.word to skip the duplicated word**\n    \n    oath, ath, th, h end with h which Trie contains word = oath. so in order to ignore the imperfect word, initialize the trie.word to null\n    \n    ```java\n    if(trie.word != null) {\n        ans.add(trie.word);\n        trie.word = null; // to avoid checking similiar words\n    }\n    ```\n    \n4. **How can I check if the word is already used?**\n    \n    ```java\n    board[y][x] = '_';                     // temp word\n    find(board, x + 1, y, trie, result);\n    find(board, x, y + 1, trie, result);\n    find(board, x - 1, y, trie, result);\n    find(board, x, y - 1, trie, result);\n    board[y][x] = c;                       // recover\n    ```\n    \n    If we use the Backtracking, we can switch the value temporarly and recover it. Threre are two ways to implement backtracking\n    \n    1. **Stack**\n    2. **Memory Stack**\n    \n    Problem of using Stack data structure, we have to cache the important to data to recover. so it is way easier to use Memory Stack for backtracking\n    \n5. **Trie can also check if the character is in the next Trie array**\n    \n    ```java\n    class Trie {\n        Trie[] next = new Trie[26];\n        String word;\n    \n    \t\tboolean isContain(char c) {\n    \t\t\treturn next[c - 'a'] != null;\n    \t\t}\n    }\n    ```\n","source":"_posts/212-Word-Search-II.md","raw":"---\ntitle: \"212.\\_Word Search II\"\ncatalog: true\ndate: 2022-09-19 23:39:54\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- all lowercase english letter\n- all the strings of words are unique\n- word is constructed from letters of sequentially adjacent cells which neiboring horizontally or vertically\n- the same cells are not used more than once in a word\n\n## Solve by hands first\n\n---\n\nWe can start with Brute Force way. Iterate though every input `words` (length ≤ 10) and matches the each letters (length ≤ 3 * 10^4) in `words`. with `board` array (length ≤ 12 ^ 2). so Time complexity will be approximately O(w*l*m*n) = O(n^4). It will takes around 10 x 3 x 10^3 x 12 x 12 = 4,320,000 second which is not efficient\n\nWe can also come up with Trie data structure. Create Trie with input `words` and iterate `board` through adjacent cells horizontally and vertically. if node in Trie has the letter in cell then check the adjacent cell if it matches next node in Trie. Since we are only enable to check adjacent cells, use BFS to check the adjacent cell around the target letter.\n\n**So, this question is combination of Trie + BFS + Backtracking algorithm**\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    class Trie {\n        Trie[] next = new Trie[26];\n        String word;\n    }\n    \n    int[] dx = new int[] {1,-1,0,0};\n    int[] dy = new int[] {0,0,1,-1};\n    \n    class Cell {\n        int x;\n        int y;\n        \n        Cell(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public List<String> findWords(char[][] board, String[] words) {\n        \n        List<String> ans = new ArrayList();\n        Stack<Cell> q = new Stack();\n        \n        Trie trie = new Trie();\n        for(int i = 0; i < words.length; i++) {\n            build(words[i], trie);\n        }\n        \n        Trie root = trie;\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[i].length; j++) {\n            \n                // initialze the trie\n                trie = root;\n                q.push(new Cell(i, j));\n                \n                while(!q.isEmpty()) {\n                    Cell cc = q.pop();\n                    char c = board[cc.x][cc.y];\n                    \n                    int idx = c - 'a';\n                    \n                    // if there is no letter in trie then skip\n                    if(trie.next[idx] == null) continue;\n                    \n                    // move to next node\n                    trie = trie.next[idx];\n                        \n                    // add if it's last\n                    if(trie.word != null) {\n                        ans.add(trie.word);\n                        trie.word = null; // initialize the last word otherwise it will keep iterate\n                    }\n                                        \n                    for(int z = 0; z < 4; z++) {\n                        int cx = cc.x + dx[z];\n                        int cy = cc.y + dy[z];\n\n                        if(cx < 0 || cy < 0 || cx >= board.length || cy >= board[i].length) continue;\n                        \n                        q.push(new Cell(cx, cy));\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n    \n    private void build(String word, Trie trie) {\n        \n        // 1. create Trie data structure\n        for(int i = 0; i < word.length(); i++) {    \n            char c = word.charAt(i);\n            int idx = c - 'a';\n            \n            if(trie.next[idx] == null) {\n                trie.next[idx] = new Trie();\n            }\n            \n            trie = trie.next[idx];\n        }\n        \n        // 2. caches the words at the last trie \n        trie.word = word;\n    }\n}\n```\n\n1. create **Trie** with input words\n2. visit every cell and find the word in Trie by **DFS**\n3. switch visited cell to temp word and recover it by **Backtracking**\n\n**The mistake that I made was that I use BFS not DFS**. I can switch Queue to Stack but still needed backtracking but it seems impossible to backtrack with Stack.\n\nMore than one word in Trie can be started from the same cell. For instance words “hklf” and “hf” is from the same cell “h”. In “hf”, f is already visited so “hklf” can’t access to f\n\n```java\n\n      l   pop  \nh pop f        f\n```\n\n## Lesson I learnt\n\n---\n\n1. How to build trie\n    \n    **In Trie, each index represent the alphat letter.** If the value in index of array is null, it means there is no next letter in Trie.\n    \n    ```java\n    class Trie {\n    \n    \tTrie[] next = new Trie[26];\n    \tString word;\n    }\n    \n    void build() {\n    \tTrie trie = new Trie();\n    \n    \tfor(int i = 0; i < word.length(); i++) {    \n    \t\t// 1. create Trie\n    \t\tchar c = word.charAt(i);\n    \t\tint idx = c - 'a';\n    \t\t\n    \t\tif(trie.next[idx] == null) {\n    \t\t\ttrie.next[idx] = new Trie();\n    \t\t}\n    \t\t\n    \t\ttrie = trie.next[idx];\n    \t}\n    \n    \t  // 2. caches the words at the last trie \n    \ttrie.word = word;\n    }\n    ```\n    \n    Trie data structure to make word “bb”\n    \n    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b2855d5-cb2b-4c95-b90d-f3fac6bf3ba7/Untitled.png)\n    \n2. **initialize the trie node when other words start** \n    \n    ```java\n    Trie root = trie;\n    for(int i = 0; i < board.length; i++) {\n        for(int j = 0; j < board[i].length; j++) {\n        \n            // initialze the trie\n            trie = root;\n    \t}\n    }\n    ```\n    \n3. **intialize the trie.word to skip the duplicated word**\n    \n    oath, ath, th, h end with h which Trie contains word = oath. so in order to ignore the imperfect word, initialize the trie.word to null\n    \n    ```java\n    if(trie.word != null) {\n        ans.add(trie.word);\n        trie.word = null; // to avoid checking similiar words\n    }\n    ```\n    \n4. **How can I check if the word is already used?**\n    \n    ```java\n    board[y][x] = '_';                     // temp word\n    find(board, x + 1, y, trie, result);\n    find(board, x, y + 1, trie, result);\n    find(board, x - 1, y, trie, result);\n    find(board, x, y - 1, trie, result);\n    board[y][x] = c;                       // recover\n    ```\n    \n    If we use the Backtracking, we can switch the value temporarly and recover it. Threre are two ways to implement backtracking\n    \n    1. **Stack**\n    2. **Memory Stack**\n    \n    Problem of using Stack data structure, we have to cache the important to data to recover. so it is way easier to use Memory Stack for backtracking\n    \n5. **Trie can also check if the character is in the next Trie array**\n    \n    ```java\n    class Trie {\n        Trie[] next = new Trie[26];\n        String word;\n    \n    \t\tboolean isContain(char c) {\n    \t\t\treturn next[c - 'a'] != null;\n    \t\t}\n    }\n    ```\n","slug":"212-Word-Search-II","published":1,"updated":"2022-09-19T14:40:13.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1a0012qkcchqk9sf8s","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>all lowercase english letter</li>\n<li>all the strings of words are unique</li>\n<li>word is constructed from letters of sequentially adjacent cells which neiboring horizontally or vertically</li>\n<li>the same cells are not used more than once in a word</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>We can start with Brute Force way. Iterate though every input <code>words</code> (length ≤ 10) and matches the each letters (length ≤ 3 * 10^4) in <code>words</code>. with <code>board</code> array (length ≤ 12 ^ 2). so Time complexity will be approximately O(w<em>l</em>m*n) = O(n^4). It will takes around 10 x 3 x 10^3 x 12 x 12 = 4,320,000 second which is not efficient</p>\n<p>We can also come up with Trie data structure. Create Trie with input <code>words</code> and iterate <code>board</code> through adjacent cells horizontally and vertically. if node in Trie has the letter in cell then check the adjacent cell if it matches next node in Trie. Since we are only enable to check adjacent cells, use BFS to check the adjacent cell around the target letter.</p>\n<p><strong>So, this question is combination of Trie + BFS + Backtracking algorithm</strong></p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">        Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">        String word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>,-<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,-<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cell</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Cell(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">findWords</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;String&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        Stack&lt;Cell&gt; q = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">        </span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; words.length; i++) &#123;</span><br><span class=\"line\">            build(words[i], trie);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Trie root = trie;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">                <span class=\"comment\">// initialze the trie</span></span><br><span class=\"line\">                trie = root;</span><br><span class=\"line\">                q.push(<span class=\"keyword\">new</span> Cell(i, j));</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">                    Cell cc = q.pop();</span><br><span class=\"line\">                    <span class=\"keyword\">char</span> c = board[cc.x][cc.y];</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">int</span> idx = c - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">// if there is no letter in trie then skip</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(trie.next[idx] == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">// move to next node</span></span><br><span class=\"line\">                    trie = trie.next[idx];</span><br><span class=\"line\">                        </span><br><span class=\"line\">                    <span class=\"comment\">// add if it's last</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(trie.word != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        ans.add(trie.word);</span><br><span class=\"line\">                        trie.word = <span class=\"keyword\">null</span>; <span class=\"comment\">// initialize the last word otherwise it will keep iterate</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                                        </span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">4</span>; z++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> cx = cc.x + dx[z];</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> cy = cc.y + dy[z];</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(cx &lt; <span class=\"number\">0</span> || cy &lt; <span class=\"number\">0</span> || cx &gt;= board.length || cy &gt;= board[i].length) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        q.push(<span class=\"keyword\">new</span> Cell(cx, cy));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(String word, Trie trie)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 1. create Trie data structure</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;    </span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> idx = c - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[idx] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                trie.next[idx] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            trie = trie.next[idx];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 2. caches the words at the last trie </span></span><br><span class=\"line\">        trie.word = word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>create <strong>Trie</strong> with input words</li>\n<li>visit every cell and find the word in Trie by <strong>DFS</strong></li>\n<li>switch visited cell to temp word and recover it by <strong>Backtracking</strong></li>\n</ol>\n<p><strong>The mistake that I made was that I use BFS not DFS</strong>. I can switch Queue to Stack but still needed backtracking but it seems impossible to backtrack with Stack.</p>\n<p>More than one word in Trie can be started from the same cell. For instance words “hklf” and “hf” is from the same cell “h”. In “hf”, f is already visited so “hklf” can’t access to f</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">      l   pop  </span><br><span class=\"line\">h pop f        f</span><br></pre></td></tr></table></figure>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>How to build trie</p>\n<p><strong>In Trie, each index represent the alphat letter.</strong> If the value in index of array is null, it means there is no next letter in Trie.</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTrie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">\tString word;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tTrie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;    </span><br><span class=\"line\">\t\t<span class=\"comment\">// 1. create Trie</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> idx = c - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(trie.next[idx] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\ttrie.next[idx] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttrie = trie.next[idx];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t  <span class=\"comment\">// 2. caches the words at the last trie </span></span><br><span class=\"line\">\ttrie.word = word;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>Trie data structure to make word “bb”\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b2855d5-cb2b-4c95-b90d-f3fac6bf3ba7/Untitled.png)\n</code></pre>\n<ol start=\"2\">\n<li>\n<p><strong>initialize the trie node when other words start</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trie root = trie;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// initialze the trie</span></span><br><span class=\"line\">        trie = root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p><strong>intialize the trie.word to skip the duplicated word</strong></p>\n<p>oath, ath, th, h end with h which Trie contains word = oath. so in order to ignore the imperfect word, initialize the trie.word to null</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(trie.word != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    ans.add(trie.word);</span><br><span class=\"line\">    trie.word = <span class=\"keyword\">null</span>; <span class=\"comment\">// to avoid checking similiar words</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p><strong>How can I check if the word is already used?</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">board[y][x] = <span class=\"string\">'_'</span>;                     <span class=\"comment\">// temp word</span></span><br><span class=\"line\">find(board, x + <span class=\"number\">1</span>, y, trie, result);</span><br><span class=\"line\">find(board, x, y + <span class=\"number\">1</span>, trie, result);</span><br><span class=\"line\">find(board, x - <span class=\"number\">1</span>, y, trie, result);</span><br><span class=\"line\">find(board, x, y - <span class=\"number\">1</span>, trie, result);</span><br><span class=\"line\">board[y][x] = c;                       <span class=\"comment\">// recover</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>If we use the Backtracking, we can switch the value temporarly and recover it. Threre are two ways to implement backtracking\n\n1. **Stack**\n2. **Memory Stack**\n\nProblem of using Stack data structure, we have to cache the important to data to recover. so it is way easier to use Memory Stack for backtracking\n</code></pre>\n<ol start=\"5\">\n<li>\n<p><strong>Trie can also check if the character is in the next Trie array</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">    Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">    String word;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isContain</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> next[c - <span class=\"string\">'a'</span>] != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>all lowercase english letter</li>\n<li>all the strings of words are unique</li>\n<li>word is constructed from letters of sequentially adjacent cells which neiboring horizontally or vertically</li>\n<li>the same cells are not used more than once in a word</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>We can start with Brute Force way. Iterate though every input <code>words</code> (length ≤ 10) and matches the each letters (length ≤ 3 * 10^4) in <code>words</code>. with <code>board</code> array (length ≤ 12 ^ 2). so Time complexity will be approximately O(w<em>l</em>m*n) = O(n^4). It will takes around 10 x 3 x 10^3 x 12 x 12 = 4,320,000 second which is not efficient</p>\n<p>We can also come up with Trie data structure. Create Trie with input <code>words</code> and iterate <code>board</code> through adjacent cells horizontally and vertically. if node in Trie has the letter in cell then check the adjacent cell if it matches next node in Trie. Since we are only enable to check adjacent cells, use BFS to check the adjacent cell around the target letter.</p>\n<p><strong>So, this question is combination of Trie + BFS + Backtracking algorithm</strong></p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">        Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">        String word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>,-<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,-<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cell</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Cell(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">findWords</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;String&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        Stack&lt;Cell&gt; q = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">        </span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; words.length; i++) &#123;</span><br><span class=\"line\">            build(words[i], trie);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Trie root = trie;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">                <span class=\"comment\">// initialze the trie</span></span><br><span class=\"line\">                trie = root;</span><br><span class=\"line\">                q.push(<span class=\"keyword\">new</span> Cell(i, j));</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">while</span>(!q.isEmpty()) &#123;</span><br><span class=\"line\">                    Cell cc = q.pop();</span><br><span class=\"line\">                    <span class=\"keyword\">char</span> c = board[cc.x][cc.y];</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">int</span> idx = c - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">// if there is no letter in trie then skip</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(trie.next[idx] == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">// move to next node</span></span><br><span class=\"line\">                    trie = trie.next[idx];</span><br><span class=\"line\">                        </span><br><span class=\"line\">                    <span class=\"comment\">// add if it's last</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(trie.word != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        ans.add(trie.word);</span><br><span class=\"line\">                        trie.word = <span class=\"keyword\">null</span>; <span class=\"comment\">// initialize the last word otherwise it will keep iterate</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                                        </span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">4</span>; z++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> cx = cc.x + dx[z];</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> cy = cc.y + dy[z];</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(cx &lt; <span class=\"number\">0</span> || cy &lt; <span class=\"number\">0</span> || cx &gt;= board.length || cy &gt;= board[i].length) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        q.push(<span class=\"keyword\">new</span> Cell(cx, cy));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(String word, Trie trie)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 1. create Trie data structure</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;    </span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> idx = c - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[idx] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                trie.next[idx] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            trie = trie.next[idx];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 2. caches the words at the last trie </span></span><br><span class=\"line\">        trie.word = word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>create <strong>Trie</strong> with input words</li>\n<li>visit every cell and find the word in Trie by <strong>DFS</strong></li>\n<li>switch visited cell to temp word and recover it by <strong>Backtracking</strong></li>\n</ol>\n<p><strong>The mistake that I made was that I use BFS not DFS</strong>. I can switch Queue to Stack but still needed backtracking but it seems impossible to backtrack with Stack.</p>\n<p>More than one word in Trie can be started from the same cell. For instance words “hklf” and “hf” is from the same cell “h”. In “hf”, f is already visited so “hklf” can’t access to f</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">      l   pop  </span><br><span class=\"line\">h pop f        f</span><br></pre></td></tr></table></figure>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>How to build trie</p>\n<p><strong>In Trie, each index represent the alphat letter.</strong> If the value in index of array is null, it means there is no next letter in Trie.</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTrie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">\tString word;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tTrie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;    </span><br><span class=\"line\">\t\t<span class=\"comment\">// 1. create Trie</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> idx = c - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(trie.next[idx] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\ttrie.next[idx] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttrie = trie.next[idx];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t  <span class=\"comment\">// 2. caches the words at the last trie </span></span><br><span class=\"line\">\ttrie.word = word;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>Trie data structure to make word “bb”\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b2855d5-cb2b-4c95-b90d-f3fac6bf3ba7/Untitled.png)\n</code></pre>\n<ol start=\"2\">\n<li>\n<p><strong>initialize the trie node when other words start</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trie root = trie;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// initialze the trie</span></span><br><span class=\"line\">        trie = root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p><strong>intialize the trie.word to skip the duplicated word</strong></p>\n<p>oath, ath, th, h end with h which Trie contains word = oath. so in order to ignore the imperfect word, initialize the trie.word to null</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(trie.word != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    ans.add(trie.word);</span><br><span class=\"line\">    trie.word = <span class=\"keyword\">null</span>; <span class=\"comment\">// to avoid checking similiar words</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p><strong>How can I check if the word is already used?</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">board[y][x] = <span class=\"string\">'_'</span>;                     <span class=\"comment\">// temp word</span></span><br><span class=\"line\">find(board, x + <span class=\"number\">1</span>, y, trie, result);</span><br><span class=\"line\">find(board, x, y + <span class=\"number\">1</span>, trie, result);</span><br><span class=\"line\">find(board, x - <span class=\"number\">1</span>, y, trie, result);</span><br><span class=\"line\">find(board, x, y - <span class=\"number\">1</span>, trie, result);</span><br><span class=\"line\">board[y][x] = c;                       <span class=\"comment\">// recover</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>If we use the Backtracking, we can switch the value temporarly and recover it. Threre are two ways to implement backtracking\n\n1. **Stack**\n2. **Memory Stack**\n\nProblem of using Stack data structure, we have to cache the important to data to recover. so it is way easier to use Memory Stack for backtracking\n</code></pre>\n<ol start=\"5\">\n<li>\n<p><strong>Trie can also check if the character is in the next Trie array</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">    Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">    String word;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isContain</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> next[c - <span class=\"string\">'a'</span>] != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"226. Invert Binary Tree","catalog":true,"date":"2022-10-18T08:48:22.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- invert the binary tree and return its root\n- what is inverted means in this question?\n    - it means switch left and right child node.\n\n### **Edge cases**\n\n---\n\n[4, 2, 7, 1, 3, 6, 9] → [4, 7, 2, 9, 6, 3, 1]\n\n[] → []\n\n[4] → [4]\n\n[4, 2] → [4, null, 2]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nIt’s hard to use brute force way on Tree data structure\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can start with Depth First Search. Switch left and right child nodes in every visit. Put the child node to Stack if they are not null\n\nTime complexity is O(number of node). Space complexity is O(number of child nodes)\n\n[]()\n\n### **Coding**\n\n---\n\n```java\npublic TreeNode invertTree(TreeNode root) {\n    if(root == null) return null;\n    Stack<TreeNode> s = new Stack();\n    s.add(root);\n    while(!s.isEmpty()) {\n        TreeNode n = s.pop();\n        // switch\n        TreeNode l = n.left;\n        n.left = n.right;\n        n.right = l;\n        \n        if(n.left != null) s.add(n.left);\n        if(n.right != null) s.add(n.right);\n    }\n    return root;\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67467859-cf57-4e23-8d44-e31a64696bcb/Untitled.png)\n\n### What I learned\n\n---\n\n1. it doesn’t need to backtrack to change the tree structure.\n","source":"_posts/226-Invert-Binary-Tree.md","raw":"---\ntitle: \"226.\\_Invert Binary Tree\"\ncatalog: true\ndate: 2022-10-18 17:48:22\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- invert the binary tree and return its root\n- what is inverted means in this question?\n    - it means switch left and right child node.\n\n### **Edge cases**\n\n---\n\n[4, 2, 7, 1, 3, 6, 9] → [4, 7, 2, 9, 6, 3, 1]\n\n[] → []\n\n[4] → [4]\n\n[4, 2] → [4, null, 2]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nIt’s hard to use brute force way on Tree data structure\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can start with Depth First Search. Switch left and right child nodes in every visit. Put the child node to Stack if they are not null\n\nTime complexity is O(number of node). Space complexity is O(number of child nodes)\n\n[]()\n\n### **Coding**\n\n---\n\n```java\npublic TreeNode invertTree(TreeNode root) {\n    if(root == null) return null;\n    Stack<TreeNode> s = new Stack();\n    s.add(root);\n    while(!s.isEmpty()) {\n        TreeNode n = s.pop();\n        // switch\n        TreeNode l = n.left;\n        n.left = n.right;\n        n.right = l;\n        \n        if(n.left != null) s.add(n.left);\n        if(n.right != null) s.add(n.right);\n    }\n    return root;\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67467859-cf57-4e23-8d44-e31a64696bcb/Untitled.png)\n\n### What I learned\n\n---\n\n1. it doesn’t need to backtrack to change the tree structure.\n","slug":"226-Invert-Binary-Tree","published":1,"updated":"2022-10-18T08:48:42.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1a0013qkcctcqhj0qo","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>invert the binary tree and return its root</li>\n<li>what is inverted means in this question?\n<ul>\n<li>it means switch left and right child node.</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<p>[4, 2, 7, 1, 3, 6, 9] → [4, 7, 2, 9, 6, 3, 1]</p>\n<p>[] → []</p>\n<p>[4] → [4]</p>\n<p>[4, 2] → [4, null, 2]</p>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>It’s hard to use brute force way on Tree data structure</p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>We can start with Depth First Search. Switch left and right child nodes in every visit. Put the child node to Stack if they are not null</p>\n<p>Time complexity is O(number of node). Space complexity is O(number of child nodes)</p>\n<p><a href></a></p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; s = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">    s.add(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!s.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode n = s.pop();</span><br><span class=\"line\">        <span class=\"comment\">// switch</span></span><br><span class=\"line\">        TreeNode l = n.left;</span><br><span class=\"line\">        n.left = n.right;</span><br><span class=\"line\">        n.right = l;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n.left != <span class=\"keyword\">null</span>) s.add(n.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n.right != <span class=\"keyword\">null</span>) s.add(n.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67467859-cf57-4e23-8d44-e31a64696bcb/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>it doesn’t need to backtrack to change the tree structure.</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>invert the binary tree and return its root</li>\n<li>what is inverted means in this question?\n<ul>\n<li>it means switch left and right child node.</li>\n</ul>\n</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<p>[4, 2, 7, 1, 3, 6, 9] → [4, 7, 2, 9, 6, 3, 1]</p>\n<p>[] → []</p>\n<p>[4] → [4]</p>\n<p>[4, 2] → [4, null, 2]</p>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>It’s hard to use brute force way on Tree data structure</p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>We can start with Depth First Search. Switch left and right child nodes in every visit. Put the child node to Stack if they are not null</p>\n<p>Time complexity is O(number of node). Space complexity is O(number of child nodes)</p>\n<p><a href></a></p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; s = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\">    s.add(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!s.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode n = s.pop();</span><br><span class=\"line\">        <span class=\"comment\">// switch</span></span><br><span class=\"line\">        TreeNode l = n.left;</span><br><span class=\"line\">        n.left = n.right;</span><br><span class=\"line\">        n.right = l;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n.left != <span class=\"keyword\">null</span>) s.add(n.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n.right != <span class=\"keyword\">null</span>) s.add(n.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/67467859-cf57-4e23-8d44-e31a64696bcb/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>it doesn’t need to backtrack to change the tree structure.</li>\n</ol>\n"},{"title":"268. Missing Number","catalog":true,"date":"2022-09-22T08:59:31.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- array `nums` containing `n` distinct numbers in the range `[0, n]`\n- return *the only number in the range that is missing from the array.*\n\n## Solve by hands first\n\n---\n\nwe can create the cache array with size of nums.length + 1. iterate throught the integer array nums and increase the value of cache array at the value of nums as index. Time complexity will be O(n) and space complexity would be O(n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n\n        int[] t = new int[nums.length + 1];\n        \n        for(int i = 0; i < nums.length; i++) {\n            t[nums[i]]++;\n        }\n        \n        for(int i = 0; i < t.length; i++) {\n            if(t[i] == 0) return i;\n        }\n        \n        return nums.length;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5341df08-e709-4fed-99c0-b589b5b07ce1/Untitled.png)\n\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int sum = 0;\n        for(int i = 1; i <= nums.length; i++) {\n            sum += i;\n        }\n        for(int i = 0; i < nums.length; i++) {\n            sum -= nums[i];\n        }\n        return sum;\n    }\n}\n```\n\n**we can simply find the sum of 0 to n and take out the sum of the value of nums array**. Time complexity is O(n) and space complexity is O(1). below code is the simplified form of above code\n\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int sum = nums.length;\n        for(int i = 0; i < nums.length; i++) {\n            sum += i - nums[i];\n        }\n        return sum;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/60f46f39-d0bd-4a3f-93a8-af0387677a12/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. calculate sum of array and take out helps sometimes\n    \n    ```java\n    for(int i = 0; i < nums.length; i++) {\n        sum -= nums[i];\n    }\n    ```\n    \n2. we can use math to reduce the space complexity\n","source":"_posts/268-Missing-Number.md","raw":"---\ntitle: \"268.\\_Missing Number\"\ncatalog: true\ndate: 2022-09-22 17:59:31\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- array `nums` containing `n` distinct numbers in the range `[0, n]`\n- return *the only number in the range that is missing from the array.*\n\n## Solve by hands first\n\n---\n\nwe can create the cache array with size of nums.length + 1. iterate throught the integer array nums and increase the value of cache array at the value of nums as index. Time complexity will be O(n) and space complexity would be O(n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n\n        int[] t = new int[nums.length + 1];\n        \n        for(int i = 0; i < nums.length; i++) {\n            t[nums[i]]++;\n        }\n        \n        for(int i = 0; i < t.length; i++) {\n            if(t[i] == 0) return i;\n        }\n        \n        return nums.length;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5341df08-e709-4fed-99c0-b589b5b07ce1/Untitled.png)\n\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int sum = 0;\n        for(int i = 1; i <= nums.length; i++) {\n            sum += i;\n        }\n        for(int i = 0; i < nums.length; i++) {\n            sum -= nums[i];\n        }\n        return sum;\n    }\n}\n```\n\n**we can simply find the sum of 0 to n and take out the sum of the value of nums array**. Time complexity is O(n) and space complexity is O(1). below code is the simplified form of above code\n\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int sum = nums.length;\n        for(int i = 0; i < nums.length; i++) {\n            sum += i - nums[i];\n        }\n        return sum;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/60f46f39-d0bd-4a3f-93a8-af0387677a12/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. calculate sum of array and take out helps sometimes\n    \n    ```java\n    for(int i = 0; i < nums.length; i++) {\n        sum -= nums[i];\n    }\n    ```\n    \n2. we can use math to reduce the space complexity\n","slug":"268-Missing-Number","published":1,"updated":"2022-09-22T09:06:31.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1a0014qkccbrs3q63n","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code></li>\n<li>return <em>the only number in the range that is missing from the array.</em></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can create the cache array with size of nums.length + 1. iterate throught the integer array nums and increase the value of cache array at the value of nums as index. Time complexity will be O(n) and space complexity would be O(n)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] t = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            t[nums[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t[i] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums.length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5341df08-e709-4fed-99c0-b589b5b07ce1/Untitled.png\" alt=\"Untitled\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class=\"line\">            sum += i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            sum -= nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>we can simply find the sum of 0 to n and take out the sum of the value of nums array</strong>. Time complexity is O(n) and space complexity is O(1). below code is the simplified form of above code</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            sum += i - nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/60f46f39-d0bd-4a3f-93a8-af0387677a12/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>calculate sum of array and take out helps sometimes</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    sum -= nums[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li>we can use math to reduce the space complexity</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code></li>\n<li>return <em>the only number in the range that is missing from the array.</em></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can create the cache array with size of nums.length + 1. iterate throught the integer array nums and increase the value of cache array at the value of nums as index. Time complexity will be O(n) and space complexity would be O(n)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] t = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            t[nums[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t[i] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums.length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5341df08-e709-4fed-99c0-b589b5b07ce1/Untitled.png\" alt=\"Untitled\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class=\"line\">            sum += i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            sum -= nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>we can simply find the sum of 0 to n and take out the sum of the value of nums array</strong>. Time complexity is O(n) and space complexity is O(1). below code is the simplified form of above code</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            sum += i - nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/60f46f39-d0bd-4a3f-93a8-af0387677a12/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>calculate sum of array and take out helps sometimes</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    sum -= nums[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li>we can use math to reduce the space complexity</li>\n</ol>\n"},{"title":"230. Kth Smallest Element in a BST","catalog":true,"date":"2022-10-02T02:07:43.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- binary search tree\n- return *the* `kth` *smallest value*\n\n## Solve by hands first\n\n---\n\nIf we traverse in inorder (left → root → right) in binary search tree, it always find the smallest value first. Time complexity is O(n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    int c = 0, ans = 0;\n    \n    public int kthSmallest(TreeNode root, int k) {\n        c = k;\n        io(root);\n        return ans;\n    }\n    \n    private void io(TreeNode root) {\n        if(root.left != null) io(root.left);\n        if(--c == 0) {\n            ans = root.val;\n            return;\n        }\n        if(root.right != null) io(root.right);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/371dbcff-7b9e-493b-9e05-a0279fd1a414/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. inorder : left → root → right\n2. inorder with code\n    \n    ```java\n    private void io(Node root, int k) {\n    \tio(root.left, k);  // visit left node\n    \tk++;               // just handle value at current node\n    \tio(root.right, k); // visit right node\n    }\n    ```\n    \n3. **decrease target instead of increasing to target**\n","source":"_posts/230-Kth-Smallest-Element-in-a-BST.md","raw":"---\ntitle: \"230.\\_Kth Smallest Element in a BST\"\ncatalog: true\ndate: 2022-10-02 11:07:43\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- binary search tree\n- return *the* `kth` *smallest value*\n\n## Solve by hands first\n\n---\n\nIf we traverse in inorder (left → root → right) in binary search tree, it always find the smallest value first. Time complexity is O(n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    int c = 0, ans = 0;\n    \n    public int kthSmallest(TreeNode root, int k) {\n        c = k;\n        io(root);\n        return ans;\n    }\n    \n    private void io(TreeNode root) {\n        if(root.left != null) io(root.left);\n        if(--c == 0) {\n            ans = root.val;\n            return;\n        }\n        if(root.right != null) io(root.right);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/371dbcff-7b9e-493b-9e05-a0279fd1a414/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. inorder : left → root → right\n2. inorder with code\n    \n    ```java\n    private void io(Node root, int k) {\n    \tio(root.left, k);  // visit left node\n    \tk++;               // just handle value at current node\n    \tio(root.right, k); // visit right node\n    }\n    ```\n    \n3. **decrease target instead of increasing to target**\n","slug":"230-Kth-Smallest-Element-in-a-BST","published":1,"updated":"2022-10-02T02:07:57.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1a0015qkcc0sdypa8s","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>binary search tree</li>\n<li>return <em>the</em> <code>kth</code> <em>smallest value</em></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>If we traverse in inorder (left → root → right) in binary search tree, it always find the smallest value first. Time complexity is O(n)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        c = k;</span><br><span class=\"line\">        io(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">io</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left != <span class=\"keyword\">null</span>) io(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(--c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ans = root.val;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.right != <span class=\"keyword\">null</span>) io(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/371dbcff-7b9e-493b-9e05-a0279fd1a414/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>inorder : left → root → right</p>\n</li>\n<li>\n<p>inorder with code</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">io</span><span class=\"params\">(Node root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">\tio(root.left, k);  <span class=\"comment\">// visit left node</span></span><br><span class=\"line\">\tk++;               <span class=\"comment\">// just handle value at current node</span></span><br><span class=\"line\">\tio(root.right, k); <span class=\"comment\">// visit right node</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li><strong>decrease target instead of increasing to target</strong></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>binary search tree</li>\n<li>return <em>the</em> <code>kth</code> <em>smallest value</em></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>If we traverse in inorder (left → root → right) in binary search tree, it always find the smallest value first. Time complexity is O(n)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        c = k;</span><br><span class=\"line\">        io(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">io</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left != <span class=\"keyword\">null</span>) io(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(--c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ans = root.val;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.right != <span class=\"keyword\">null</span>) io(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/371dbcff-7b9e-493b-9e05-a0279fd1a414/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>inorder : left → root → right</p>\n</li>\n<li>\n<p>inorder with code</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">io</span><span class=\"params\">(Node root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">\tio(root.left, k);  <span class=\"comment\">// visit left node</span></span><br><span class=\"line\">\tk++;               <span class=\"comment\">// just handle value at current node</span></span><br><span class=\"line\">\tio(root.right, k); <span class=\"comment\">// visit right node</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li><strong>decrease target instead of increasing to target</strong></li>\n</ol>\n"},{"title":"238. Product of Array Except Self","catalog":true,"date":"2022-09-30T11:33:02.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`\n- The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n- You must write an algorithm that runs in `O(n)` time and without using the division operation.\n\n## Solve by hands first\n\n---\n\nit can be simple math problem. create product of all elements of array and divide them in each element. \n\nbut how do it handle 0?\n\nAnother option is dynamic programming. each element has to know product of previous element from current index. calculate product of left element and calulate right element again.\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int len = nums.length;\n        int[] ans = new int[len];\n        \n        ans[0] = 1;\n        for(int i = 1; i < len; i++) {\n            ans[i] = ans[i - 1] * nums[i - 1];\n        }\n        \n        int pr = 1;\n        for(int i = len - 1; i >= 0; i--) {\n            ans[i] *= pr;\n            pr *= nums[i];\n        }\n        \n        return ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65d3250b-c5d0-4ca4-87c7-6c1d8d23b4ef/Untitled.png)\n\n![A99A29B8-77DD-4AFE-BCFB-54C35C0C3D02.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d97af286-acbb-41be-a466-f1dfbe27ba97/A99A29B8-77DD-4AFE-BCFB-54C35C0C3D02.jpeg)\n\n## Lesson I learnt\n\n---\n\n- product = multiplication\n","source":"_posts/238-Product-of-Array-Except-Self.md","raw":"---\ntitle: \"238.\\_Product of Array Except Self\"\ncatalog: true\ndate: 2022-09-30 20:33:02\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`\n- The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n- You must write an algorithm that runs in `O(n)` time and without using the division operation.\n\n## Solve by hands first\n\n---\n\nit can be simple math problem. create product of all elements of array and divide them in each element. \n\nbut how do it handle 0?\n\nAnother option is dynamic programming. each element has to know product of previous element from current index. calculate product of left element and calulate right element again.\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int len = nums.length;\n        int[] ans = new int[len];\n        \n        ans[0] = 1;\n        for(int i = 1; i < len; i++) {\n            ans[i] = ans[i - 1] * nums[i - 1];\n        }\n        \n        int pr = 1;\n        for(int i = len - 1; i >= 0; i--) {\n            ans[i] *= pr;\n            pr *= nums[i];\n        }\n        \n        return ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65d3250b-c5d0-4ca4-87c7-6c1d8d23b4ef/Untitled.png)\n\n![A99A29B8-77DD-4AFE-BCFB-54C35C0C3D02.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d97af286-acbb-41be-a466-f1dfbe27ba97/A99A29B8-77DD-4AFE-BCFB-54C35C0C3D02.jpeg)\n\n## Lesson I learnt\n\n---\n\n- product = multiplication\n","slug":"238-Product-of-Array-Except-Self","published":1,"updated":"2022-09-30T11:33:30.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1b0016qkccmijqcfsr","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li><code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code></li>\n<li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n<li>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>it can be simple math problem. create product of all elements of array and divide them in each element.</p>\n<p>but how do it handle 0?</p>\n<p>Another option is dynamic programming. each element has to know product of previous element from current index. calculate product of left element and calulate right element again.</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] productExceptSelf(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len];</span><br><span class=\"line\">        </span><br><span class=\"line\">        ans[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            ans[i] = ans[i - <span class=\"number\">1</span>] * nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> pr = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = len - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            ans[i] *= pr;</span><br><span class=\"line\">            pr *= nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65d3250b-c5d0-4ca4-87c7-6c1d8d23b4ef/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d97af286-acbb-41be-a466-f1dfbe27ba97/A99A29B8-77DD-4AFE-BCFB-54C35C0C3D02.jpeg\" alt=\"A99A29B8-77DD-4AFE-BCFB-54C35C0C3D02.jpeg\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ul>\n<li>product = multiplication</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li><code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code></li>\n<li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n<li>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>it can be simple math problem. create product of all elements of array and divide them in each element.</p>\n<p>but how do it handle 0?</p>\n<p>Another option is dynamic programming. each element has to know product of previous element from current index. calculate product of left element and calulate right element again.</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] productExceptSelf(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len];</span><br><span class=\"line\">        </span><br><span class=\"line\">        ans[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            ans[i] = ans[i - <span class=\"number\">1</span>] * nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> pr = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = len - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            ans[i] *= pr;</span><br><span class=\"line\">            pr *= nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65d3250b-c5d0-4ca4-87c7-6c1d8d23b4ef/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d97af286-acbb-41be-a466-f1dfbe27ba97/A99A29B8-77DD-4AFE-BCFB-54C35C0C3D02.jpeg\" alt=\"A99A29B8-77DD-4AFE-BCFB-54C35C0C3D02.jpeg\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ul>\n<li>product = multiplication</li>\n</ul>\n"},{"title":"236. Lowest Common Ancestor of a Binary Tree","catalog":true,"date":"2022-10-01T02:54:55.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- binary tree\n- find the lowest common ancestor (LCA) of two given nodes in the tree.\n- he lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants\n\n## Solve by hands first\n\n---\n\nUnlike lowest common ancestor of binary search tree question, we have to visit both of left and right childrent anyway. if we find the node then return otherwise should compare visited left and right node. there are two caes can be the lowest common ancestors\n\n1. both of child nodes are not null\n2. one of child is not null\n\n![1F161E1D-86B1-4D4F-A879-F48C16FE3DB0.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a3e6f65-4d61-4253-968f-d4e2700b59a4/1F161E1D-86B1-4D4F-A879-F48C16FE3DB0.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        \n        if(root == null) return null;\n        if(root == p || root == q) return root;\n        \n        TreeNode ln = lowestCommonAncestor(root.left, p, q);\n        TreeNode rn = lowestCommonAncestor(root.right, p, q);\n\n        if(ln != null && rn != null) return root;\n        return ln != null ? ln : rn;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/348363f5-19b4-44a8-9dc9-2c95fee12fc6/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. read the code carefully\n2. compare with reference of node\n    \n    ```java\n    root == p\n    ```\n    \n3. three part of tree traversal. **every things happens in the current node!**\n    1. enter the current node\n    2. visit child nodes\n    3. come back from child node\n    \n    ```java\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    \t\t\n    \t\t// 1. enter the current root      \n        if(root == null) return null;\n        if(root == p || root == q) return root;\n        \n    \t\t// 2. visit child nodes\n        TreeNode ln = lowestCommonAncestor(root.left, p, q);\n        TreeNode rn = lowestCommonAncestor(root.right, p, q);\n    \n    \t\t// 3. come back from child nodes\n        if(ln != null && rn != null) return root;\n        return ln != null ? ln : rn;\n    }\n    ```\n","source":"_posts/236-Lowest-Common-Ancestor-of-a-Binary-Tree.md","raw":"---\ntitle: \"236.\\_Lowest Common Ancestor of a Binary Tree\"\ncatalog: true\ndate: 2022-10-01 11:54:55\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- binary tree\n- find the lowest common ancestor (LCA) of two given nodes in the tree.\n- he lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants\n\n## Solve by hands first\n\n---\n\nUnlike lowest common ancestor of binary search tree question, we have to visit both of left and right childrent anyway. if we find the node then return otherwise should compare visited left and right node. there are two caes can be the lowest common ancestors\n\n1. both of child nodes are not null\n2. one of child is not null\n\n![1F161E1D-86B1-4D4F-A879-F48C16FE3DB0.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a3e6f65-4d61-4253-968f-d4e2700b59a4/1F161E1D-86B1-4D4F-A879-F48C16FE3DB0.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        \n        if(root == null) return null;\n        if(root == p || root == q) return root;\n        \n        TreeNode ln = lowestCommonAncestor(root.left, p, q);\n        TreeNode rn = lowestCommonAncestor(root.right, p, q);\n\n        if(ln != null && rn != null) return root;\n        return ln != null ? ln : rn;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/348363f5-19b4-44a8-9dc9-2c95fee12fc6/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. read the code carefully\n2. compare with reference of node\n    \n    ```java\n    root == p\n    ```\n    \n3. three part of tree traversal. **every things happens in the current node!**\n    1. enter the current node\n    2. visit child nodes\n    3. come back from child node\n    \n    ```java\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    \t\t\n    \t\t// 1. enter the current root      \n        if(root == null) return null;\n        if(root == p || root == q) return root;\n        \n    \t\t// 2. visit child nodes\n        TreeNode ln = lowestCommonAncestor(root.left, p, q);\n        TreeNode rn = lowestCommonAncestor(root.right, p, q);\n    \n    \t\t// 3. come back from child nodes\n        if(ln != null && rn != null) return root;\n        return ln != null ? ln : rn;\n    }\n    ```\n","slug":"236-Lowest-Common-Ancestor-of-a-Binary-Tree","published":1,"updated":"2022-10-01T02:55:09.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1b0017qkccvbqo18jw","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>binary tree</li>\n<li>find the lowest common ancestor (LCA) of two given nodes in the tree.</li>\n<li>he lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>Unlike lowest common ancestor of binary search tree question, we have to visit both of left and right childrent anyway. if we find the node then return otherwise should compare visited left and right node. there are two caes can be the lowest common ancestors</p>\n<ol>\n<li>both of child nodes are not null</li>\n<li>one of child is not null</li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a3e6f65-4d61-4253-968f-d4e2700b59a4/1F161E1D-86B1-4D4F-A879-F48C16FE3DB0.jpeg\" alt=\"1F161E1D-86B1-4D4F-A879-F48C16FE3DB0.jpeg\"></p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == p || root == q) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        TreeNode ln = lowestCommonAncestor(root.left, p, q);</span><br><span class=\"line\">        TreeNode rn = lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ln != <span class=\"keyword\">null</span> &amp;&amp; rn != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ln != <span class=\"keyword\">null</span> ? ln : rn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/348363f5-19b4-44a8-9dc9-2c95fee12fc6/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>read the code carefully</p>\n</li>\n<li>\n<p>compare with reference of node</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root == p</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>three part of tree traversal. <strong>every things happens in the current node!</strong></p>\n<ol>\n<li>enter the current node</li>\n<li>visit child nodes</li>\n<li>come back from child node</li>\n</ol>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 1. enter the current root      </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == p || root == q) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">// 2. visit child nodes</span></span><br><span class=\"line\">    TreeNode ln = lowestCommonAncestor(root.left, p, q);</span><br><span class=\"line\">    TreeNode rn = lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 3. come back from child nodes</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ln != <span class=\"keyword\">null</span> &amp;&amp; rn != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ln != <span class=\"keyword\">null</span> ? ln : rn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>binary tree</li>\n<li>find the lowest common ancestor (LCA) of two given nodes in the tree.</li>\n<li>he lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>Unlike lowest common ancestor of binary search tree question, we have to visit both of left and right childrent anyway. if we find the node then return otherwise should compare visited left and right node. there are two caes can be the lowest common ancestors</p>\n<ol>\n<li>both of child nodes are not null</li>\n<li>one of child is not null</li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a3e6f65-4d61-4253-968f-d4e2700b59a4/1F161E1D-86B1-4D4F-A879-F48C16FE3DB0.jpeg\" alt=\"1F161E1D-86B1-4D4F-A879-F48C16FE3DB0.jpeg\"></p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == p || root == q) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        TreeNode ln = lowestCommonAncestor(root.left, p, q);</span><br><span class=\"line\">        TreeNode rn = lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ln != <span class=\"keyword\">null</span> &amp;&amp; rn != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ln != <span class=\"keyword\">null</span> ? ln : rn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/348363f5-19b4-44a8-9dc9-2c95fee12fc6/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>read the code carefully</p>\n</li>\n<li>\n<p>compare with reference of node</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root == p</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>three part of tree traversal. <strong>every things happens in the current node!</strong></p>\n<ol>\n<li>enter the current node</li>\n<li>visit child nodes</li>\n<li>come back from child node</li>\n</ol>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 1. enter the current root      </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == p || root == q) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">// 2. visit child nodes</span></span><br><span class=\"line\">    TreeNode ln = lowestCommonAncestor(root.left, p, q);</span><br><span class=\"line\">    TreeNode rn = lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 3. come back from child nodes</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ln != <span class=\"keyword\">null</span> &amp;&amp; rn != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ln != <span class=\"keyword\">null</span> ? ln : rn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"235. Lowest Common Ancestor of a Binary Search Tree","catalog":true,"date":"2022-09-25T13:52:27.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- Given a binary search tree (BST)\n- find the lowest common ancestor (LCA) node of two given nodes\n- The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants\n- we allow **a node to be a descendant of itself**\n- All `Node.val` are **unique**.\n- p != q\n\n## Solve by hands first\n\n---\n\nboth min, max value can be less or greater than current node’s value. then how do we split to left and right child node;\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        return dfs(root, Math.min(p.val, q.val), Math.max(p.val, q.val));\n    }\n    \n    private TreeNode dfs(TreeNode root, int min, int max) {\n        if(root == null) return null;\n        if(root.val < min && root.val < max) return dfs(root.right,  min,  max);\n        else if(root.val > min && root.val > max) return dfs(root.left,  min,  max);\n        else return root;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c29bf31-5abc-46b4-ba09-49ad38c69e6f/Untitled.png)\n\n```java\nclass Solution {\n    \n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        while(true) {\n            if(root.val < p.val && root.val < q.val) root = root.right;\n            else if(root.val > p.val && root.val > q.val) root = root.left;\n            else return root;\n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b1448a13-4070-48a4-b6e1-0cb7a6657fd1/Untitled.png)\n\n**if the value of node is greater than minimun and less than maximum, the node is the lowest common ancester**. otherwise it has to travel left or right until find the common ancester\n\n**it’s the question that you know the character/pattern of BST or not**. \n\n## Lesson I learnt\n\n---\n\n1. change input example with the given inputs\n2. I need to fully solve by hand first and the implement code by it! (it’s very important since I can review my thought afterall)\n3. use the `else if` and `else` statement activly when handle edge case\n    \n    ```java\n    if(root.val < p.val && root.val < q.val) root = root.right; // root.val is less than both min, max\n    else if(root.val > p.val && root.val  q.val) root = root.left; // root.val is greater than both min, max \n    else return root;\n    ```\n    \n4. **when split occur at certain node. that node will be the lowest common ancestor**\n    - for instance with given 2, 8. parent node 6 is greater than 2 and less than 8 which means it has to be splited.\n    - so whatever value is greater than minimun and less than maximum can be the lowest common ancester\n    - it doesn’t really matters how many child node it has to travel after\n    \n    ```java\n         6   \n       /   \\\n      2     8\n             \\ \n              10 \n    ```\n    \n    ```java\n    2 < 6 < 8\n    2 < 6 < 10\n    ```>\n","source":"_posts/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree.md","raw":"---\ntitle: \"235.\\_Lowest Common Ancestor of a Binary Search Tree\"\ncatalog: true\ndate: 2022-09-25 22:52:27\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- Given a binary search tree (BST)\n- find the lowest common ancestor (LCA) node of two given nodes\n- The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants\n- we allow **a node to be a descendant of itself**\n- All `Node.val` are **unique**.\n- p != q\n\n## Solve by hands first\n\n---\n\nboth min, max value can be less or greater than current node’s value. then how do we split to left and right child node;\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        return dfs(root, Math.min(p.val, q.val), Math.max(p.val, q.val));\n    }\n    \n    private TreeNode dfs(TreeNode root, int min, int max) {\n        if(root == null) return null;\n        if(root.val < min && root.val < max) return dfs(root.right,  min,  max);\n        else if(root.val > min && root.val > max) return dfs(root.left,  min,  max);\n        else return root;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c29bf31-5abc-46b4-ba09-49ad38c69e6f/Untitled.png)\n\n```java\nclass Solution {\n    \n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        while(true) {\n            if(root.val < p.val && root.val < q.val) root = root.right;\n            else if(root.val > p.val && root.val > q.val) root = root.left;\n            else return root;\n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b1448a13-4070-48a4-b6e1-0cb7a6657fd1/Untitled.png)\n\n**if the value of node is greater than minimun and less than maximum, the node is the lowest common ancester**. otherwise it has to travel left or right until find the common ancester\n\n**it’s the question that you know the character/pattern of BST or not**. \n\n## Lesson I learnt\n\n---\n\n1. change input example with the given inputs\n2. I need to fully solve by hand first and the implement code by it! (it’s very important since I can review my thought afterall)\n3. use the `else if` and `else` statement activly when handle edge case\n    \n    ```java\n    if(root.val < p.val && root.val < q.val) root = root.right; // root.val is less than both min, max\n    else if(root.val > p.val && root.val  q.val) root = root.left; // root.val is greater than both min, max \n    else return root;\n    ```\n    \n4. **when split occur at certain node. that node will be the lowest common ancestor**\n    - for instance with given 2, 8. parent node 6 is greater than 2 and less than 8 which means it has to be splited.\n    - so whatever value is greater than minimun and less than maximum can be the lowest common ancester\n    - it doesn’t really matters how many child node it has to travel after\n    \n    ```java\n         6   \n       /   \\\n      2     8\n             \\ \n              10 \n    ```\n    \n    ```java\n    2 < 6 < 8\n    2 < 6 < 10\n    ```>\n","slug":"235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree","published":1,"updated":"2022-09-25T13:52:43.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1b0018qkcc2f5c2y0u","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>Given a binary search tree (BST)</li>\n<li>find the lowest common ancestor (LCA) node of two given nodes</li>\n<li>The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants</li>\n<li>we allow <strong>a node to be a descendant of itself</strong></li>\n<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n<li>p != q</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>both min, max value can be less or greater than current node’s value. then how do we split to left and right child node;</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(root, Math.min(p.val, q.val), Math.max(p.val, q.val));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">dfs</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val &lt; min &amp;&amp; root.val &lt; max) <span class=\"keyword\">return</span> dfs(root.right,  min,  max);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(root.val &gt; min &amp;&amp; root.val &gt; max) <span class=\"keyword\">return</span> dfs(root.left,  min,  max);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c29bf31-5abc-46b4-ba09-49ad38c69e6f/Untitled.png\" alt=\"Untitled\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) root = root.right;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) root = root.left;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b1448a13-4070-48a4-b6e1-0cb7a6657fd1/Untitled.png\" alt=\"Untitled\"></p>\n<p><strong>if the value of node is greater than minimun and less than maximum, the node is the lowest common ancester</strong>. otherwise it has to travel left or right until find the common ancester</p>\n<p><strong>it’s the question that you know the character/pattern of BST or not</strong>.</p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>change input example with the given inputs</p>\n</li>\n<li>\n<p>I need to fully solve by hand first and the implement code by it! (it’s very important since I can review my thought afterall)</p>\n</li>\n<li>\n<p>use the <code>else if</code> and <code>else</code> statement activly when handle edge case</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) root = root.right; <span class=\"comment\">// root.val is less than both min, max</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(root.val &gt; p.val &amp;&amp; root.val  q.val) root = root.left; <span class=\"comment\">// root.val is greater than both min, max </span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">return</span> root;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p><strong>when split occur at certain node. that node will be the lowest common ancestor</strong></p>\n<ul>\n<li>for instance with given 2, 8. parent node 6 is greater than 2 and less than 8 which means it has to be splited.</li>\n<li>so whatever value is greater than minimun and less than maximum can be the lowest common ancester</li>\n<li>it doesn’t really matters how many child node it has to travel after</li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"number\">6</span>   </span><br><span class=\"line\"> /   \\</span><br><span class=\"line\"><span class=\"number\">2</span>     <span class=\"number\">8</span></span><br><span class=\"line\">       \\ </span><br><span class=\"line\">        <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>```java\n2 &lt; 6 &lt; 8\n2 &lt; 6 &lt; 10\n```&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>Given a binary search tree (BST)</li>\n<li>find the lowest common ancestor (LCA) node of two given nodes</li>\n<li>The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants</li>\n<li>we allow <strong>a node to be a descendant of itself</strong></li>\n<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n<li>p != q</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>both min, max value can be less or greater than current node’s value. then how do we split to left and right child node;</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(root, Math.min(p.val, q.val), Math.max(p.val, q.val));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">dfs</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val &lt; min &amp;&amp; root.val &lt; max) <span class=\"keyword\">return</span> dfs(root.right,  min,  max);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(root.val &gt; min &amp;&amp; root.val &gt; max) <span class=\"keyword\">return</span> dfs(root.left,  min,  max);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c29bf31-5abc-46b4-ba09-49ad38c69e6f/Untitled.png\" alt=\"Untitled\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) root = root.right;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) root = root.left;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b1448a13-4070-48a4-b6e1-0cb7a6657fd1/Untitled.png\" alt=\"Untitled\"></p>\n<p><strong>if the value of node is greater than minimun and less than maximum, the node is the lowest common ancester</strong>. otherwise it has to travel left or right until find the common ancester</p>\n<p><strong>it’s the question that you know the character/pattern of BST or not</strong>.</p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>change input example with the given inputs</p>\n</li>\n<li>\n<p>I need to fully solve by hand first and the implement code by it! (it’s very important since I can review my thought afterall)</p>\n</li>\n<li>\n<p>use the <code>else if</code> and <code>else</code> statement activly when handle edge case</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) root = root.right; <span class=\"comment\">// root.val is less than both min, max</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(root.val &gt; p.val &amp;&amp; root.val  q.val) root = root.left; <span class=\"comment\">// root.val is greater than both min, max </span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">return</span> root;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p><strong>when split occur at certain node. that node will be the lowest common ancestor</strong></p>\n<ul>\n<li>for instance with given 2, 8. parent node 6 is greater than 2 and less than 8 which means it has to be splited.</li>\n<li>so whatever value is greater than minimun and less than maximum can be the lowest common ancester</li>\n<li>it doesn’t really matters how many child node it has to travel after</li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"number\">6</span>   </span><br><span class=\"line\"> /   \\</span><br><span class=\"line\"><span class=\"number\">2</span>     <span class=\"number\">8</span></span><br><span class=\"line\">       \\ </span><br><span class=\"line\">        <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>```java\n2 &lt; 6 &lt; 8\n2 &lt; 6 &lt; 10\n```&gt;\n</code></pre>\n"},{"title":"3. Longest Substring Without Repeating Characters","catalog":true,"date":"2022-10-11T11:15:46.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- find the length of the **longest substring** without repeating characters.\n- `s` consists of English letters, digits, symbols and spaces.\n\n## Solve by hands first\n\n---\n\nThe goal is to find the maximum length of substring. we can iterate each position and compare with the max length.\n\nThe problem is how to find the maximum length. we can use the **sliding window**. Create the left and right pointer. Move the right pointer to the right in every iteration and store the character in string as key and position as value in HashMap. If the right pointer find the character stored in the HashMap then move the left pointer to right from the position of stored in HashMap. **It will keep updating the poistion of the same character to right**. \n\n![35E4038F-CE7F-4AED-A251-987BE48779AC.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/838202f4-9e6b-4896-b98f-14a8c54037ee/35E4038F-CE7F-4AED-A251-987BE48779AC.jpeg)\n\nThe key is that **we have to skip the left pointer to the duplicate position**. For instance “abcb” if the right pointer is last “b” and the left pointer at “a”, we have to skip left pointe to the poisition of stored “b” + 1. but **there is possibility moving left pointer to backward** **if the poisition of the stored value is way behind the current left pointer**.\n\n![3E8CD1AF-BB6A-4C2F-801E-F9B709F67873.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c61832ad-8d0a-48f4-b8a2-12771bdf594e/3E8CD1AF-BB6A-4C2F-801E-F9B709F67873.jpeg)\n\nTime complexity is O(n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> m = new HashMap();\n        int max = 0;\n        for(int l = 0, r = 0; r < s.length(); r++) {\n            if(m.containsKey(s.charAt(r))) {\n                l = Math.max(l, m.get(s.charAt(r)) + 1);\n            }\n            m.put(s.charAt(r), r);\n            max = Math.max(max, r - l + 1);\n        }\n        \n        return max;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7fd4a9ca-1656-4dce-8803-4208fc5f83ec/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Storing character and position in HashMap and keep updating in every iteration\n\n```java\nfor(int l = 0, r = 0; r < s.length(); r++) {\n    m.puts.charAt(r), r);\n    max = Math.max(max, r - l + 1);\n}\n```\n\n1. Find the maximum left position since it will keep updating the position of duplicated characters (**current left position vs position of duplicated characters**)\n\n```java\nl = Math.max(l, m.get(s.charAt(r)) + 1);\n```(\n","source":"_posts/3-Longest-Substring-Without-Repeating-Characters.md","raw":"---\ntitle: \"3.\\_Longest Substring Without Repeating Characters\"\ncatalog: true\ndate: 2022-10-11 20:15:46\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- find the length of the **longest substring** without repeating characters.\n- `s` consists of English letters, digits, symbols and spaces.\n\n## Solve by hands first\n\n---\n\nThe goal is to find the maximum length of substring. we can iterate each position and compare with the max length.\n\nThe problem is how to find the maximum length. we can use the **sliding window**. Create the left and right pointer. Move the right pointer to the right in every iteration and store the character in string as key and position as value in HashMap. If the right pointer find the character stored in the HashMap then move the left pointer to right from the position of stored in HashMap. **It will keep updating the poistion of the same character to right**. \n\n![35E4038F-CE7F-4AED-A251-987BE48779AC.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/838202f4-9e6b-4896-b98f-14a8c54037ee/35E4038F-CE7F-4AED-A251-987BE48779AC.jpeg)\n\nThe key is that **we have to skip the left pointer to the duplicate position**. For instance “abcb” if the right pointer is last “b” and the left pointer at “a”, we have to skip left pointe to the poisition of stored “b” + 1. but **there is possibility moving left pointer to backward** **if the poisition of the stored value is way behind the current left pointer**.\n\n![3E8CD1AF-BB6A-4C2F-801E-F9B709F67873.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c61832ad-8d0a-48f4-b8a2-12771bdf594e/3E8CD1AF-BB6A-4C2F-801E-F9B709F67873.jpeg)\n\nTime complexity is O(n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> m = new HashMap();\n        int max = 0;\n        for(int l = 0, r = 0; r < s.length(); r++) {\n            if(m.containsKey(s.charAt(r))) {\n                l = Math.max(l, m.get(s.charAt(r)) + 1);\n            }\n            m.put(s.charAt(r), r);\n            max = Math.max(max, r - l + 1);\n        }\n        \n        return max;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7fd4a9ca-1656-4dce-8803-4208fc5f83ec/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Storing character and position in HashMap and keep updating in every iteration\n\n```java\nfor(int l = 0, r = 0; r < s.length(); r++) {\n    m.puts.charAt(r), r);\n    max = Math.max(max, r - l + 1);\n}\n```\n\n1. Find the maximum left position since it will keep updating the position of duplicated characters (**current left position vs position of duplicated characters**)\n\n```java\nl = Math.max(l, m.get(s.charAt(r)) + 1);\n```(\n","slug":"3-Longest-Substring-Without-Repeating-Characters","published":1,"updated":"2022-10-11T11:15:58.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1b0019qkccqdijx8pe","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>find the length of the <strong>longest substring</strong> without repeating characters.</li>\n<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>The goal is to find the maximum length of substring. we can iterate each position and compare with the max length.</p>\n<p>The problem is how to find the maximum length. we can use the <strong>sliding window</strong>. Create the left and right pointer. Move the right pointer to the right in every iteration and store the character in string as key and position as value in HashMap. If the right pointer find the character stored in the HashMap then move the left pointer to right from the position of stored in HashMap. <strong>It will keep updating the poistion of the same character to right</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/838202f4-9e6b-4896-b98f-14a8c54037ee/35E4038F-CE7F-4AED-A251-987BE48779AC.jpeg\" alt=\"35E4038F-CE7F-4AED-A251-987BE48779AC.jpeg\"></p>\n<p>The key is that <strong>we have to skip the left pointer to the duplicate position</strong>. For instance “abcb” if the right pointer is last “b” and the left pointer at “a”, we have to skip left pointe to the poisition of stored “b” + 1. but <strong>there is possibility moving left pointer to backward</strong> <strong>if the poisition of the stored value is way behind the current left pointer</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c61832ad-8d0a-48f4-b8a2-12771bdf594e/3E8CD1AF-BB6A-4C2F-801E-F9B709F67873.jpeg\" alt=\"3E8CD1AF-BB6A-4C2F-801E-F9B709F67873.jpeg\"></p>\n<p>Time complexity is O(n)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>; r &lt; s.length(); r++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m.containsKey(s.charAt(r))) &#123;</span><br><span class=\"line\">                l = Math.max(l, m.get(s.charAt(r)) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m.put(s.charAt(r), r);</span><br><span class=\"line\">            max = Math.max(max, r - l + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7fd4a9ca-1656-4dce-8803-4208fc5f83ec/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>Storing character and position in HashMap and keep updating in every iteration</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>; r &lt; s.length(); r++) &#123;</span><br><span class=\"line\">    m.puts.charAt(r), r);</span><br><span class=\"line\">    max = Math.max(max, r - l + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Find the maximum left position since it will keep updating the position of duplicated characters (<strong>current left position vs position of duplicated characters</strong>)</li>\n</ol>\n<pre><code class=\"language-java\">l = Math.max(l, m.get(s.charAt(r)) + 1);\n```(\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>find the length of the <strong>longest substring</strong> without repeating characters.</li>\n<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>The goal is to find the maximum length of substring. we can iterate each position and compare with the max length.</p>\n<p>The problem is how to find the maximum length. we can use the <strong>sliding window</strong>. Create the left and right pointer. Move the right pointer to the right in every iteration and store the character in string as key and position as value in HashMap. If the right pointer find the character stored in the HashMap then move the left pointer to right from the position of stored in HashMap. <strong>It will keep updating the poistion of the same character to right</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/838202f4-9e6b-4896-b98f-14a8c54037ee/35E4038F-CE7F-4AED-A251-987BE48779AC.jpeg\" alt=\"35E4038F-CE7F-4AED-A251-987BE48779AC.jpeg\"></p>\n<p>The key is that <strong>we have to skip the left pointer to the duplicate position</strong>. For instance “abcb” if the right pointer is last “b” and the left pointer at “a”, we have to skip left pointe to the poisition of stored “b” + 1. but <strong>there is possibility moving left pointer to backward</strong> <strong>if the poisition of the stored value is way behind the current left pointer</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c61832ad-8d0a-48f4-b8a2-12771bdf594e/3E8CD1AF-BB6A-4C2F-801E-F9B709F67873.jpeg\" alt=\"3E8CD1AF-BB6A-4C2F-801E-F9B709F67873.jpeg\"></p>\n<p>Time complexity is O(n)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>; r &lt; s.length(); r++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m.containsKey(s.charAt(r))) &#123;</span><br><span class=\"line\">                l = Math.max(l, m.get(s.charAt(r)) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m.put(s.charAt(r), r);</span><br><span class=\"line\">            max = Math.max(max, r - l + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7fd4a9ca-1656-4dce-8803-4208fc5f83ec/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>Storing character and position in HashMap and keep updating in every iteration</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>; r &lt; s.length(); r++) &#123;</span><br><span class=\"line\">    m.puts.charAt(r), r);</span><br><span class=\"line\">    max = Math.max(max, r - l + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Find the maximum left position since it will keep updating the position of duplicated characters (<strong>current left position vs position of duplicated characters</strong>)</li>\n</ol>\n<pre><code class=\"language-java\">l = Math.max(l, m.get(s.charAt(r)) + 1);\n```(\n</code></pre>\n"},{"title":"322. Coin Change","catalog":true,"date":"2022-09-30T10:29:01.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- Return *the fewest number of coins that you need to make up that amount*\n- You may assume that you have an infinite number of each kind of coin.\n\n## Solve by hands first\n\n---\n\nmost of permutation problem can be handled by Dynamic programming. \n\n## Solution\n\n---\n\n### bottom up\n\n```java\nclass Solution {\n    \n\n    Integer[] dp;\n    \n    public int coinChange(int[] coins, int amount) {\n        dp = new Integer[amount+1];\n        return dfs(coins, amount);\n    }\n    \n    private int dfs(int[] coins, int amount) {\n        \n        // condition at last node\n        if(amount < 0) return -1;\n        if(amount == 0) return 0;\n        \n        // minimum count at amount \n        if(dp[amount] != null) return dp[amount];\n        \n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < coins.length; i++) {\n            int count = dfs(coins, amount - coins[i]);\n            if(count >= 0) min = Math.min(c + 1, min);\n        }\n        \n        return dp[amount] = (min == Integer.MAX_VALUE) ? -1 : min;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/188c68b9-9bcc-4641-9f32-02c4b5873da7/Untitled.png)\n\nthe meaning of each element in `dp[x]` is that minimum combination when `x` amount left. for instance **dp[5] = 1, which mean when amount left 5 then there are only 1 combination to be amount = 0**. so in this question, what we want to know is number of combination to make amount 0, so we have to consider **all of the possibility from 0 to amount**.\n\n![72846EBD-1718-468F-A90A-5D623DC11E7D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d8a93ed8-e2b8-40b8-9402-5a40775beb1b/72846EBD-1718-468F-A90A-5D623DC11E7D.jpeg)\n\n### top down\n\n```java\nclass Solution {\n    \n    int[] dp;\n    \n    public int coinChange(int[] coins, int amount) {\n        dp = new int[amount + 1];\n        \n        int sum = 0;\n        while(++sum <= amount) {\n            \n            int min = -1;\n            for(int coin : coins) {          \n                // sum - coin < 0 : can't be 0 at current node\n                // dp[1] == -1 : there is no way to make 0 when 1 is left \n                if(sum - coin >= 0 && dp[sum - coin] != -1) {\n                    int tmp = dp[sum - coin] + 1;                    \n                    min = (min < 0) ? tmp : (tmp < min) ? tmp : min;\n                }\n            }    \n            dp[sum] = min;\n        }\n        \n        return dp[amount];\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d7ed11b-8ffc-4ffe-a147-ee1543ad58d7/Untitled.png)\n\n![16435737-A6CD-4AD8-8464-FD182778E0CE.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/22798aee-8143-4c89-9a3f-68a1c157a765/16435737-A6CD-4AD8-8464-FD182778E0CE.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. always define sub problem in dynamic programming\n2. **decide what to be the value of node**. in this case, remainer is value of node. **The value of node is mostly one of the method parameter**. \n    \n    ![96252388-D5CA-4291-82E9-A5380BA54248.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d9972b4c-e1f4-40ff-a714-562a4a1159e4/96252388-D5CA-4291-82E9-A5380BA54248.jpeg)\n    \n3. The return value of dynamic programming is what we want. but with memoization, it can also be the value at the node in momization array\n    \n    ```java\n    return dp[amount] = (min == Integer.MAX_VALUE) ? -1 : min;\n    ```\n    \n    - since we want to know the minimum number of combination. so return the **minimum number** and **memoization array**\n4. In dynamic programming, it’s important to decide **the value of node** and **return value**.\n5. utilize default value (ie. dp[0] = -1, dp[last index] = 0)\n6. understand elements of memoization array \n    - dp[1] = -1 means there is no way to make 0 when 1 is left\n7. in a nutshell\n    1. **define the value of node (ie. index)**\n    2. **define the return value (ie. sum)**\n    3. **define the element of memoization (ie. min value)**\n","source":"_posts/322-Coin-Change.md","raw":"---\ntitle: \"322.\\_Coin Change\"\ncatalog: true\ndate: 2022-09-30 19:29:01\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- Return *the fewest number of coins that you need to make up that amount*\n- You may assume that you have an infinite number of each kind of coin.\n\n## Solve by hands first\n\n---\n\nmost of permutation problem can be handled by Dynamic programming. \n\n## Solution\n\n---\n\n### bottom up\n\n```java\nclass Solution {\n    \n\n    Integer[] dp;\n    \n    public int coinChange(int[] coins, int amount) {\n        dp = new Integer[amount+1];\n        return dfs(coins, amount);\n    }\n    \n    private int dfs(int[] coins, int amount) {\n        \n        // condition at last node\n        if(amount < 0) return -1;\n        if(amount == 0) return 0;\n        \n        // minimum count at amount \n        if(dp[amount] != null) return dp[amount];\n        \n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < coins.length; i++) {\n            int count = dfs(coins, amount - coins[i]);\n            if(count >= 0) min = Math.min(c + 1, min);\n        }\n        \n        return dp[amount] = (min == Integer.MAX_VALUE) ? -1 : min;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/188c68b9-9bcc-4641-9f32-02c4b5873da7/Untitled.png)\n\nthe meaning of each element in `dp[x]` is that minimum combination when `x` amount left. for instance **dp[5] = 1, which mean when amount left 5 then there are only 1 combination to be amount = 0**. so in this question, what we want to know is number of combination to make amount 0, so we have to consider **all of the possibility from 0 to amount**.\n\n![72846EBD-1718-468F-A90A-5D623DC11E7D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d8a93ed8-e2b8-40b8-9402-5a40775beb1b/72846EBD-1718-468F-A90A-5D623DC11E7D.jpeg)\n\n### top down\n\n```java\nclass Solution {\n    \n    int[] dp;\n    \n    public int coinChange(int[] coins, int amount) {\n        dp = new int[amount + 1];\n        \n        int sum = 0;\n        while(++sum <= amount) {\n            \n            int min = -1;\n            for(int coin : coins) {          \n                // sum - coin < 0 : can't be 0 at current node\n                // dp[1] == -1 : there is no way to make 0 when 1 is left \n                if(sum - coin >= 0 && dp[sum - coin] != -1) {\n                    int tmp = dp[sum - coin] + 1;                    \n                    min = (min < 0) ? tmp : (tmp < min) ? tmp : min;\n                }\n            }    \n            dp[sum] = min;\n        }\n        \n        return dp[amount];\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d7ed11b-8ffc-4ffe-a147-ee1543ad58d7/Untitled.png)\n\n![16435737-A6CD-4AD8-8464-FD182778E0CE.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/22798aee-8143-4c89-9a3f-68a1c157a765/16435737-A6CD-4AD8-8464-FD182778E0CE.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. always define sub problem in dynamic programming\n2. **decide what to be the value of node**. in this case, remainer is value of node. **The value of node is mostly one of the method parameter**. \n    \n    ![96252388-D5CA-4291-82E9-A5380BA54248.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d9972b4c-e1f4-40ff-a714-562a4a1159e4/96252388-D5CA-4291-82E9-A5380BA54248.jpeg)\n    \n3. The return value of dynamic programming is what we want. but with memoization, it can also be the value at the node in momization array\n    \n    ```java\n    return dp[amount] = (min == Integer.MAX_VALUE) ? -1 : min;\n    ```\n    \n    - since we want to know the minimum number of combination. so return the **minimum number** and **memoization array**\n4. In dynamic programming, it’s important to decide **the value of node** and **return value**.\n5. utilize default value (ie. dp[0] = -1, dp[last index] = 0)\n6. understand elements of memoization array \n    - dp[1] = -1 means there is no way to make 0 when 1 is left\n7. in a nutshell\n    1. **define the value of node (ie. index)**\n    2. **define the return value (ie. sum)**\n    3. **define the element of memoization (ie. min value)**\n","slug":"322-Coin-Change","published":1,"updated":"2022-09-30T10:29:21.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1b001aqkccxk30tusf","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>Return <em>the fewest number of coins that you need to make up that amount</em></li>\n<li>You may assume that you have an infinite number of each kind of coin.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>most of permutation problem can be handled by Dynamic programming.</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<h3><span id=\"bottom-up\">bottom up</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    Integer[] dp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">coinChange</span><span class=\"params\">(<span class=\"keyword\">int</span>[] coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> Integer[amount+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(coins, amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// condition at last node</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(amount &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(amount == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// minimum count at amount </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[amount] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = dfs(coins, amount - coins[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(count &gt;= <span class=\"number\">0</span>) min = Math.min(c + <span class=\"number\">1</span>, min);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount] = (min == Integer.MAX_VALUE) ? -<span class=\"number\">1</span> : min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/188c68b9-9bcc-4641-9f32-02c4b5873da7/Untitled.png\" alt=\"Untitled\"></p>\n<p>the meaning of each element in <code>dp[x]</code> is that minimum combination when <code>x</code> amount left. for instance <strong>dp[5] = 1, which mean when amount left 5 then there are only 1 combination to be amount = 0</strong>. so in this question, what we want to know is number of combination to make amount 0, so we have to consider <strong>all of the possibility from 0 to amount</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d8a93ed8-e2b8-40b8-9402-5a40775beb1b/72846EBD-1718-468F-A90A-5D623DC11E7D.jpeg\" alt=\"72846EBD-1718-468F-A90A-5D623DC11E7D.jpeg\"></p>\n<h3><span id=\"top-down\">top down</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">coinChange</span><span class=\"params\">(<span class=\"keyword\">int</span>[] coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[amount + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(++sum &lt;= amount) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> coin : coins) &#123;          </span><br><span class=\"line\">                <span class=\"comment\">// sum - coin &lt; 0 : can't be 0 at current node</span></span><br><span class=\"line\">                <span class=\"comment\">// dp[1] == -1 : there is no way to make 0 when 1 is left </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(sum - coin &gt;= <span class=\"number\">0</span> &amp;&amp; dp[sum - coin] != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tmp = dp[sum - coin] + <span class=\"number\">1</span>;                    </span><br><span class=\"line\">                    min = (min &lt; <span class=\"number\">0</span>) ? tmp : (tmp &lt; min) ? tmp : min;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;    </span><br><span class=\"line\">            dp[sum] = min;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d7ed11b-8ffc-4ffe-a147-ee1543ad58d7/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/22798aee-8143-4c89-9a3f-68a1c157a765/16435737-A6CD-4AD8-8464-FD182778E0CE.jpeg\" alt=\"16435737-A6CD-4AD8-8464-FD182778E0CE.jpeg\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>always define sub problem in dynamic programming</p>\n</li>\n<li>\n<p><strong>decide what to be the value of node</strong>. in this case, remainer is value of node. <strong>The value of node is mostly one of the method parameter</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d9972b4c-e1f4-40ff-a714-562a4a1159e4/96252388-D5CA-4291-82E9-A5380BA54248.jpeg\" alt=\"96252388-D5CA-4291-82E9-A5380BA54248.jpeg\"></p>\n</li>\n<li>\n<p>The return value of dynamic programming is what we want. but with memoization, it can also be the value at the node in momization array</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> dp[amount] = (min == Integer.MAX_VALUE) ? -<span class=\"number\">1</span> : min;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>- since we want to know the minimum number of combination. so return the **minimum number** and **memoization array**\n</code></pre>\n<ol start=\"4\">\n<li>In dynamic programming, it’s important to decide <strong>the value of node</strong> and <strong>return value</strong>.</li>\n<li>utilize default value (ie. dp[0] = -1, dp[last index] = 0)</li>\n<li>understand elements of memoization array\n<ul>\n<li>dp[1] = -1 means there is no way to make 0 when 1 is left</li>\n</ul>\n</li>\n<li>in a nutshell\n<ol>\n<li><strong>define the value of node (ie. index)</strong></li>\n<li><strong>define the return value (ie. sum)</strong></li>\n<li><strong>define the element of memoization (ie. min value)</strong></li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>Return <em>the fewest number of coins that you need to make up that amount</em></li>\n<li>You may assume that you have an infinite number of each kind of coin.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>most of permutation problem can be handled by Dynamic programming.</p>\n<h2>Solution</h2>\n<hr>\n<h3>bottom up</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    Integer[] dp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">coinChange</span><span class=\"params\">(<span class=\"keyword\">int</span>[] coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> Integer[amount+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(coins, amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// condition at last node</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(amount &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(amount == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// minimum count at amount </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[amount] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = dfs(coins, amount - coins[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(count &gt;= <span class=\"number\">0</span>) min = Math.min(c + <span class=\"number\">1</span>, min);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount] = (min == Integer.MAX_VALUE) ? -<span class=\"number\">1</span> : min;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/188c68b9-9bcc-4641-9f32-02c4b5873da7/Untitled.png\" alt=\"Untitled\"></p>\n<p>the meaning of each element in <code>dp[x]</code> is that minimum combination when <code>x</code> amount left. for instance <strong>dp[5] = 1, which mean when amount left 5 then there are only 1 combination to be amount = 0</strong>. so in this question, what we want to know is number of combination to make amount 0, so we have to consider <strong>all of the possibility from 0 to amount</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d8a93ed8-e2b8-40b8-9402-5a40775beb1b/72846EBD-1718-468F-A90A-5D623DC11E7D.jpeg\" alt=\"72846EBD-1718-468F-A90A-5D623DC11E7D.jpeg\"></p>\n<h3>top down</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">coinChange</span><span class=\"params\">(<span class=\"keyword\">int</span>[] coins, <span class=\"keyword\">int</span> amount)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[amount + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(++sum &lt;= amount) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> coin : coins) &#123;          </span><br><span class=\"line\">                <span class=\"comment\">// sum - coin &lt; 0 : can't be 0 at current node</span></span><br><span class=\"line\">                <span class=\"comment\">// dp[1] == -1 : there is no way to make 0 when 1 is left </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(sum - coin &gt;= <span class=\"number\">0</span> &amp;&amp; dp[sum - coin] != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tmp = dp[sum - coin] + <span class=\"number\">1</span>;                    </span><br><span class=\"line\">                    min = (min &lt; <span class=\"number\">0</span>) ? tmp : (tmp &lt; min) ? tmp : min;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;    </span><br><span class=\"line\">            dp[sum] = min;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d7ed11b-8ffc-4ffe-a147-ee1543ad58d7/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/22798aee-8143-4c89-9a3f-68a1c157a765/16435737-A6CD-4AD8-8464-FD182778E0CE.jpeg\" alt=\"16435737-A6CD-4AD8-8464-FD182778E0CE.jpeg\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>always define sub problem in dynamic programming</p>\n</li>\n<li>\n<p><strong>decide what to be the value of node</strong>. in this case, remainer is value of node. <strong>The value of node is mostly one of the method parameter</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d9972b4c-e1f4-40ff-a714-562a4a1159e4/96252388-D5CA-4291-82E9-A5380BA54248.jpeg\" alt=\"96252388-D5CA-4291-82E9-A5380BA54248.jpeg\"></p>\n</li>\n<li>\n<p>The return value of dynamic programming is what we want. but with memoization, it can also be the value at the node in momization array</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> dp[amount] = (min == Integer.MAX_VALUE) ? -<span class=\"number\">1</span> : min;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>- since we want to know the minimum number of combination. so return the **minimum number** and **memoization array**\n</code></pre>\n<ol start=\"4\">\n<li>In dynamic programming, it’s important to decide <strong>the value of node</strong> and <strong>return value</strong>.</li>\n<li>utilize default value (ie. dp[0] = -1, dp[last index] = 0)</li>\n<li>understand elements of memoization array\n<ul>\n<li>dp[1] = -1 means there is no way to make 0 when 1 is left</li>\n</ul>\n</li>\n<li>in a nutshell\n<ol>\n<li><strong>define the value of node (ie. index)</strong></li>\n<li><strong>define the return value (ie. sum)</strong></li>\n<li><strong>define the element of memoization (ie. min value)</strong></li>\n</ol>\n</li>\n</ol>\n"},{"title":"300. Longest Increasing Subsequence","catalog":true,"date":"2022-10-20T13:08:47.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- return the length of the longest strictly increasing subsequence without changing order\n\n### **Edge cases**\n\n---\n\n- [] → 0\n- [1] → 1\n- [1,1,1,1,1] → 1\n- [10, 1, 3, 7, 5, 15, 100, 20] → [1, 3, 7, 15, 20] → 5\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nwe can use dynamic programming. Iterate throught every element in array. in the recursion, find the max length of increasing subsequence within remaining subarray. Once we find the max length then add 1 for current value. Base line is when the current index is the last index, then return 1 which means the last index value is part of the increasing subsequence. Time complexity is O(n^n) and space complexity is O(1)\n\n```java\npublic int lengthOfLIS(int[] nums) {\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++) {\n\t\t\tmax = Math.max(max, dfs(nums, i));\n\t\t}\n\t\treturn max;\n}\n\nprivate int dfs(int[] nums, int idx) {\n    if(idx >= nums.length - 1) return 1;\n\n    int max = 0;\n    for(int i = idx+1; i < nums.length; i++) {\n        if(nums[idx] >= nums[i]) continue;\n        max = Math.max(max, dfs(nums, i));\n    }\n    return max + 1;\n}\n```\n\n![6CFFFF82-C60B-4AAF-B7B2-925B7E9BA821.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c35b1406-6646-495e-b894-1b0dd34348e9/6CFFFF82-C60B-4AAF-B7B2-925B7E9BA821.jpeg)\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can optimize above solution with memoization. What we looking for is the maximum length at index 0. So we can store the maximum length at every index (which can be node in recursion). Time complexity is O(n^2)\n\n```java\nInteger[] dp;\n\npublic int lengthOfLIS(int[] nums) {\n\t\tdp = new Integer[nums.length];\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++) {\n\t\t\tmax = Math.max(max, dfs(nums, i));\n\t\t}\n\t\treturn max;\n}\n\nprivate int dfs(int[] nums, int idx) {\n    if(idx >= nums.length - 1) return 1;\n\t\tif(dp[idx] != null) return dp[idx];\n\n    int max = 0;\n    for(int i = idx+1; i < nums.length; i++) {\n        if(nums[idx] >= nums[i]) continue;\n        max = Math.max(max, dfs(nums, i));\n    }\n    return dp[idx] = max + 1;\n}\n```\n\n![2F761690-DFCF-4DC2-B1F7-71C4DA7D2002.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8ae39a7-d8fa-4895-80ea-81c7c14cc78a/2F761690-DFCF-4DC2-B1F7-71C4DA7D2002.jpeg)\n\nWe can also use top down approach. But it’s not easy to come up with the idea because elements in the dp array should as least have length of 1. because every element can be potentially belong to subsequence. So, we have to set 1 in dp array from the beginning. then we can start from top to bottom. from the last index decrease index to 0. and in the inner loop, iterate from outer index to last index to see previous index has larger subsequence or not. **If maxium length in any previous index can jump to current index, max length of previous index + 1 is the maximum length of increasing subsequence at current index**. So, **we can simple replace the max length at current index to max length at any previous index + 1**. Time complexity is O(n^2) (a bit complicated explaination I will soon clear it up!)\n\n```java\nint[] dp = new int[nums.length];\nArrays.fill(dp,1);\nfor(int i = nums.length-1; i >= 0; i--) {\n\tfor(int j = i+1; j < nums.length-1; j++) {\n\t\tif(nums[i] >= nums[j]) continue;\n\t\tnums[i] = Math.max(nums[i], nums[j]+1);\n\t}\n}\nArrays.sort(dp);\nreturn dp[nums.length-1];\n```\n\n![84BD3CE9-BC72-499C-931E-18B06AEC1A54.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ca128783-4d01-49ee-8d3c-5b4b5e4d93cb/84BD3CE9-BC72-499C-931E-18B06AEC1A54.jpeg)\n\n### **Coding**\n\n---\n\n```java\nInteger[] dp;\n\npublic int lengthOfLIS(int[] nums) {\n\t\tdp = new Integer[nums.length];\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++) {\n\t\t\tmax = Math.max(max, dfs(nums, i));\n\t\t}\n\t\treturn max;\n}\n\nprivate int dfs(int[] nums, int idx) {\n    if(idx >= nums.length - 1) return 1;\n\t\tif(dp[idx] != null) return dp[idx];\n\n    int max = 0;\n    for(int i = idx+1; i < nums.length; i++) {\n        if(nums[idx] >= nums[i]) continue;\n        max = Math.max(max, dfs(nums, i));\n    }\n    return dp[idx] = max + 1;\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/008e57f7-4349-4c81-9412-49cbe54f3404/Untitled.png)\n\n### What I learned\n\n---\n\n1. dynamic programing program can be greedy by any chance\n2. There is [O(nlog(n)) approach](https://leetcode.com/problems/longest-increasing-subsequence/discuss/1326308/C%2B%2BPython-DP-Binary-Search-BIT-Solutions-Picture-explain-O(NlogN)) as well \n3. Important to know what represent node and return in dp \n4. In top down dynamic programing, it start from the last index to 0. check with the next value and if it’s greater than current element then compare the length of current longest subsequence at current index and the length of previous longest subsequence. the point is **compare the cached value at current index to next index and updated the cached array at current index**\n\n```java\nfor(int i = nums.length-1; i >= 0; i--) {\n    for(int j = i+1; j < nums.length; j++) {\n        if(nums[i] >= nums[j]) continue;\n\n\t\t\t\t// cached array at current index vs next index + 1 and update cached value at current index to whichever max value\n        df[i] = Math.max(df[i], df[j]+1); \n    }\n}\n```\n","source":"_posts/300-Longest-Increasing-Subsequence.md","raw":"---\ntitle: \"300.\\_Longest Increasing Subsequence\"\ncatalog: true\ndate: 2022-10-20 22:08:47\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- return the length of the longest strictly increasing subsequence without changing order\n\n### **Edge cases**\n\n---\n\n- [] → 0\n- [1] → 1\n- [1,1,1,1,1] → 1\n- [10, 1, 3, 7, 5, 15, 100, 20] → [1, 3, 7, 15, 20] → 5\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nwe can use dynamic programming. Iterate throught every element in array. in the recursion, find the max length of increasing subsequence within remaining subarray. Once we find the max length then add 1 for current value. Base line is when the current index is the last index, then return 1 which means the last index value is part of the increasing subsequence. Time complexity is O(n^n) and space complexity is O(1)\n\n```java\npublic int lengthOfLIS(int[] nums) {\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++) {\n\t\t\tmax = Math.max(max, dfs(nums, i));\n\t\t}\n\t\treturn max;\n}\n\nprivate int dfs(int[] nums, int idx) {\n    if(idx >= nums.length - 1) return 1;\n\n    int max = 0;\n    for(int i = idx+1; i < nums.length; i++) {\n        if(nums[idx] >= nums[i]) continue;\n        max = Math.max(max, dfs(nums, i));\n    }\n    return max + 1;\n}\n```\n\n![6CFFFF82-C60B-4AAF-B7B2-925B7E9BA821.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c35b1406-6646-495e-b894-1b0dd34348e9/6CFFFF82-C60B-4AAF-B7B2-925B7E9BA821.jpeg)\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can optimize above solution with memoization. What we looking for is the maximum length at index 0. So we can store the maximum length at every index (which can be node in recursion). Time complexity is O(n^2)\n\n```java\nInteger[] dp;\n\npublic int lengthOfLIS(int[] nums) {\n\t\tdp = new Integer[nums.length];\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++) {\n\t\t\tmax = Math.max(max, dfs(nums, i));\n\t\t}\n\t\treturn max;\n}\n\nprivate int dfs(int[] nums, int idx) {\n    if(idx >= nums.length - 1) return 1;\n\t\tif(dp[idx] != null) return dp[idx];\n\n    int max = 0;\n    for(int i = idx+1; i < nums.length; i++) {\n        if(nums[idx] >= nums[i]) continue;\n        max = Math.max(max, dfs(nums, i));\n    }\n    return dp[idx] = max + 1;\n}\n```\n\n![2F761690-DFCF-4DC2-B1F7-71C4DA7D2002.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8ae39a7-d8fa-4895-80ea-81c7c14cc78a/2F761690-DFCF-4DC2-B1F7-71C4DA7D2002.jpeg)\n\nWe can also use top down approach. But it’s not easy to come up with the idea because elements in the dp array should as least have length of 1. because every element can be potentially belong to subsequence. So, we have to set 1 in dp array from the beginning. then we can start from top to bottom. from the last index decrease index to 0. and in the inner loop, iterate from outer index to last index to see previous index has larger subsequence or not. **If maxium length in any previous index can jump to current index, max length of previous index + 1 is the maximum length of increasing subsequence at current index**. So, **we can simple replace the max length at current index to max length at any previous index + 1**. Time complexity is O(n^2) (a bit complicated explaination I will soon clear it up!)\n\n```java\nint[] dp = new int[nums.length];\nArrays.fill(dp,1);\nfor(int i = nums.length-1; i >= 0; i--) {\n\tfor(int j = i+1; j < nums.length-1; j++) {\n\t\tif(nums[i] >= nums[j]) continue;\n\t\tnums[i] = Math.max(nums[i], nums[j]+1);\n\t}\n}\nArrays.sort(dp);\nreturn dp[nums.length-1];\n```\n\n![84BD3CE9-BC72-499C-931E-18B06AEC1A54.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ca128783-4d01-49ee-8d3c-5b4b5e4d93cb/84BD3CE9-BC72-499C-931E-18B06AEC1A54.jpeg)\n\n### **Coding**\n\n---\n\n```java\nInteger[] dp;\n\npublic int lengthOfLIS(int[] nums) {\n\t\tdp = new Integer[nums.length];\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++) {\n\t\t\tmax = Math.max(max, dfs(nums, i));\n\t\t}\n\t\treturn max;\n}\n\nprivate int dfs(int[] nums, int idx) {\n    if(idx >= nums.length - 1) return 1;\n\t\tif(dp[idx] != null) return dp[idx];\n\n    int max = 0;\n    for(int i = idx+1; i < nums.length; i++) {\n        if(nums[idx] >= nums[i]) continue;\n        max = Math.max(max, dfs(nums, i));\n    }\n    return dp[idx] = max + 1;\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/008e57f7-4349-4c81-9412-49cbe54f3404/Untitled.png)\n\n### What I learned\n\n---\n\n1. dynamic programing program can be greedy by any chance\n2. There is [O(nlog(n)) approach](https://leetcode.com/problems/longest-increasing-subsequence/discuss/1326308/C%2B%2BPython-DP-Binary-Search-BIT-Solutions-Picture-explain-O(NlogN)) as well \n3. Important to know what represent node and return in dp \n4. In top down dynamic programing, it start from the last index to 0. check with the next value and if it’s greater than current element then compare the length of current longest subsequence at current index and the length of previous longest subsequence. the point is **compare the cached value at current index to next index and updated the cached array at current index**\n\n```java\nfor(int i = nums.length-1; i >= 0; i--) {\n    for(int j = i+1; j < nums.length; j++) {\n        if(nums[i] >= nums[j]) continue;\n\n\t\t\t\t// cached array at current index vs next index + 1 and update cached value at current index to whichever max value\n        df[i] = Math.max(df[i], df[j]+1); \n    }\n}\n```\n","slug":"300-Longest-Increasing-Subsequence","published":1,"updated":"2022-10-20T13:09:01.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1c001bqkcci1ra74g1","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>return the length of the longest strictly increasing subsequence without changing order</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>[] → 0</li>\n<li>[1] → 1</li>\n<li>[1,1,1,1,1] → 1</li>\n<li>[10, 1, 3, 7, 5, 15, 100, 20] → [1, 3, 7, 15, 20] → 5</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>we can use dynamic programming. Iterate throught every element in array. in the recursion, find the max length of increasing subsequence within remaining subarray. Once we find the max length then add 1 for current value. Base line is when the current index is the last index, then return 1 which means the last index value is part of the increasing subsequence. Time complexity is O(n^n) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">\t\t\tmax = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(idx &gt;= nums.length - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = idx+<span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[idx] &gt;= nums[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        max = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c35b1406-6646-495e-b894-1b0dd34348e9/6CFFFF82-C60B-4AAF-B7B2-925B7E9BA821.jpeg\" alt=\"6CFFFF82-C60B-4AAF-B7B2-925B7E9BA821.jpeg\"></p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>We can optimize above solution with memoization. What we looking for is the maximum length at index 0. So we can store the maximum length at every index (which can be node in recursion). Time complexity is O(n^2)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] dp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">\t\tdp = <span class=\"keyword\">new</span> Integer[nums.length];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">\t\t\tmax = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(idx &gt;= nums.length - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(dp[idx] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = idx+<span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[idx] &gt;= nums[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        max = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[idx] = max + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8ae39a7-d8fa-4895-80ea-81c7c14cc78a/2F761690-DFCF-4DC2-B1F7-71C4DA7D2002.jpeg\" alt=\"2F761690-DFCF-4DC2-B1F7-71C4DA7D2002.jpeg\"></p>\n<p>We can also use top down approach. But it’s not easy to come up with the idea because elements in the dp array should as least have length of 1. because every element can be potentially belong to subsequence. So, we have to set 1 in dp array from the beginning. then we can start from top to bottom. from the last index decrease index to 0. and in the inner loop, iterate from outer index to last index to see previous index has larger subsequence or not. <strong>If maxium length in any previous index can jump to current index, max length of previous index + 1 is the maximum length of increasing subsequence at current index</strong>. So, <strong>we can simple replace the max length at current index to max length at any previous index + 1</strong>. Time complexity is O(n^2) (a bit complicated explaination I will soon clear it up!)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length];</span><br><span class=\"line\">Arrays.fill(dp,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nums.length-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; nums.length-<span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[i] &gt;= nums[j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tnums[i] = Math.max(nums[i], nums[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Arrays.sort(dp);</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[nums.length-<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ca128783-4d01-49ee-8d3c-5b4b5e4d93cb/84BD3CE9-BC72-499C-931E-18B06AEC1A54.jpeg\" alt=\"84BD3CE9-BC72-499C-931E-18B06AEC1A54.jpeg\"></p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] dp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">\t\tdp = <span class=\"keyword\">new</span> Integer[nums.length];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">\t\t\tmax = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(idx &gt;= nums.length - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(dp[idx] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = idx+<span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[idx] &gt;= nums[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        max = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[idx] = max + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/008e57f7-4349-4c81-9412-49cbe54f3404/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>dynamic programing program can be greedy by any chance</li>\n<li>There is <a href=\"https://leetcode.com/problems/longest-increasing-subsequence/discuss/1326308/C%2B%2BPython-DP-Binary-Search-BIT-Solutions-Picture-explain-O(NlogN)\" target=\"_blank\" rel=\"noopener\">O(nlog(n)) approach</a> as well</li>\n<li>Important to know what represent node and return in dp</li>\n<li>In top down dynamic programing, it start from the last index to 0. check with the next value and if it’s greater than current element then compare the length of current longest subsequence at current index and the length of previous longest subsequence. the point is <strong>compare the cached value at current index to next index and updated the cached array at current index</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nums.length-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[i] &gt;= nums[j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// cached array at current index vs next index + 1 and update cached value at current index to whichever max value</span></span><br><span class=\"line\">        df[i] = Math.max(df[i], df[j]+<span class=\"number\">1</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>return the length of the longest strictly increasing subsequence without changing order</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>[] → 0</li>\n<li>[1] → 1</li>\n<li>[1,1,1,1,1] → 1</li>\n<li>[10, 1, 3, 7, 5, 15, 100, 20] → [1, 3, 7, 15, 20] → 5</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>we can use dynamic programming. Iterate throught every element in array. in the recursion, find the max length of increasing subsequence within remaining subarray. Once we find the max length then add 1 for current value. Base line is when the current index is the last index, then return 1 which means the last index value is part of the increasing subsequence. Time complexity is O(n^n) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">\t\t\tmax = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(idx &gt;= nums.length - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = idx+<span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[idx] &gt;= nums[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        max = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c35b1406-6646-495e-b894-1b0dd34348e9/6CFFFF82-C60B-4AAF-B7B2-925B7E9BA821.jpeg\" alt=\"6CFFFF82-C60B-4AAF-B7B2-925B7E9BA821.jpeg\"></p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>We can optimize above solution with memoization. What we looking for is the maximum length at index 0. So we can store the maximum length at every index (which can be node in recursion). Time complexity is O(n^2)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] dp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">\t\tdp = <span class=\"keyword\">new</span> Integer[nums.length];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">\t\t\tmax = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(idx &gt;= nums.length - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(dp[idx] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = idx+<span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[idx] &gt;= nums[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        max = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[idx] = max + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8ae39a7-d8fa-4895-80ea-81c7c14cc78a/2F761690-DFCF-4DC2-B1F7-71C4DA7D2002.jpeg\" alt=\"2F761690-DFCF-4DC2-B1F7-71C4DA7D2002.jpeg\"></p>\n<p>We can also use top down approach. But it’s not easy to come up with the idea because elements in the dp array should as least have length of 1. because every element can be potentially belong to subsequence. So, we have to set 1 in dp array from the beginning. then we can start from top to bottom. from the last index decrease index to 0. and in the inner loop, iterate from outer index to last index to see previous index has larger subsequence or not. <strong>If maxium length in any previous index can jump to current index, max length of previous index + 1 is the maximum length of increasing subsequence at current index</strong>. So, <strong>we can simple replace the max length at current index to max length at any previous index + 1</strong>. Time complexity is O(n^2) (a bit complicated explaination I will soon clear it up!)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length];</span><br><span class=\"line\">Arrays.fill(dp,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nums.length-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; nums.length-<span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[i] &gt;= nums[j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tnums[i] = Math.max(nums[i], nums[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Arrays.sort(dp);</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[nums.length-<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ca128783-4d01-49ee-8d3c-5b4b5e4d93cb/84BD3CE9-BC72-499C-931E-18B06AEC1A54.jpeg\" alt=\"84BD3CE9-BC72-499C-931E-18B06AEC1A54.jpeg\"></p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] dp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">\t\tdp = <span class=\"keyword\">new</span> Integer[nums.length];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">\t\t\tmax = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(idx &gt;= nums.length - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(dp[idx] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = idx+<span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[idx] &gt;= nums[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        max = Math.max(max, dfs(nums, i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[idx] = max + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/008e57f7-4349-4c81-9412-49cbe54f3404/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>dynamic programing program can be greedy by any chance</li>\n<li>There is <a href=\"https://leetcode.com/problems/longest-increasing-subsequence/discuss/1326308/C%2B%2BPython-DP-Binary-Search-BIT-Solutions-Picture-explain-O(NlogN)\" target=\"_blank\" rel=\"noopener\">O(nlog(n)) approach</a> as well</li>\n<li>Important to know what represent node and return in dp</li>\n<li>In top down dynamic programing, it start from the last index to 0. check with the next value and if it’s greater than current element then compare the length of current longest subsequence at current index and the length of previous longest subsequence. the point is <strong>compare the cached value at current index to next index and updated the cached array at current index</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nums.length-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[i] &gt;= nums[j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// cached array at current index vs next index + 1 and update cached value at current index to whichever max value</span></span><br><span class=\"line\">        df[i] = Math.max(df[i], df[j]+<span class=\"number\">1</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"33. Search in Rotated Sorted Array","catalog":true,"date":"2022-10-16T03:46:56.000Z","subtitle":null,"header-img":null,"_content":"","source":"_posts/33-Search-in-Rotated-Sorted-Array-1.md","raw":"---\ntitle: \"33.\\_Search in Rotated Sorted Array\"\ncatalog: true\ndate: 2022-10-16 12:46:56\nsubtitle:\nheader-img:\ntags:\n---\n","slug":"33-Search-in-Rotated-Sorted-Array-1","published":1,"updated":"2022-10-16T03:46:56.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1c001cqkcc70kj8onn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"338. Counting Bits","catalog":true,"date":"2022-10-20T11:34:25.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- `ans[i]` *is the **number of*** `1`***'s** in the binary representation of* `i`\n- each element of ans arrays is the number of 1’s in the binary form of i. For instance i = 4 which is 100 in binary representation. So, ans[4] = 1 since there is only one 1 in 100.\n\n### **Edge cases**\n\n---\n\n- 1 → 0 → [0]\n- 2 → [1, 2] → [0, 10] → [0, 1]\n- 3 → [1, 2, 3] → [0, 10, 11] → [0, 1, 2]\n- 4 → [1, 2, 3, 4] → [0, 10, 11, 100] → [0, 1, 2, 1]\n- 11 → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] → [0, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010] → [0, 1, 2, 1, 2, 2, 3, 1, 2, 2]\n- pattern\n    - 1 : 1 → 1\n    - 2 : 10 11 → 1, 2\n    - 4 : 100 101 110 111 → 1, 2, 2, 3\n    - 8 : 1000 1001 1010 1011 1100 1101 1110 1111 → 1 2 2 3 2 3 3 4\n    - 16 : 10000\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nwe can loop through 1 to n. then count the number of i in each iteration. How to count the number of 1’s with number. we can use right shift and & operation. right shift each number and & operation with 1. If the binary is 0, it will return 0, otherwise return 1. Time complexity is O(nlog(n)) (Because shift operation is basically division equation. so n is divided by 2 every loop)\n\n```java\npublic int[] countBits(int n) {\n    int[] ans = new int[n+1];\n    for(int i = 0; i <= n; i++) {\n        ans[i] = count(i);\n    }\n    return ans;\n}\n\nprivate int count(int n) {\n    int count = 0;\n    while(n != 0) {\n        if((n & 1) == 1) count++;\n        n = n >> 1;\n    }\n    return count;\n}\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nTo optimize this solution we can find the pattern of bits. It always add 1 on significient bit and bits below have same patterns in preivous bits. Time complexity is O(n) and space complexity is O(n)\n\n```java\n0 : 0000 -> 0\n--------\n1 : 0001 -> 1 + dp[0] -> 1 + dp[1-1]\n--------\n2 : 0010 -> 1 + dp[0] -> 1 + dp[2-2]\n3 : 0011 -> 1 + dp[1] -> 1 + dp[3-2]\n--------\n4 : 0100 -> 1 + dp[0] -> 1 + dp[4-4]\n5 : 0101 -> 1 + dp[1] -> 1 + dp[5-4]\n6 : 0110 -> 1 + dp[2] -> 1 + dp[6-4]\n7 : 0111 -> 1 + dp[3] -> 1 + dp[7-4]\n--------\n8 : 1000 -> 1 + dp[0] -> 1 + dp[8-8]\n9 : 1001 -> 1 + dp[1] -> 1 + dp[9-8]\n--------\ndp[n] = 1 + dp[n - significient bit]\n```\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int[] countBits(int n) {\n        int[] ans = new int[n+1];\n        int sig = 1;\n        for(int i = 1; i <= n; i++) {\n            if(sig * 2 == i) sig = i;\n            ans[i] = 1 + ans[i - sig];\n        }\n        return ans;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c54dc06-bffd-4f2c-aa9e-dd44da6489cd/Untitled.png)\n\n### What I learned\n\n---\n\n1. significient bit = 1, 2, 4, 8 ..\n2. show the binary representation with 4 bits\n3. bits has patterns\n4. find the significient bits. it gradually increases twice.\n\n```java\nint sig = 1;\nfor(int i = 1; i <= n; i++) {\n\tif(sig * 2 == i) sig = i;\n}\n```\n","source":"_posts/338-Counting-Bits.md","raw":"---\ntitle: \"338.\\_Counting Bits\"\ncatalog: true\ndate: 2022-10-20 20:34:25\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- `ans[i]` *is the **number of*** `1`***'s** in the binary representation of* `i`\n- each element of ans arrays is the number of 1’s in the binary form of i. For instance i = 4 which is 100 in binary representation. So, ans[4] = 1 since there is only one 1 in 100.\n\n### **Edge cases**\n\n---\n\n- 1 → 0 → [0]\n- 2 → [1, 2] → [0, 10] → [0, 1]\n- 3 → [1, 2, 3] → [0, 10, 11] → [0, 1, 2]\n- 4 → [1, 2, 3, 4] → [0, 10, 11, 100] → [0, 1, 2, 1]\n- 11 → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] → [0, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010] → [0, 1, 2, 1, 2, 2, 3, 1, 2, 2]\n- pattern\n    - 1 : 1 → 1\n    - 2 : 10 11 → 1, 2\n    - 4 : 100 101 110 111 → 1, 2, 2, 3\n    - 8 : 1000 1001 1010 1011 1100 1101 1110 1111 → 1 2 2 3 2 3 3 4\n    - 16 : 10000\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nwe can loop through 1 to n. then count the number of i in each iteration. How to count the number of 1’s with number. we can use right shift and & operation. right shift each number and & operation with 1. If the binary is 0, it will return 0, otherwise return 1. Time complexity is O(nlog(n)) (Because shift operation is basically division equation. so n is divided by 2 every loop)\n\n```java\npublic int[] countBits(int n) {\n    int[] ans = new int[n+1];\n    for(int i = 0; i <= n; i++) {\n        ans[i] = count(i);\n    }\n    return ans;\n}\n\nprivate int count(int n) {\n    int count = 0;\n    while(n != 0) {\n        if((n & 1) == 1) count++;\n        n = n >> 1;\n    }\n    return count;\n}\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nTo optimize this solution we can find the pattern of bits. It always add 1 on significient bit and bits below have same patterns in preivous bits. Time complexity is O(n) and space complexity is O(n)\n\n```java\n0 : 0000 -> 0\n--------\n1 : 0001 -> 1 + dp[0] -> 1 + dp[1-1]\n--------\n2 : 0010 -> 1 + dp[0] -> 1 + dp[2-2]\n3 : 0011 -> 1 + dp[1] -> 1 + dp[3-2]\n--------\n4 : 0100 -> 1 + dp[0] -> 1 + dp[4-4]\n5 : 0101 -> 1 + dp[1] -> 1 + dp[5-4]\n6 : 0110 -> 1 + dp[2] -> 1 + dp[6-4]\n7 : 0111 -> 1 + dp[3] -> 1 + dp[7-4]\n--------\n8 : 1000 -> 1 + dp[0] -> 1 + dp[8-8]\n9 : 1001 -> 1 + dp[1] -> 1 + dp[9-8]\n--------\ndp[n] = 1 + dp[n - significient bit]\n```\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int[] countBits(int n) {\n        int[] ans = new int[n+1];\n        int sig = 1;\n        for(int i = 1; i <= n; i++) {\n            if(sig * 2 == i) sig = i;\n            ans[i] = 1 + ans[i - sig];\n        }\n        return ans;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c54dc06-bffd-4f2c-aa9e-dd44da6489cd/Untitled.png)\n\n### What I learned\n\n---\n\n1. significient bit = 1, 2, 4, 8 ..\n2. show the binary representation with 4 bits\n3. bits has patterns\n4. find the significient bits. it gradually increases twice.\n\n```java\nint sig = 1;\nfor(int i = 1; i <= n; i++) {\n\tif(sig * 2 == i) sig = i;\n}\n```\n","slug":"338-Counting-Bits","published":1,"updated":"2022-10-20T11:34:39.114Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1c001dqkccieujhst7","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li><code>ans[i]</code> <em>is the <strong>number of</strong></em> <code>1</code><em><strong>'s</strong> in the binary representation of</em> <code>i</code></li>\n<li>each element of ans arrays is the number of 1’s in the binary form of i. For instance i = 4 which is 100 in binary representation. So, ans[4] = 1 since there is only one 1 in 100.</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>1 → 0 → [0]</li>\n<li>2 → [1, 2] → [0, 10] → [0, 1]</li>\n<li>3 → [1, 2, 3] → [0, 10, 11] → [0, 1, 2]</li>\n<li>4 → [1, 2, 3, 4] → [0, 10, 11, 100] → [0, 1, 2, 1]</li>\n<li>11 → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] → [0, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010] → [0, 1, 2, 1, 2, 2, 3, 1, 2, 2]</li>\n<li>pattern\n<ul>\n<li>1 : 1 → 1</li>\n<li>2 : 10 11 → 1, 2</li>\n<li>4 : 100 101 110 111 → 1, 2, 2, 3</li>\n<li>8 : 1000 1001 1010 1011 1100 1101 1110 1111 → 1 2 2 3 2 3 3 4</li>\n<li>16 : 10000</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>we can loop through 1 to n. then count the number of i in each iteration. How to count the number of 1’s with number. we can use right shift and &amp; operation. right shift each number and &amp; operation with 1. If the binary is 0, it will return 0, otherwise return 1. Time complexity is O(nlog(n)) (Because shift operation is basically division equation. so n is divided by 2 every loop)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] countBits(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        ans[i] = count(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) count++;</span><br><span class=\"line\">        n = n &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>To optimize this solution we can find the pattern of bits. It always add 1 on significient bit and bits below have same patterns in preivous bits. Time complexity is O(n) and space complexity is O(n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> : <span class=\"number\">0000</span> -&gt; <span class=\"number\">0</span></span><br><span class=\"line\">--------</span><br><span class=\"line\"><span class=\"number\">1</span> : <span class=\"number\">0001</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">0</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">1</span>-<span class=\"number\">1</span>]</span><br><span class=\"line\">--------</span><br><span class=\"line\"><span class=\"number\">2</span> : <span class=\"number\">0010</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">0</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">2</span>-<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">3</span> : <span class=\"number\">0011</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">1</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">3</span>-<span class=\"number\">2</span>]</span><br><span class=\"line\">--------</span><br><span class=\"line\"><span class=\"number\">4</span> : <span class=\"number\">0100</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">0</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">4</span>-<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">5</span> : <span class=\"number\">0101</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">1</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">5</span>-<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">6</span> : <span class=\"number\">0110</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">2</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">6</span>-<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">7</span> : <span class=\"number\">0111</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">3</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">7</span>-<span class=\"number\">4</span>]</span><br><span class=\"line\">--------</span><br><span class=\"line\"><span class=\"number\">8</span> : <span class=\"number\">1000</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">0</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">8</span>-<span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"number\">9</span> : <span class=\"number\">1001</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">1</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">9</span>-<span class=\"number\">8</span>]</span><br><span class=\"line\">--------</span><br><span class=\"line\">dp[n] = <span class=\"number\">1</span> + dp[n - significient bit]</span><br></pre></td></tr></table></figure>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] countBits(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sig = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sig * <span class=\"number\">2</span> == i) sig = i;</span><br><span class=\"line\">            ans[i] = <span class=\"number\">1</span> + ans[i - sig];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c54dc06-bffd-4f2c-aa9e-dd44da6489cd/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>significient bit = 1, 2, 4, 8 …</li>\n<li>show the binary representation with 4 bits</li>\n<li>bits has patterns</li>\n<li>find the significient bits. it gradually increases twice.</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sig = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(sig * <span class=\"number\">2</span> == i) sig = i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li><code>ans[i]</code> <em>is the <strong>number of</strong></em> <code>1</code><em><strong>'s</strong> in the binary representation of</em> <code>i</code></li>\n<li>each element of ans arrays is the number of 1’s in the binary form of i. For instance i = 4 which is 100 in binary representation. So, ans[4] = 1 since there is only one 1 in 100.</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>1 → 0 → [0]</li>\n<li>2 → [1, 2] → [0, 10] → [0, 1]</li>\n<li>3 → [1, 2, 3] → [0, 10, 11] → [0, 1, 2]</li>\n<li>4 → [1, 2, 3, 4] → [0, 10, 11, 100] → [0, 1, 2, 1]</li>\n<li>11 → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] → [0, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010] → [0, 1, 2, 1, 2, 2, 3, 1, 2, 2]</li>\n<li>pattern\n<ul>\n<li>1 : 1 → 1</li>\n<li>2 : 10 11 → 1, 2</li>\n<li>4 : 100 101 110 111 → 1, 2, 2, 3</li>\n<li>8 : 1000 1001 1010 1011 1100 1101 1110 1111 → 1 2 2 3 2 3 3 4</li>\n<li>16 : 10000</li>\n</ul>\n</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>we can loop through 1 to n. then count the number of i in each iteration. How to count the number of 1’s with number. we can use right shift and &amp; operation. right shift each number and &amp; operation with 1. If the binary is 0, it will return 0, otherwise return 1. Time complexity is O(nlog(n)) (Because shift operation is basically division equation. so n is divided by 2 every loop)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] countBits(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        ans[i] = count(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) count++;</span><br><span class=\"line\">        n = n &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>To optimize this solution we can find the pattern of bits. It always add 1 on significient bit and bits below have same patterns in preivous bits. Time complexity is O(n) and space complexity is O(n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> : <span class=\"number\">0000</span> -&gt; <span class=\"number\">0</span></span><br><span class=\"line\">--------</span><br><span class=\"line\"><span class=\"number\">1</span> : <span class=\"number\">0001</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">0</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">1</span>-<span class=\"number\">1</span>]</span><br><span class=\"line\">--------</span><br><span class=\"line\"><span class=\"number\">2</span> : <span class=\"number\">0010</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">0</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">2</span>-<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">3</span> : <span class=\"number\">0011</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">1</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">3</span>-<span class=\"number\">2</span>]</span><br><span class=\"line\">--------</span><br><span class=\"line\"><span class=\"number\">4</span> : <span class=\"number\">0100</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">0</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">4</span>-<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">5</span> : <span class=\"number\">0101</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">1</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">5</span>-<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">6</span> : <span class=\"number\">0110</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">2</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">6</span>-<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">7</span> : <span class=\"number\">0111</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">3</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">7</span>-<span class=\"number\">4</span>]</span><br><span class=\"line\">--------</span><br><span class=\"line\"><span class=\"number\">8</span> : <span class=\"number\">1000</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">0</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">8</span>-<span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"number\">9</span> : <span class=\"number\">1001</span> -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">1</span>] -&gt; <span class=\"number\">1</span> + dp[<span class=\"number\">9</span>-<span class=\"number\">8</span>]</span><br><span class=\"line\">--------</span><br><span class=\"line\">dp[n] = <span class=\"number\">1</span> + dp[n - significient bit]</span><br></pre></td></tr></table></figure>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] countBits(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sig = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sig * <span class=\"number\">2</span> == i) sig = i;</span><br><span class=\"line\">            ans[i] = <span class=\"number\">1</span> + ans[i - sig];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c54dc06-bffd-4f2c-aa9e-dd44da6489cd/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>significient bit = 1, 2, 4, 8 …</li>\n<li>show the binary representation with 4 bits</li>\n<li>bits has patterns</li>\n<li>find the significient bits. it gradually increases twice.</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sig = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(sig * <span class=\"number\">2</span> == i) sig = i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"33. Search in Rotated Sorted Array","catalog":true,"date":"2022-09-09T05:24:29.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- integer array `nums` sorted in ascending order (with **distinct** values).\n- **possibly rotated** at an unknown pivot index `k`\n- return *the index of* `target` *if it is in* `nums`*, or* `-1` *if it is not in* `nums`\n- You must write an algorithm with `O(log n)` runtime complexity.\n\n### **Edge cases**\n\n---\n\n- [4,5,6,7,0,1,2], 0 → 4 (exist)\n- [4,5,6,7,0,1,2], 3 → -1 (non-exist)\n- [0], 1 → -1 (non-exist)\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nwe can’t use the brute force way because the quired runtime complexity is O(logn). binary search can be a good start for this problem since the array is already sorted.\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nwe can start with finding pivot index. Because left and right sub arrays are already sorted from the pivot. it makes easy to find the target value by using the binary search. so total time complexity is O(logn) + O(logn) + O(logn) = O(logn)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        \n        // nums = [4,5,6,7,0,1,2], target = 0\n        //         l     m     r            \n        // nums = [6,7,0,1,2,4,5], target = 0\n        //         l     m     r            \n        //         l m r\n        //             l\n        int l = 0, r = nums.length - 1;\n        while(l < r) {\n            int m = (l + r) / 2;\n            if(nums[m] > nums[r]) l = m + 1;\n            else r = m;\n        }\n        int p = l;\n\n        // left sub array\n        l = 0; r = p - 1;\n        while(l <= r) {\n            int m = (l + r) / 2;\n            if(nums[m] == target) return m;\n            else if(nums[m] > target) r = m - 1;\n            else l = m + 1;\n        }\n\n        // right sub array\n        l = p; r = nums.length - 1;\n        while(l <= r) {\n            int m = (l + r) / 2;\n            if(nums[m] == target) return m;\n            else if(nums[m] > target) r = m - 1;\n            else l = m + 1;\n        }\n        \n        return -1;\n        \n    }\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0147f6f2-df70-465f-b244-d9df82f34edf/Untitled.png)\n\n### What I learned\n\n---\n\n1. Don’t forget the equals comparison in a while loop to find the target\n\n```java\nwhile(l <= r)\n```\n\n1. mid point in even length of array\n    - in java, **the actual number will be truncated in *`int`* data type**\n\n```sql\n[1,2,3,4]\n\nint left = 0;\nint right = 3;\nint mid = left + (right - left) / 2;\n        = 0 + (3 - 0)/2\n        = 0 + 1.5\n        = 1\nint mid = (left + right) / 2;\n```\n\n1. condition in while loop \n    - In binary search, condition in while loop has to be `*left ≤ right*`, **if size of the array is one, then it happen to compare the same index**\n    - **The left and right index updated with +1 and -1** in order to meet the *`left ≤ right`* condition. otherwise it will stuck in while loop at certain point in time. for instance left = 1, right = 1\n    - ex) array = [1], left = 0, right = 0 → when left < right in while condition, it can’t go into the while loop since it does not meet the condition\n\n```java\nwhile(l <= r) {\n    int m = l + (r - l)/2;\n    if(nums[m] == target) {\n        return m;\n    } else if (nums[m] < target) {\n        l = m + 1;\n    } else {\n        r = m - 1;\n    }\n}\n```\n","source":"_posts/33-Search-in-Rotated-Sorted-Array.md","raw":"---\ntitle: \"33.\\_Search in Rotated Sorted Array\"\ncatalog: true\ndate: 2022-09-09 14:24:29\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- integer array `nums` sorted in ascending order (with **distinct** values).\n- **possibly rotated** at an unknown pivot index `k`\n- return *the index of* `target` *if it is in* `nums`*, or* `-1` *if it is not in* `nums`\n- You must write an algorithm with `O(log n)` runtime complexity.\n\n### **Edge cases**\n\n---\n\n- [4,5,6,7,0,1,2], 0 → 4 (exist)\n- [4,5,6,7,0,1,2], 3 → -1 (non-exist)\n- [0], 1 → -1 (non-exist)\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nwe can’t use the brute force way because the quired runtime complexity is O(logn). binary search can be a good start for this problem since the array is already sorted.\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nwe can start with finding pivot index. Because left and right sub arrays are already sorted from the pivot. it makes easy to find the target value by using the binary search. so total time complexity is O(logn) + O(logn) + O(logn) = O(logn)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        \n        // nums = [4,5,6,7,0,1,2], target = 0\n        //         l     m     r            \n        // nums = [6,7,0,1,2,4,5], target = 0\n        //         l     m     r            \n        //         l m r\n        //             l\n        int l = 0, r = nums.length - 1;\n        while(l < r) {\n            int m = (l + r) / 2;\n            if(nums[m] > nums[r]) l = m + 1;\n            else r = m;\n        }\n        int p = l;\n\n        // left sub array\n        l = 0; r = p - 1;\n        while(l <= r) {\n            int m = (l + r) / 2;\n            if(nums[m] == target) return m;\n            else if(nums[m] > target) r = m - 1;\n            else l = m + 1;\n        }\n\n        // right sub array\n        l = p; r = nums.length - 1;\n        while(l <= r) {\n            int m = (l + r) / 2;\n            if(nums[m] == target) return m;\n            else if(nums[m] > target) r = m - 1;\n            else l = m + 1;\n        }\n        \n        return -1;\n        \n    }\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0147f6f2-df70-465f-b244-d9df82f34edf/Untitled.png)\n\n### What I learned\n\n---\n\n1. Don’t forget the equals comparison in a while loop to find the target\n\n```java\nwhile(l <= r)\n```\n\n1. mid point in even length of array\n    - in java, **the actual number will be truncated in *`int`* data type**\n\n```sql\n[1,2,3,4]\n\nint left = 0;\nint right = 3;\nint mid = left + (right - left) / 2;\n        = 0 + (3 - 0)/2\n        = 0 + 1.5\n        = 1\nint mid = (left + right) / 2;\n```\n\n1. condition in while loop \n    - In binary search, condition in while loop has to be `*left ≤ right*`, **if size of the array is one, then it happen to compare the same index**\n    - **The left and right index updated with +1 and -1** in order to meet the *`left ≤ right`* condition. otherwise it will stuck in while loop at certain point in time. for instance left = 1, right = 1\n    - ex) array = [1], left = 0, right = 0 → when left < right in while condition, it can’t go into the while loop since it does not meet the condition\n\n```java\nwhile(l <= r) {\n    int m = l + (r - l)/2;\n    if(nums[m] == target) {\n        return m;\n    } else if (nums[m] < target) {\n        l = m + 1;\n    } else {\n        r = m - 1;\n    }\n}\n```\n","slug":"33-Search-in-Rotated-Sorted-Array","published":1,"updated":"2022-10-16T03:50:16.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1c001eqkccep05eip0","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</li>\n<li><strong>possibly rotated</strong> at an unknown pivot index <code>k</code></li>\n<li>return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code></li>\n<li>You must write an algorithm with <code>O(log n)</code> runtime complexity.</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>[4,5,6,7,0,1,2], 0 → 4 (exist)</li>\n<li>[4,5,6,7,0,1,2], 3 → -1 (non-exist)</li>\n<li>[0], 1 → -1 (non-exist)</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>we can’t use the brute force way because the quired runtime complexity is O(logn). binary search can be a good start for this problem since the array is already sorted.</p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>we can start with finding pivot index. Because left and right sub arrays are already sorted from the pivot. it makes easy to find the target value by using the binary search. so total time complexity is O(logn) + O(logn) + O(logn) = O(logn)</p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// nums = [4,5,6,7,0,1,2], target = 0</span></span><br><span class=\"line\">        <span class=\"comment\">//         l     m     r            </span></span><br><span class=\"line\">        <span class=\"comment\">// nums = [6,7,0,1,2,4,5], target = 0</span></span><br><span class=\"line\">        <span class=\"comment\">//         l     m     r            </span></span><br><span class=\"line\">        <span class=\"comment\">//         l m r</span></span><br><span class=\"line\">        <span class=\"comment\">//             l</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] &gt; nums[r]) l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> r = m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = l;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// left sub array</span></span><br><span class=\"line\">        l = <span class=\"number\">0</span>; r = p - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[m] &gt; target) r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// right sub array</span></span><br><span class=\"line\">        l = p; r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[m] &gt; target) r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0147f6f2-df70-465f-b244-d9df82f34edf/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>Don’t forget the equals comparison in a while loop to find the target</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(l &lt;= r)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>mid point in even length of array\n<ul>\n<li>in java, <strong>the actual number will be truncated in <em><code>int</code></em> data type</strong></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1,2,3,4]</span><br><span class=\"line\"></span><br><span class=\"line\">int left = 0;</span><br><span class=\"line\">int right = 3;</span><br><span class=\"line\">int mid = left + (right - left) / 2;</span><br><span class=\"line\">        = 0 + (3 - 0)/2</span><br><span class=\"line\">        = 0 + 1.5</span><br><span class=\"line\">        = 1</span><br><span class=\"line\">int mid = (left + right) / 2;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>condition in while loop\n<ul>\n<li>In binary search, condition in while loop has to be <code>*left ≤ right*</code>, <strong>if size of the array is one, then it happen to compare the same index</strong></li>\n<li><strong>The left and right index updated with +1 and -1</strong> in order to meet the <em><code>left ≤ right</code></em> condition. otherwise it will stuck in while loop at certain point in time. for instance left = 1, right = 1</li>\n<li>ex) array = [1], left = 0, right = 0 → when left &lt; right in while condition, it can’t go into the while loop since it does not meet the condition</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = l + (r - l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[m] == target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[m] &lt; target) &#123;</span><br><span class=\"line\">        l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</li>\n<li><strong>possibly rotated</strong> at an unknown pivot index <code>k</code></li>\n<li>return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code></li>\n<li>You must write an algorithm with <code>O(log n)</code> runtime complexity.</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>[4,5,6,7,0,1,2], 0 → 4 (exist)</li>\n<li>[4,5,6,7,0,1,2], 3 → -1 (non-exist)</li>\n<li>[0], 1 → -1 (non-exist)</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>we can’t use the brute force way because the quired runtime complexity is O(logn). binary search can be a good start for this problem since the array is already sorted.</p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>we can start with finding pivot index. Because left and right sub arrays are already sorted from the pivot. it makes easy to find the target value by using the binary search. so total time complexity is O(logn) + O(logn) + O(logn) = O(logn)</p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// nums = [4,5,6,7,0,1,2], target = 0</span></span><br><span class=\"line\">        <span class=\"comment\">//         l     m     r            </span></span><br><span class=\"line\">        <span class=\"comment\">// nums = [6,7,0,1,2,4,5], target = 0</span></span><br><span class=\"line\">        <span class=\"comment\">//         l     m     r            </span></span><br><span class=\"line\">        <span class=\"comment\">//         l m r</span></span><br><span class=\"line\">        <span class=\"comment\">//             l</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] &gt; nums[r]) l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> r = m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = l;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// left sub array</span></span><br><span class=\"line\">        l = <span class=\"number\">0</span>; r = p - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[m] &gt; target) r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// right sub array</span></span><br><span class=\"line\">        l = p; r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[m] &gt; target) r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0147f6f2-df70-465f-b244-d9df82f34edf/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>Don’t forget the equals comparison in a while loop to find the target</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(l &lt;= r)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>mid point in even length of array\n<ul>\n<li>in java, <strong>the actual number will be truncated in <em><code>int</code></em> data type</strong></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1,2,3,4]</span><br><span class=\"line\"></span><br><span class=\"line\">int left = 0;</span><br><span class=\"line\">int right = 3;</span><br><span class=\"line\">int mid = left + (right - left) / 2;</span><br><span class=\"line\">        = 0 + (3 - 0)/2</span><br><span class=\"line\">        = 0 + 1.5</span><br><span class=\"line\">        = 1</span><br><span class=\"line\">int mid = (left + right) / 2;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>condition in while loop\n<ul>\n<li>In binary search, condition in while loop has to be <code>*left ≤ right*</code>, <strong>if size of the array is one, then it happen to compare the same index</strong></li>\n<li><strong>The left and right index updated with +1 and -1</strong> in order to meet the <em><code>left ≤ right</code></em> condition. otherwise it will stuck in while loop at certain point in time. for instance left = 1, right = 1</li>\n<li>ex) array = [1], left = 0, right = 0 → when left &lt; right in while condition, it can’t go into the while loop since it does not meet the condition</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(l &lt;= r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = l + (r - l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[m] == target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[m] &lt; target) &#123;</span><br><span class=\"line\">        l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"347. Top K Frequent Elements","catalog":true,"date":"2022-09-27T11:43:30.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- return *the* `k` *most frequent elements*\n- return the answer in **any order**\n- It is **guaranteed** that the answer is **unique**.\n- Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.\n\n## Solve by hands first\n\n---\n\nwe can start with **Map**. iterate the number array and count the each value. store value as key and count as value in Map. Increase from 1 to input k and find the count of value at every increament. if we can sort by value, first element of map willl be the most frequent element. Time complexity is O(n) and space complexity is O(1)\n\nwe can use either **PriorityQueue** or TreeMap to sort by value yet still have to keep the key and value pair. since we use the Map, it’s easy to utilize the Map.Entry which has key and value\n\nproblem of using TreeMap is that we can order element by key but has to be unique. in this question, there is the duplicated most frequent element allowed. for instance [1,1,3,3] in this case. 1 and 3 both appears twice. so we can’t keep the both 1, 3 for key 2\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> m = new HashMap();\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> (b.getValue() - a.getValue()));\n        ArrayList<Integer> ans = new ArrayList();\n        \n        for(int n : nums) {\n            m.put(n, m.getOrDefault(n, 0) + 1);\n        }\n        \n        for(Map.Entry<Integer, Integer> e : m.entrySet()) {\n            pq.add(e);\n        }\n        \n        while(k-- > 0) {\n            ans.add(pq.poll().getKey());\n        }\n        \n        return ans.stream().mapToInt(i -> i).toArray();\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18e4a223-0b22-4719-ac9d-7f60430fd9ba/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. need to have more understanding of TreeMap and PriorityQueue in java\n2. PriorityQueue with Entry order by value\n    - Map.Entry is class only has key and value as\n    - if we want to order PriorityQueue by value in Map.Entry, **we can pass Comparable with lambda form to constructor parameter**\n    \n    ```java\n    PriorityQueue<Map.Entry<Integer, Integer>> pq = \n    \t\tnew PriorityQueue<> (b.getValue() - a.getValue()));\n    \n    ```>((a, b) -\n","source":"_posts/347-Top-K-Frequent-Elements.md","raw":"---\ntitle: \"347.\\_Top K Frequent Elements\"\ncatalog: true\ndate: 2022-09-27 20:43:30\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- return *the* `k` *most frequent elements*\n- return the answer in **any order**\n- It is **guaranteed** that the answer is **unique**.\n- Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.\n\n## Solve by hands first\n\n---\n\nwe can start with **Map**. iterate the number array and count the each value. store value as key and count as value in Map. Increase from 1 to input k and find the count of value at every increament. if we can sort by value, first element of map willl be the most frequent element. Time complexity is O(n) and space complexity is O(1)\n\nwe can use either **PriorityQueue** or TreeMap to sort by value yet still have to keep the key and value pair. since we use the Map, it’s easy to utilize the Map.Entry which has key and value\n\nproblem of using TreeMap is that we can order element by key but has to be unique. in this question, there is the duplicated most frequent element allowed. for instance [1,1,3,3] in this case. 1 and 3 both appears twice. so we can’t keep the both 1, 3 for key 2\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> m = new HashMap();\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> (b.getValue() - a.getValue()));\n        ArrayList<Integer> ans = new ArrayList();\n        \n        for(int n : nums) {\n            m.put(n, m.getOrDefault(n, 0) + 1);\n        }\n        \n        for(Map.Entry<Integer, Integer> e : m.entrySet()) {\n            pq.add(e);\n        }\n        \n        while(k-- > 0) {\n            ans.add(pq.poll().getKey());\n        }\n        \n        return ans.stream().mapToInt(i -> i).toArray();\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18e4a223-0b22-4719-ac9d-7f60430fd9ba/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. need to have more understanding of TreeMap and PriorityQueue in java\n2. PriorityQueue with Entry order by value\n    - Map.Entry is class only has key and value as\n    - if we want to order PriorityQueue by value in Map.Entry, **we can pass Comparable with lambda form to constructor parameter**\n    \n    ```java\n    PriorityQueue<Map.Entry<Integer, Integer>> pq = \n    \t\tnew PriorityQueue<> (b.getValue() - a.getValue()));\n    \n    ```>((a, b) -\n","slug":"347-Top-K-Frequent-Elements","published":1,"updated":"2022-09-27T11:43:45.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1c001fqkccdd9gfjgc","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>return <em>the</em> <code>k</code> <em>most frequent elements</em></li>\n<li>return the answer in <strong>any order</strong></li>\n<li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li>\n<li>Your algorithm’s time complexity must be better than <code>O(n log n)</code>, where n is the array’s size.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can start with <strong>Map</strong>. iterate the number array and count the each value. store value as key and count as value in Map. Increase from 1 to input k and find the count of value at every increament. if we can sort by value, first element of map willl be the most frequent element. Time complexity is O(n) and space complexity is O(1)</p>\n<p>we can use either <strong>PriorityQueue</strong> or TreeMap to sort by value yet still have to keep the key and value pair. since we use the Map, it’s easy to utilize the Map.Entry which has key and value</p>\n<p>problem of using TreeMap is that we can order element by key but has to be unique. in this question, there is the duplicated most frequent element allowed. for instance [1,1,3,3] in this case. 1 and 3 both appears twice. so we can’t keep the both 1, 3 for key 2</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] topKFrequent(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (b.getValue() - a.getValue()));</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">            m.put(n, m.getOrDefault(n, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Map.Entry&lt;Integer, Integer&gt; e : m.entrySet()) &#123;</span><br><span class=\"line\">            pq.add(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(k-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ans.add(pq.poll().getKey());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.stream().mapToInt(i -&gt; i).toArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18e4a223-0b22-4719-ac9d-7f60430fd9ba/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>need to have more understanding of TreeMap and PriorityQueue in java</p>\n</li>\n<li>\n<p>PriorityQueue with Entry order by value</p>\n<ul>\n<li>Map.Entry is class only has key and value as</li>\n<li>if we want to order PriorityQueue by value in Map.Entry, <strong>we can pass Comparable with lambda form to constructor parameter</strong></li>\n</ul>\n<pre><code class=\"language-java\">PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = \n\t\tnew PriorityQueue&lt;&gt; (b.getValue() - a.getValue()));\n\n```&gt;((a, b) -\n</code></pre>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>return <em>the</em> <code>k</code> <em>most frequent elements</em></li>\n<li>return the answer in <strong>any order</strong></li>\n<li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li>\n<li>Your algorithm’s time complexity must be better than <code>O(n log n)</code>, where n is the array’s size.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can start with <strong>Map</strong>. iterate the number array and count the each value. store value as key and count as value in Map. Increase from 1 to input k and find the count of value at every increament. if we can sort by value, first element of map willl be the most frequent element. Time complexity is O(n) and space complexity is O(1)</p>\n<p>we can use either <strong>PriorityQueue</strong> or TreeMap to sort by value yet still have to keep the key and value pair. since we use the Map, it’s easy to utilize the Map.Entry which has key and value</p>\n<p>problem of using TreeMap is that we can order element by key but has to be unique. in this question, there is the duplicated most frequent element allowed. for instance [1,1,3,3] in this case. 1 and 3 both appears twice. so we can’t keep the both 1, 3 for key 2</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] topKFrequent(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (b.getValue() - a.getValue()));</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">            m.put(n, m.getOrDefault(n, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Map.Entry&lt;Integer, Integer&gt; e : m.entrySet()) &#123;</span><br><span class=\"line\">            pq.add(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(k-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ans.add(pq.poll().getKey());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.stream().mapToInt(i -&gt; i).toArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18e4a223-0b22-4719-ac9d-7f60430fd9ba/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>need to have more understanding of TreeMap and PriorityQueue in java</p>\n</li>\n<li>\n<p>PriorityQueue with Entry order by value</p>\n<ul>\n<li>Map.Entry is class only has key and value as</li>\n<li>if we want to order PriorityQueue by value in Map.Entry, <strong>we can pass Comparable with lambda form to constructor parameter</strong></li>\n</ul>\n<pre><code class=\"language-java\">PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = \n\t\tnew PriorityQueue&lt;&gt; (b.getValue() - a.getValue()));\n\n```&gt;((a, b) -\n</code></pre>\n</li>\n</ol>\n"},{"title":"39. Combination Sum","catalog":true,"date":"2022-09-10T06:35:37.000Z","subtitle":null,"header-img":null,"_content":"\n## Conditions\n\n---\n\n- distinct integer array `candidate`\n- return list of all unique combination of `candidates` numbers sum to target in any order\n- The same number can be chosen from `candidates` an unlimited number of times\n- Gauaranteed that the number of unique combinatios is less than 150\n\n## Solve by hands first\n\n---\n\nWe can start from Brute Force. Time complexity will be O(nm). If we use DFS algorithm, time complexity can be O(logN). **The combination question can be handled by DFS algorithm**.\n\nhow to store the history of the array values when sum is equals to target in DFS?\n\n- create ArrayList and pass to method parameter\n- add the value into list and remove it if it doesn’t meet condition by Backtracking\n\n```java\nfor (int j = i; j < candi.length; j++) {\n    // add value in list and take out current value\n    sum += candi[j];\n    list.add(candi[j]);\n\n    dfs(j, target, candi, sum, list);\n    \n    // remove value in list and take out current value\n    list.remove(list.size()-1);\n    sum -= candi[j];\n}\n```\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    List<List<Integer>> ans = new ArrayList();\n    \n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        for(int i = 0; i < candidates.length; i++) {\n            dfs(i, target, candidates, 0, new ArrayList());\n        }\n        return ans;\n    }\n     \n    void dfs(int i, int target, int[] candi, int sum, List<Integer> list) {\n        \n        if(target < sum) {\n            return;\n        }\n        \n        if(target == sum) {\n            if(!ans.contains(list)) {\n                ans.add(new ArrayList(list));    \n            }\n            return;\n        }\n        \n        for (int j = i; j < candi.length; j++) {\n            // add value in list and take out current value\n            sum += candi[j];\n            list.add(candi[j]);\n\n            dfs(j, target, candi, sum, list);\n            \n            // remove value in list and take out current value\n            list.remove(list.size()-1);\n            sum -= candi[j];\n        }\n    } \n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/954e4c9f-17c6-4c35-bbf5-9afcf8873f11/Untitled.png)\n\n**is there any way to make it faster?**\n\n## Lesson I learnt\n\n---\n\n1. **Combination can be handle by DFS (or Backtracking If you needed)**\n    \n    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/829439ef-0239-43db-baab-f3172d354d7c/Untitled.png)\n    \n2. **Backtracking helps to initialize the value before and after**\n    \n    ```java\n    for (int j = i; j < candi.length; j++) {\n        // add value in list and take out current value\n        sum += candi[j];\n        list.add(candi[j]);\n    \n        dfs(j, target, candi, sum, list);\n        \n        // remove value in list and take out current value\n        list.remove(list.size()-1);\n        sum -= candi[j];\n    }\n    ```\n","source":"_posts/39-Combination-Sum.md","raw":"---\ntitle: \"39.\\_Combination Sum\"\ncatalog: true\ndate: 2022-09-10 15:35:37\nsubtitle:\nheader-img:\ntags:\n---\n\n## Conditions\n\n---\n\n- distinct integer array `candidate`\n- return list of all unique combination of `candidates` numbers sum to target in any order\n- The same number can be chosen from `candidates` an unlimited number of times\n- Gauaranteed that the number of unique combinatios is less than 150\n\n## Solve by hands first\n\n---\n\nWe can start from Brute Force. Time complexity will be O(nm). If we use DFS algorithm, time complexity can be O(logN). **The combination question can be handled by DFS algorithm**.\n\nhow to store the history of the array values when sum is equals to target in DFS?\n\n- create ArrayList and pass to method parameter\n- add the value into list and remove it if it doesn’t meet condition by Backtracking\n\n```java\nfor (int j = i; j < candi.length; j++) {\n    // add value in list and take out current value\n    sum += candi[j];\n    list.add(candi[j]);\n\n    dfs(j, target, candi, sum, list);\n    \n    // remove value in list and take out current value\n    list.remove(list.size()-1);\n    sum -= candi[j];\n}\n```\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    List<List<Integer>> ans = new ArrayList();\n    \n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        for(int i = 0; i < candidates.length; i++) {\n            dfs(i, target, candidates, 0, new ArrayList());\n        }\n        return ans;\n    }\n     \n    void dfs(int i, int target, int[] candi, int sum, List<Integer> list) {\n        \n        if(target < sum) {\n            return;\n        }\n        \n        if(target == sum) {\n            if(!ans.contains(list)) {\n                ans.add(new ArrayList(list));    \n            }\n            return;\n        }\n        \n        for (int j = i; j < candi.length; j++) {\n            // add value in list and take out current value\n            sum += candi[j];\n            list.add(candi[j]);\n\n            dfs(j, target, candi, sum, list);\n            \n            // remove value in list and take out current value\n            list.remove(list.size()-1);\n            sum -= candi[j];\n        }\n    } \n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/954e4c9f-17c6-4c35-bbf5-9afcf8873f11/Untitled.png)\n\n**is there any way to make it faster?**\n\n## Lesson I learnt\n\n---\n\n1. **Combination can be handle by DFS (or Backtracking If you needed)**\n    \n    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/829439ef-0239-43db-baab-f3172d354d7c/Untitled.png)\n    \n2. **Backtracking helps to initialize the value before and after**\n    \n    ```java\n    for (int j = i; j < candi.length; j++) {\n        // add value in list and take out current value\n        sum += candi[j];\n        list.add(candi[j]);\n    \n        dfs(j, target, candi, sum, list);\n        \n        // remove value in list and take out current value\n        list.remove(list.size()-1);\n        sum -= candi[j];\n    }\n    ```\n","slug":"39-Combination-Sum","published":1,"updated":"2022-09-10T06:36:23.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1d001gqkccr4ffbs6r","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>distinct integer array <code>candidate</code></li>\n<li>return list of all unique combination of <code>candidates</code> numbers sum to target in any order</li>\n<li>The same number can be chosen from <code>candidates</code> an unlimited number of times</li>\n<li>Gauaranteed that the number of unique combinatios is less than 150</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>We can start from Brute Force. Time complexity will be O(nm). If we use DFS algorithm, time complexity can be O(logN). <strong>The combination question can be handled by DFS algorithm</strong>.</p>\n<p>how to store the history of the array values when sum is equals to target in DFS?</p>\n<ul>\n<li>create ArrayList and pass to method parameter</li>\n<li>add the value into list and remove it if it doesn’t meet condition by Backtracking</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; candi.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// add value in list and take out current value</span></span><br><span class=\"line\">    sum += candi[j];</span><br><span class=\"line\">    list.add(candi[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(j, target, candi, sum, list);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// remove value in list and take out current value</span></span><br><span class=\"line\">    list.remove(list.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">    sum -= candi[j];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class=\"keyword\">int</span>[] candidates, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">            dfs(i, target, candidates, <span class=\"number\">0</span>, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> target, <span class=\"keyword\">int</span>[] candi, <span class=\"keyword\">int</span> sum, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target &lt; sum) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target == sum) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!ans.contains(list)) &#123;</span><br><span class=\"line\">                ans.add(<span class=\"keyword\">new</span> ArrayList(list));    </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; candi.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// add value in list and take out current value</span></span><br><span class=\"line\">            sum += candi[j];</span><br><span class=\"line\">            list.add(candi[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">            dfs(j, target, candi, sum, list);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// remove value in list and take out current value</span></span><br><span class=\"line\">            list.remove(list.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">            sum -= candi[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/954e4c9f-17c6-4c35-bbf5-9afcf8873f11/Untitled.png\" alt=\"Untitled\"></p>\n<p><strong>is there any way to make it faster?</strong></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p><strong>Combination can be handle by DFS (or Backtracking If you needed)</strong></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/829439ef-0239-43db-baab-f3172d354d7c/Untitled.png\" alt=\"Untitled\"></p>\n</li>\n<li>\n<p><strong>Backtracking helps to initialize the value before and after</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; candi.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// add value in list and take out current value</span></span><br><span class=\"line\">    sum += candi[j];</span><br><span class=\"line\">    list.add(candi[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(j, target, candi, sum, list);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// remove value in list and take out current value</span></span><br><span class=\"line\">    list.remove(list.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">    sum -= candi[j];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>distinct integer array <code>candidate</code></li>\n<li>return list of all unique combination of <code>candidates</code> numbers sum to target in any order</li>\n<li>The same number can be chosen from <code>candidates</code> an unlimited number of times</li>\n<li>Gauaranteed that the number of unique combinatios is less than 150</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>We can start from Brute Force. Time complexity will be O(nm). If we use DFS algorithm, time complexity can be O(logN). <strong>The combination question can be handled by DFS algorithm</strong>.</p>\n<p>how to store the history of the array values when sum is equals to target in DFS?</p>\n<ul>\n<li>create ArrayList and pass to method parameter</li>\n<li>add the value into list and remove it if it doesn’t meet condition by Backtracking</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; candi.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// add value in list and take out current value</span></span><br><span class=\"line\">    sum += candi[j];</span><br><span class=\"line\">    list.add(candi[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(j, target, candi, sum, list);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// remove value in list and take out current value</span></span><br><span class=\"line\">    list.remove(list.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">    sum -= candi[j];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class=\"keyword\">int</span>[] candidates, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">            dfs(i, target, candidates, <span class=\"number\">0</span>, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> target, <span class=\"keyword\">int</span>[] candi, <span class=\"keyword\">int</span> sum, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target &lt; sum) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target == sum) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!ans.contains(list)) &#123;</span><br><span class=\"line\">                ans.add(<span class=\"keyword\">new</span> ArrayList(list));    </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; candi.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// add value in list and take out current value</span></span><br><span class=\"line\">            sum += candi[j];</span><br><span class=\"line\">            list.add(candi[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">            dfs(j, target, candi, sum, list);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// remove value in list and take out current value</span></span><br><span class=\"line\">            list.remove(list.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">            sum -= candi[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/954e4c9f-17c6-4c35-bbf5-9afcf8873f11/Untitled.png\" alt=\"Untitled\"></p>\n<p><strong>is there any way to make it faster?</strong></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p><strong>Combination can be handle by DFS (or Backtracking If you needed)</strong></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/829439ef-0239-43db-baab-f3172d354d7c/Untitled.png\" alt=\"Untitled\"></p>\n</li>\n<li>\n<p><strong>Backtracking helps to initialize the value before and after</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; candi.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// add value in list and take out current value</span></span><br><span class=\"line\">    sum += candi[j];</span><br><span class=\"line\">    list.add(candi[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs(j, target, candi, sum, list);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// remove value in list and take out current value</span></span><br><span class=\"line\">    list.remove(list.size()-<span class=\"number\">1</span>);</span><br><span class=\"line\">    sum -= candi[j];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"424. Longest Repeating Character Replacement","catalog":true,"date":"2022-09-13T09:48:23.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- return the longest same letters after switch with any other letters\n\n## Solve by hands first\n\n---\n\n```java\nABABBA 1\n\nfind the possible sequence of letter to change?????\nA\nAB\nABA -> AAA\nABAB -> x : over two letters\nABABBA -> x : over two letters\n\nB\nB A -> BB\nB AB -> BBB\nB ABB -> BBBB\nB ABBA -> x\n\nfind the number of letter to switch is equals to k\ncalculate length of the same letters\n\n```\n\nI think we can start with **dynamic programing**. If you find the patterns it looks like sub problem can return the length of the same. then when it merge the parent problem then check if the letter of root problem is the frequent letter in sub problem. for instance, if the letters in sub problem is BAB then B is frequent letter. it goes back to root problem and its letter is B then increase the length or return 0 if it’s not the same\n\n## Solution\n\n---\n\nwe can use the **Sliding Window** instead of Brute Force and its time complexity will be O(n).\n\n```java\nclass Solution {\n    \n    // length - frequent <= k\n    public int characterReplacement(String s, int k) {\n        \n        int[] f = new int[26];\n        \n        int max = 0, mf = 0, l = 0, r = 0;\n        \n        for(; r < s.length(); r++) {\n            f[s.charAt(r) - 'A']++;\n            \n            int length = r - l + 1; // 0\n            mf = Math.max(mf, f[s.charAt(r)-'A']);  \n            \n            // move left index if frequent is greater than k\n            if(length - mf > k) {\n                f[s.charAt(l) - 'A']--;\n                l++;\n            }\n            \n            max = Math.max(max, r - l + 1);\n        }\n        \n        return max;\n    }\n}\n```\n\nNot to duplicate number of frequent letter. For instance, if the letter at index i = 0, j = 0 is ‘A’, it will point to the same letter but it will count 2 for letter ‘A’. **we can only increase right index to track the number of letters**\n\nValify the length of less frequent substring is less than k and increase the left index once. **Because it will decrease total length of window which is always less than max value**. So we don’t need to keep increasing and validating the size of window by for loop. \n\n## Lesson I learnt\n\n---\n\n1. Time complexity of sliding window\n2. `l` for left  index and `r` for right index\n3. I can only use one of index to check the value in array\n","source":"_posts/424-Longest-Repeating-Character-Replacement.md","raw":"---\ntitle: \"424.\\_Longest Repeating Character Replacement\"\ncatalog: true\ndate: 2022-09-13 18:48:23\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- return the longest same letters after switch with any other letters\n\n## Solve by hands first\n\n---\n\n```java\nABABBA 1\n\nfind the possible sequence of letter to change?????\nA\nAB\nABA -> AAA\nABAB -> x : over two letters\nABABBA -> x : over two letters\n\nB\nB A -> BB\nB AB -> BBB\nB ABB -> BBBB\nB ABBA -> x\n\nfind the number of letter to switch is equals to k\ncalculate length of the same letters\n\n```\n\nI think we can start with **dynamic programing**. If you find the patterns it looks like sub problem can return the length of the same. then when it merge the parent problem then check if the letter of root problem is the frequent letter in sub problem. for instance, if the letters in sub problem is BAB then B is frequent letter. it goes back to root problem and its letter is B then increase the length or return 0 if it’s not the same\n\n## Solution\n\n---\n\nwe can use the **Sliding Window** instead of Brute Force and its time complexity will be O(n).\n\n```java\nclass Solution {\n    \n    // length - frequent <= k\n    public int characterReplacement(String s, int k) {\n        \n        int[] f = new int[26];\n        \n        int max = 0, mf = 0, l = 0, r = 0;\n        \n        for(; r < s.length(); r++) {\n            f[s.charAt(r) - 'A']++;\n            \n            int length = r - l + 1; // 0\n            mf = Math.max(mf, f[s.charAt(r)-'A']);  \n            \n            // move left index if frequent is greater than k\n            if(length - mf > k) {\n                f[s.charAt(l) - 'A']--;\n                l++;\n            }\n            \n            max = Math.max(max, r - l + 1);\n        }\n        \n        return max;\n    }\n}\n```\n\nNot to duplicate number of frequent letter. For instance, if the letter at index i = 0, j = 0 is ‘A’, it will point to the same letter but it will count 2 for letter ‘A’. **we can only increase right index to track the number of letters**\n\nValify the length of less frequent substring is less than k and increase the left index once. **Because it will decrease total length of window which is always less than max value**. So we don’t need to keep increasing and validating the size of window by for loop. \n\n## Lesson I learnt\n\n---\n\n1. Time complexity of sliding window\n2. `l` for left  index and `r` for right index\n3. I can only use one of index to check the value in array\n","slug":"424-Longest-Repeating-Character-Replacement","published":1,"updated":"2022-09-13T09:49:03.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1d001hqkccg7sjnkt1","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>return the longest same letters after switch with any other letters</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ABABBA <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">find the possible sequence of letter to change?????</span><br><span class=\"line\">A</span><br><span class=\"line\">AB</span><br><span class=\"line\">ABA -&gt; AAA</span><br><span class=\"line\">ABAB -&gt; x : over two letters</span><br><span class=\"line\">ABABBA -&gt; x : over two letters</span><br><span class=\"line\"></span><br><span class=\"line\">B</span><br><span class=\"line\">B A -&gt; BB</span><br><span class=\"line\">B AB -&gt; BBB</span><br><span class=\"line\">B ABB -&gt; BBBB</span><br><span class=\"line\">B ABBA -&gt; x</span><br><span class=\"line\"></span><br><span class=\"line\">find the number of letter to <span class=\"keyword\">switch</span> is equals to k</span><br><span class=\"line\">calculate length of the same letters</span><br></pre></td></tr></table></figure>\n<p>I think we can start with <strong>dynamic programing</strong>. If you find the patterns it looks like sub problem can return the length of the same. then when it merge the parent problem then check if the letter of root problem is the frequent letter in sub problem. for instance, if the letters in sub problem is BAB then B is frequent letter. it goes back to root problem and its letter is B then increase the length or return 0 if it’s not the same</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<p>we can use the <strong>Sliding Window</strong> instead of Brute Force and its time complexity will be O(n).</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// length - frequent &lt;= k</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] f = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>, mf = <span class=\"number\">0</span>, l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; r &lt; s.length(); r++) &#123;</span><br><span class=\"line\">            f[s.charAt(r) - <span class=\"string\">'A'</span>]++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> length = r - l + <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\">            mf = Math.max(mf, f[s.charAt(r)-<span class=\"string\">'A'</span>]);  </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// move left index if frequent is greater than k</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(length - mf &gt; k) &#123;</span><br><span class=\"line\">                f[s.charAt(l) - <span class=\"string\">'A'</span>]--;</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            max = Math.max(max, r - l + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Not to duplicate number of frequent letter. For instance, if the letter at index i = 0, j = 0 is ‘A’, it will point to the same letter but it will count 2 for letter ‘A’. <strong>we can only increase right index to track the number of letters</strong></p>\n<p>Valify the length of less frequent substring is less than k and increase the left index once. <strong>Because it will decrease total length of window which is always less than max value</strong>. So we don’t need to keep increasing and validating the size of window by for loop.</p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>Time complexity of sliding window</li>\n<li><code>l</code> for left  index and <code>r</code> for right index</li>\n<li>I can only use one of index to check the value in array</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>return the longest same letters after switch with any other letters</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ABABBA <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">find the possible sequence of letter to change?????</span><br><span class=\"line\">A</span><br><span class=\"line\">AB</span><br><span class=\"line\">ABA -&gt; AAA</span><br><span class=\"line\">ABAB -&gt; x : over two letters</span><br><span class=\"line\">ABABBA -&gt; x : over two letters</span><br><span class=\"line\"></span><br><span class=\"line\">B</span><br><span class=\"line\">B A -&gt; BB</span><br><span class=\"line\">B AB -&gt; BBB</span><br><span class=\"line\">B ABB -&gt; BBBB</span><br><span class=\"line\">B ABBA -&gt; x</span><br><span class=\"line\"></span><br><span class=\"line\">find the number of letter to <span class=\"keyword\">switch</span> is equals to k</span><br><span class=\"line\">calculate length of the same letters</span><br></pre></td></tr></table></figure>\n<p>I think we can start with <strong>dynamic programing</strong>. If you find the patterns it looks like sub problem can return the length of the same. then when it merge the parent problem then check if the letter of root problem is the frequent letter in sub problem. for instance, if the letters in sub problem is BAB then B is frequent letter. it goes back to root problem and its letter is B then increase the length or return 0 if it’s not the same</p>\n<h2>Solution</h2>\n<hr>\n<p>we can use the <strong>Sliding Window</strong> instead of Brute Force and its time complexity will be O(n).</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// length - frequent &lt;= k</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] f = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>, mf = <span class=\"number\">0</span>, l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; r &lt; s.length(); r++) &#123;</span><br><span class=\"line\">            f[s.charAt(r) - <span class=\"string\">'A'</span>]++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> length = r - l + <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\">            mf = Math.max(mf, f[s.charAt(r)-<span class=\"string\">'A'</span>]);  </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// move left index if frequent is greater than k</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(length - mf &gt; k) &#123;</span><br><span class=\"line\">                f[s.charAt(l) - <span class=\"string\">'A'</span>]--;</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            max = Math.max(max, r - l + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Not to duplicate number of frequent letter. For instance, if the letter at index i = 0, j = 0 is ‘A’, it will point to the same letter but it will count 2 for letter ‘A’. <strong>we can only increase right index to track the number of letters</strong></p>\n<p>Valify the length of less frequent substring is less than k and increase the left index once. <strong>Because it will decrease total length of window which is always less than max value</strong>. So we don’t need to keep increasing and validating the size of window by for loop.</p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>Time complexity of sliding window</li>\n<li><code>l</code> for left  index and <code>r</code> for right index</li>\n<li>I can only use one of index to check the value in array</li>\n</ol>\n"},{"title":"412. Fizz Buzz","catalog":true,"date":"2022-11-01T10:02:48.000Z","subtitle":null,"header-img":null,"_content":"","source":"_posts/412-Fizz-Buzz.md","raw":"---\ntitle: \"412.\\_Fizz Buzz\"\ncatalog: true\ndate: 2022-11-01 19:02:48\nsubtitle:\nheader-img:\ntags:\n---\n","slug":"412-Fizz-Buzz","published":1,"updated":"2022-11-01T10:02:48.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1d001iqkccj8otewr5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"417. Pacific Atlantic Water Flow","catalog":true,"date":"2022-09-29T01:30:47.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- The **Pacific Ocean** touches the island's left and top edges\n- the **Atlantic Ocean** touches the island's right and bottom edges.\n- `heights[r][c]` represents the **height above sea level**\n- if the neighboring cell's height is **less than or equal to** the current cell's height\n- Return *a **2D list** of grid coordinates* `result` *where* `result[i] = [ri, ci]` *denotes that rain water can flow from cell* `(ri,ci)` *to **both** **the Pacific and Atlantic oceans***\n.\n\n## Solve by hands first\n\n---\n\nwe can start with DFS with every cells. constraint is that water only can run to **both the Pacific and Atlantic [oceans**.](http://oceans.so) so we have check water can reach to top left or bottom right. \n\nhow to compare the prev node value and current node value in DFS\n\n- we can just pass the current height as method parameter\n\nwe can have two visitor metrix to check which ocean the water flows to. pacific and atlantic. we don’t actually start with every single cells, instead we can travel back from the each ocean and check the cell visited if the water can flows from the visited cell in reverse way.\n\nthere are 4 possibilities\n\n1. [0,0] → [0, n] : cell enable to flows to pacific ocean\n2. [0,0] → [n, 0] : cell enable to flows to pacific ocean\n3. [n, n] → [0, n] : cell enable to flows to atlantic ocean\n4. [n, n] → [n, 0] : cell enable to flows to atlantic ocean\n\ncreate two boolean metrix to mark as visited depends on where the water flows from. if the water comes from Pacific ocean side, set true in pacific ocean boolean metric. after all traversal, we can simple iterate through each metrix and check both marked visited in pacific and atlantic metrix. store the coordination at both of metrix marked visited.\n\n![4BA68C9B-A2E0-496D-9250-508BC74BAC89.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/89a61c15-7689-4b25-b6b9-7990af240092/4BA68C9B-A2E0-496D-9250-508BC74BAC89.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    boolean[][] pm, am;\n    \n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        List<List<Integer>> ans = new ArrayList();\n        \n        pm = new boolean[heights.length][heights[0].length];\n        am = new boolean[heights.length][heights[0].length];\n        \n        int row = heights.length;\n        int col = heights[0].length;\n        \n        for(int r = 0; r < row; r++) {\n            dfs(heights, r, 0, heights[r][0], pm);\n            dfs(heights, r, col-1, heights[r][col-1], am);\n        }\n        \n        for(int c = 0; c < col; c++) {\n            dfs(heights, 0, c, heights[0][c], pm);\n            dfs(heights, row-1, c, heights[row-1][c], am);\n        }\n\n        for(int i = 0; i < row; i++) {\n            for(int j = 0; j < col; j++) {\n                if(am[i][j] && pm[i][j]) ans.add(Arrays.asList(i,j));\n            }\n        }\n        return ans;\n    }\n    \n    \n    private void dfs(int[][] heights, int i, int j, int prev, boolean[][] m) {\n        if(i < 0 || j < 0 || i >= heights.length || j >= heights[0].length || m[i][j]|| prev > heights[i][j]) return;\n    \n        m[i][j] = true;\n        dfs(heights, i+1, j, heights[i][j], m);\n        dfs(heights, i, j+1, heights[i][j], m);\n        dfs(heights, i-1, j, heights[i][j], m);\n        dfs(heights, i, j-1, heights[i][j], m);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc41c7ae-36fa-4523-9682-bc7ee9f1b396/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. thinking reverse way\n2. we can just visit every node with dfs and **mark visited in somewhere else (like cache)**.  in this case mostly we don’t need return value for dfs method.\n","source":"_posts/417-Pacific-Atlantic-Water-Flow.md","raw":"---\ntitle: \"417.\\_Pacific Atlantic Water Flow\"\ncatalog: true\ndate: 2022-09-29 10:30:47\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- The **Pacific Ocean** touches the island's left and top edges\n- the **Atlantic Ocean** touches the island's right and bottom edges.\n- `heights[r][c]` represents the **height above sea level**\n- if the neighboring cell's height is **less than or equal to** the current cell's height\n- Return *a **2D list** of grid coordinates* `result` *where* `result[i] = [ri, ci]` *denotes that rain water can flow from cell* `(ri,ci)` *to **both** **the Pacific and Atlantic oceans***\n.\n\n## Solve by hands first\n\n---\n\nwe can start with DFS with every cells. constraint is that water only can run to **both the Pacific and Atlantic [oceans**.](http://oceans.so) so we have check water can reach to top left or bottom right. \n\nhow to compare the prev node value and current node value in DFS\n\n- we can just pass the current height as method parameter\n\nwe can have two visitor metrix to check which ocean the water flows to. pacific and atlantic. we don’t actually start with every single cells, instead we can travel back from the each ocean and check the cell visited if the water can flows from the visited cell in reverse way.\n\nthere are 4 possibilities\n\n1. [0,0] → [0, n] : cell enable to flows to pacific ocean\n2. [0,0] → [n, 0] : cell enable to flows to pacific ocean\n3. [n, n] → [0, n] : cell enable to flows to atlantic ocean\n4. [n, n] → [n, 0] : cell enable to flows to atlantic ocean\n\ncreate two boolean metrix to mark as visited depends on where the water flows from. if the water comes from Pacific ocean side, set true in pacific ocean boolean metric. after all traversal, we can simple iterate through each metrix and check both marked visited in pacific and atlantic metrix. store the coordination at both of metrix marked visited.\n\n![4BA68C9B-A2E0-496D-9250-508BC74BAC89.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/89a61c15-7689-4b25-b6b9-7990af240092/4BA68C9B-A2E0-496D-9250-508BC74BAC89.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    boolean[][] pm, am;\n    \n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        List<List<Integer>> ans = new ArrayList();\n        \n        pm = new boolean[heights.length][heights[0].length];\n        am = new boolean[heights.length][heights[0].length];\n        \n        int row = heights.length;\n        int col = heights[0].length;\n        \n        for(int r = 0; r < row; r++) {\n            dfs(heights, r, 0, heights[r][0], pm);\n            dfs(heights, r, col-1, heights[r][col-1], am);\n        }\n        \n        for(int c = 0; c < col; c++) {\n            dfs(heights, 0, c, heights[0][c], pm);\n            dfs(heights, row-1, c, heights[row-1][c], am);\n        }\n\n        for(int i = 0; i < row; i++) {\n            for(int j = 0; j < col; j++) {\n                if(am[i][j] && pm[i][j]) ans.add(Arrays.asList(i,j));\n            }\n        }\n        return ans;\n    }\n    \n    \n    private void dfs(int[][] heights, int i, int j, int prev, boolean[][] m) {\n        if(i < 0 || j < 0 || i >= heights.length || j >= heights[0].length || m[i][j]|| prev > heights[i][j]) return;\n    \n        m[i][j] = true;\n        dfs(heights, i+1, j, heights[i][j], m);\n        dfs(heights, i, j+1, heights[i][j], m);\n        dfs(heights, i-1, j, heights[i][j], m);\n        dfs(heights, i, j-1, heights[i][j], m);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc41c7ae-36fa-4523-9682-bc7ee9f1b396/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. thinking reverse way\n2. we can just visit every node with dfs and **mark visited in somewhere else (like cache)**.  in this case mostly we don’t need return value for dfs method.\n","slug":"417-Pacific-Atlantic-Water-Flow","published":1,"updated":"2022-09-29T01:31:11.105Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1d001jqkccv2a4jrgm","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>The <strong>Pacific Ocean</strong> touches the island’s left and top edges</li>\n<li>the <strong>Atlantic Ocean</strong> touches the island’s right and bottom edges.</li>\n<li><code>heights[r][c]</code> represents the <strong>height above sea level</strong></li>\n<li>if the neighboring cell’s height is <strong>less than or equal to</strong> the current cell’s height</li>\n<li>Return <em>a <strong>2D list</strong> of grid coordinates</em> <code>result</code> <em>where</em> <code>result[i] = [ri, ci]</code> <em>denotes that rain water can flow from cell</em> <code>(ri,ci)</code> <em>to <strong>both</strong> <strong>the Pacific and Atlantic oceans</strong></em><br>\n.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can start with DFS with every cells. constraint is that water only can run to **both the Pacific and Atlantic <a href=\"http://oceans.so\" target=\"_blank\" rel=\"noopener\">oceans**.</a> so we have check water can reach to top left or bottom right.</p>\n<p>how to compare the prev node value and current node value in DFS</p>\n<ul>\n<li>we can just pass the current height as method parameter</li>\n</ul>\n<p>we can have two visitor metrix to check which ocean the water flows to. pacific and atlantic. we don’t actually start with every single cells, instead we can travel back from the each ocean and check the cell visited if the water can flows from the visited cell in reverse way.</p>\n<p>there are 4 possibilities</p>\n<ol>\n<li>[0,0] → [0, n] : cell enable to flows to pacific ocean</li>\n<li>[0,0] → [n, 0] : cell enable to flows to pacific ocean</li>\n<li>[n, n] → [0, n] : cell enable to flows to atlantic ocean</li>\n<li>[n, n] → [n, 0] : cell enable to flows to atlantic ocean</li>\n</ol>\n<p>create two boolean metrix to mark as visited depends on where the water flows from. if the water comes from Pacific ocean side, set true in pacific ocean boolean metric. after all traversal, we can simple iterate through each metrix and check both marked visited in pacific and atlantic metrix. store the coordination at both of metrix marked visited.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/89a61c15-7689-4b25-b6b9-7990af240092/4BA68C9B-A2E0-496D-9250-508BC74BAC89.jpeg\" alt=\"4BA68C9B-A2E0-496D-9250-508BC74BAC89.jpeg\"></p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span>[][] pm, am;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class=\"keyword\">int</span>[][] heights) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        </span><br><span class=\"line\">        pm = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[heights.length][heights[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        am = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[heights.length][heights[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> row = heights.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> col = heights[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> r = <span class=\"number\">0</span>; r &lt; row; r++) &#123;</span><br><span class=\"line\">            dfs(heights, r, <span class=\"number\">0</span>, heights[r][<span class=\"number\">0</span>], pm);</span><br><span class=\"line\">            dfs(heights, r, col-<span class=\"number\">1</span>, heights[r][col-<span class=\"number\">1</span>], am);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>; c &lt; col; c++) &#123;</span><br><span class=\"line\">            dfs(heights, <span class=\"number\">0</span>, c, heights[<span class=\"number\">0</span>][c], pm);</span><br><span class=\"line\">            dfs(heights, row-<span class=\"number\">1</span>, c, heights[row-<span class=\"number\">1</span>][c], am);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; row; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; col; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(am[i][j] &amp;&amp; pm[i][j]) ans.add(Arrays.asList(i,j));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] heights, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, <span class=\"keyword\">int</span> prev, <span class=\"keyword\">boolean</span>[][] m)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || j &lt; <span class=\"number\">0</span> || i &gt;= heights.length || j &gt;= heights[<span class=\"number\">0</span>].length || m[i][j]|| prev &gt; heights[i][j]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">        m[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        dfs(heights, i+<span class=\"number\">1</span>, j, heights[i][j], m);</span><br><span class=\"line\">        dfs(heights, i, j+<span class=\"number\">1</span>, heights[i][j], m);</span><br><span class=\"line\">        dfs(heights, i-<span class=\"number\">1</span>, j, heights[i][j], m);</span><br><span class=\"line\">        dfs(heights, i, j-<span class=\"number\">1</span>, heights[i][j], m);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc41c7ae-36fa-4523-9682-bc7ee9f1b396/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>thinking reverse way</li>\n<li>we can just visit every node with dfs and <strong>mark visited in somewhere else (like cache)</strong>.  in this case mostly we don’t need return value for dfs method.</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>The <strong>Pacific Ocean</strong> touches the island’s left and top edges</li>\n<li>the <strong>Atlantic Ocean</strong> touches the island’s right and bottom edges.</li>\n<li><code>heights[r][c]</code> represents the <strong>height above sea level</strong></li>\n<li>if the neighboring cell’s height is <strong>less than or equal to</strong> the current cell’s height</li>\n<li>Return <em>a <strong>2D list</strong> of grid coordinates</em> <code>result</code> <em>where</em> <code>result[i] = [ri, ci]</code> <em>denotes that rain water can flow from cell</em> <code>(ri,ci)</code> <em>to <strong>both</strong> <strong>the Pacific and Atlantic oceans</strong></em><br>\n.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can start with DFS with every cells. constraint is that water only can run to **both the Pacific and Atlantic <a href=\"http://oceans.so\" target=\"_blank\" rel=\"noopener\">oceans**.</a> so we have check water can reach to top left or bottom right.</p>\n<p>how to compare the prev node value and current node value in DFS</p>\n<ul>\n<li>we can just pass the current height as method parameter</li>\n</ul>\n<p>we can have two visitor metrix to check which ocean the water flows to. pacific and atlantic. we don’t actually start with every single cells, instead we can travel back from the each ocean and check the cell visited if the water can flows from the visited cell in reverse way.</p>\n<p>there are 4 possibilities</p>\n<ol>\n<li>[0,0] → [0, n] : cell enable to flows to pacific ocean</li>\n<li>[0,0] → [n, 0] : cell enable to flows to pacific ocean</li>\n<li>[n, n] → [0, n] : cell enable to flows to atlantic ocean</li>\n<li>[n, n] → [n, 0] : cell enable to flows to atlantic ocean</li>\n</ol>\n<p>create two boolean metrix to mark as visited depends on where the water flows from. if the water comes from Pacific ocean side, set true in pacific ocean boolean metric. after all traversal, we can simple iterate through each metrix and check both marked visited in pacific and atlantic metrix. store the coordination at both of metrix marked visited.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/89a61c15-7689-4b25-b6b9-7990af240092/4BA68C9B-A2E0-496D-9250-508BC74BAC89.jpeg\" alt=\"4BA68C9B-A2E0-496D-9250-508BC74BAC89.jpeg\"></p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span>[][] pm, am;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class=\"keyword\">int</span>[][] heights) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        </span><br><span class=\"line\">        pm = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[heights.length][heights[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        am = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[heights.length][heights[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> row = heights.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> col = heights[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> r = <span class=\"number\">0</span>; r &lt; row; r++) &#123;</span><br><span class=\"line\">            dfs(heights, r, <span class=\"number\">0</span>, heights[r][<span class=\"number\">0</span>], pm);</span><br><span class=\"line\">            dfs(heights, r, col-<span class=\"number\">1</span>, heights[r][col-<span class=\"number\">1</span>], am);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>; c &lt; col; c++) &#123;</span><br><span class=\"line\">            dfs(heights, <span class=\"number\">0</span>, c, heights[<span class=\"number\">0</span>][c], pm);</span><br><span class=\"line\">            dfs(heights, row-<span class=\"number\">1</span>, c, heights[row-<span class=\"number\">1</span>][c], am);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; row; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; col; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(am[i][j] &amp;&amp; pm[i][j]) ans.add(Arrays.asList(i,j));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] heights, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, <span class=\"keyword\">int</span> prev, <span class=\"keyword\">boolean</span>[][] m)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || j &lt; <span class=\"number\">0</span> || i &gt;= heights.length || j &gt;= heights[<span class=\"number\">0</span>].length || m[i][j]|| prev &gt; heights[i][j]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">        m[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        dfs(heights, i+<span class=\"number\">1</span>, j, heights[i][j], m);</span><br><span class=\"line\">        dfs(heights, i, j+<span class=\"number\">1</span>, heights[i][j], m);</span><br><span class=\"line\">        dfs(heights, i-<span class=\"number\">1</span>, j, heights[i][j], m);</span><br><span class=\"line\">        dfs(heights, i, j-<span class=\"number\">1</span>, heights[i][j], m);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc41c7ae-36fa-4523-9682-bc7ee9f1b396/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>thinking reverse way</li>\n<li>we can just visit every node with dfs and <strong>mark visited in somewhere else (like cache)</strong>.  in this case mostly we don’t need return value for dfs method.</li>\n</ol>\n"},{"title":"435. Non-overlapping Intervals","catalog":true,"date":"2022-09-28T11:50:15.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- return *the **minimum number** of intervals you need to remove to make the rest of the intervals non-overlapping*\n\n## Solve by hands first\n\n---\n\nThere are 3 steps to solve this problem\n\n1. sort array by the start point\n2. if current start point is greater than equals to previous end point, it’s not overlapped\n3. if it’s not, those intervals are overlapped\n    1. increase count\n    2. set previous end point to smaller end point from current or previous end point (Greedy)\n\nthe key is setting **previous end point to smaller value of current or previous end point**. which is greedy approach. if end point is smaller, there is higher chance to be less overlapped\n\nTime complexity is O(nlogN) which is for sorting array\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        \n        Arrays.sort(intervals, (i, j) -> i[0] - j[0]);\n        \n        int count = 0, pe = intervals[0][1];\n        for(int i = 1; i < intervals.length; i++) {\n            int s = intervals[i][0];\n            int e = intervals[i][1];\n            \n            if(s >= pe) pe = e;\n            else {\n                count++;\n                pe = Math.min(pe, e);\n            }\n        }\n        \n        return count;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/225f1bd2-8318-4d06-899e-da602c6eae67/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. drawing a picture for the complicated problem\n2. Greedy is the way that choose the best answer in every sub problem\n","source":"_posts/435-Non-overlapping-Intervals.md","raw":"---\ntitle: \"435.\\_Non-overlapping Intervals\"\ncatalog: true\ndate: 2022-09-28 20:50:15\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- return *the **minimum number** of intervals you need to remove to make the rest of the intervals non-overlapping*\n\n## Solve by hands first\n\n---\n\nThere are 3 steps to solve this problem\n\n1. sort array by the start point\n2. if current start point is greater than equals to previous end point, it’s not overlapped\n3. if it’s not, those intervals are overlapped\n    1. increase count\n    2. set previous end point to smaller end point from current or previous end point (Greedy)\n\nthe key is setting **previous end point to smaller value of current or previous end point**. which is greedy approach. if end point is smaller, there is higher chance to be less overlapped\n\nTime complexity is O(nlogN) which is for sorting array\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        \n        Arrays.sort(intervals, (i, j) -> i[0] - j[0]);\n        \n        int count = 0, pe = intervals[0][1];\n        for(int i = 1; i < intervals.length; i++) {\n            int s = intervals[i][0];\n            int e = intervals[i][1];\n            \n            if(s >= pe) pe = e;\n            else {\n                count++;\n                pe = Math.min(pe, e);\n            }\n        }\n        \n        return count;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/225f1bd2-8318-4d06-899e-da602c6eae67/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. drawing a picture for the complicated problem\n2. Greedy is the way that choose the best answer in every sub problem\n","slug":"435-Non-overlapping-Intervals","published":1,"updated":"2022-09-28T11:50:34.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1d001kqkcckw7vxu90","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>return <em>the <strong>minimum number</strong> of intervals you need to remove to make the rest of the intervals non-overlapping</em></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>There are 3 steps to solve this problem</p>\n<ol>\n<li>sort array by the start point</li>\n<li>if current start point is greater than equals to previous end point, it’s not overlapped</li>\n<li>if it’s not, those intervals are overlapped\n<ol>\n<li>increase count</li>\n<li>set previous end point to smaller end point from current or previous end point (Greedy)</li>\n</ol>\n</li>\n</ol>\n<p>the key is setting <strong>previous end point to smaller value of current or previous end point</strong>. which is greedy approach. if end point is smaller, there is higher chance to be less overlapped</p>\n<p>Time complexity is O(nlogN) which is for sorting array</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">eraseOverlapIntervals</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] intervals)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Arrays.sort(intervals, (i, j) -&gt; i[<span class=\"number\">0</span>] - j[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>, pe = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s = intervals[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> e = intervals[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s &gt;= pe) pe = e;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                pe = Math.min(pe, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/225f1bd2-8318-4d06-899e-da602c6eae67/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>drawing a picture for the complicated problem</li>\n<li>Greedy is the way that choose the best answer in every sub problem</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>return <em>the <strong>minimum number</strong> of intervals you need to remove to make the rest of the intervals non-overlapping</em></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>There are 3 steps to solve this problem</p>\n<ol>\n<li>sort array by the start point</li>\n<li>if current start point is greater than equals to previous end point, it’s not overlapped</li>\n<li>if it’s not, those intervals are overlapped\n<ol>\n<li>increase count</li>\n<li>set previous end point to smaller end point from current or previous end point (Greedy)</li>\n</ol>\n</li>\n</ol>\n<p>the key is setting <strong>previous end point to smaller value of current or previous end point</strong>. which is greedy approach. if end point is smaller, there is higher chance to be less overlapped</p>\n<p>Time complexity is O(nlogN) which is for sorting array</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">eraseOverlapIntervals</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] intervals)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Arrays.sort(intervals, (i, j) -&gt; i[<span class=\"number\">0</span>] - j[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>, pe = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s = intervals[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> e = intervals[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s &gt;= pe) pe = e;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                pe = Math.min(pe, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/225f1bd2-8318-4d06-899e-da602c6eae67/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>drawing a picture for the complicated problem</li>\n<li>Greedy is the way that choose the best answer in every sub problem</li>\n</ol>\n"},{"title":"46. Permutations","catalog":true,"date":"2022-10-31T12:47:32.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- Given array nums is distinct integers array\n- return all the possible permutations in any order\n- length of nums is less than equals to 6\n- value of nums is greater than equals to -10 and less than equals to 10\n\n### **Edge cases**\n\n---\n\n- [1,2,3] → [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nStart with Backtracking first. iterater each element in array. If current list contains value then skip. If current list contains any value in the array then move on. If the current list size is equals to length of nums, add list to answer list. when it returns remove the last value of current list.  TIme complexity is O(size of nums * size of nums * size of nums)\n\n![24E71F87-DFDB-4826-B6D9-7D31B6A335FA.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2758459a-267d-48ee-8da0-3faa3cc71a80/24E71F87-DFDB-4826-B6D9-7D31B6A335FA.jpeg)\n\n```java\nList<List<Integer>> res = new ArrayList();\n    \npublic List<List<Integer>> permute(int[] nums) {\n    dfs(nums, 0, new ArrayList());\n    return res;\n}\n\nprivate void dfs(int[] nums, int idx, List<Integer> list) {\n\t\tif(list.size() == nums.length) {\n        res.add(new ArrayList(list));\n        return;\n    }\n\t\t\n\t\tfor(int i = 0; i < nums.length; i++) {\n      if(list.contains(nums[i])) continue;\n\t\t\tlist.add(nums[i]);\n\t\t\tdfs(nums, i, list);\n\t\t\tlist.remove(list.size()-1); // pop the last value\n\t\t}\n}\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n```java\nList<List<Integer>> res = new ArrayList();\n\npublic List<List<Integer>> permute(int[] nums) {\n    dfs(nums, new ArrayList());\n    return res;\n}\n\nprivate void dfs(int[] nums, List<Integer> list) {\n    if(list.size() == nums.length) {\n        res.add(new ArrayList(list));\n        return;\n    }\n\n    for(int i = 0; i < nums.length; i++) {\n        if(list.contains(nums[i])) continue;\n        list.add(nums[i]);\n        dfs(nums, list);\n        list.remove(list.size()-1); // pop the last value\n    }\n}\n```\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList();\n\n    public List<List<Integer>> permute(int[] nums) {\n        dfs(nums, new ArrayList());\n        return res;\n    }\n\n    private void dfs(int[] nums, List<Integer> list) {\n        if(list.size() == nums.length) {\n            res.add(new ArrayList(list));\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if(list.contains(nums[i])) continue;\n            list.add(nums[i]);\n            dfs(nums, list);\n            list.remove(list.size()-1); // pop the last value\n        }\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e149b8f7-c3ef-41ea-ade2-89b3ecad912d/Untitled.png)\n\n### What I learned\n\n---\n\n1. Backtracking is a good approach for permutation\n","source":"_posts/46-Permutations.md","raw":"---\ntitle: \"46.\\_Permutations\"\ncatalog: true\ndate: 2022-10-31 21:47:32\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- Given array nums is distinct integers array\n- return all the possible permutations in any order\n- length of nums is less than equals to 6\n- value of nums is greater than equals to -10 and less than equals to 10\n\n### **Edge cases**\n\n---\n\n- [1,2,3] → [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nStart with Backtracking first. iterater each element in array. If current list contains value then skip. If current list contains any value in the array then move on. If the current list size is equals to length of nums, add list to answer list. when it returns remove the last value of current list.  TIme complexity is O(size of nums * size of nums * size of nums)\n\n![24E71F87-DFDB-4826-B6D9-7D31B6A335FA.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2758459a-267d-48ee-8da0-3faa3cc71a80/24E71F87-DFDB-4826-B6D9-7D31B6A335FA.jpeg)\n\n```java\nList<List<Integer>> res = new ArrayList();\n    \npublic List<List<Integer>> permute(int[] nums) {\n    dfs(nums, 0, new ArrayList());\n    return res;\n}\n\nprivate void dfs(int[] nums, int idx, List<Integer> list) {\n\t\tif(list.size() == nums.length) {\n        res.add(new ArrayList(list));\n        return;\n    }\n\t\t\n\t\tfor(int i = 0; i < nums.length; i++) {\n      if(list.contains(nums[i])) continue;\n\t\t\tlist.add(nums[i]);\n\t\t\tdfs(nums, i, list);\n\t\t\tlist.remove(list.size()-1); // pop the last value\n\t\t}\n}\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n```java\nList<List<Integer>> res = new ArrayList();\n\npublic List<List<Integer>> permute(int[] nums) {\n    dfs(nums, new ArrayList());\n    return res;\n}\n\nprivate void dfs(int[] nums, List<Integer> list) {\n    if(list.size() == nums.length) {\n        res.add(new ArrayList(list));\n        return;\n    }\n\n    for(int i = 0; i < nums.length; i++) {\n        if(list.contains(nums[i])) continue;\n        list.add(nums[i]);\n        dfs(nums, list);\n        list.remove(list.size()-1); // pop the last value\n    }\n}\n```\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    List<List<Integer>> res = new ArrayList();\n\n    public List<List<Integer>> permute(int[] nums) {\n        dfs(nums, new ArrayList());\n        return res;\n    }\n\n    private void dfs(int[] nums, List<Integer> list) {\n        if(list.size() == nums.length) {\n            res.add(new ArrayList(list));\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if(list.contains(nums[i])) continue;\n            list.add(nums[i]);\n            dfs(nums, list);\n            list.remove(list.size()-1); // pop the last value\n        }\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e149b8f7-c3ef-41ea-ade2-89b3ecad912d/Untitled.png)\n\n### What I learned\n\n---\n\n1. Backtracking is a good approach for permutation\n","slug":"46-Permutations","published":1,"updated":"2022-10-31T12:47:45.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1d001lqkcc8vw30zwm","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>Given array nums is distinct integers array</li>\n<li>return all the possible permutations in any order</li>\n<li>length of nums is less than equals to 6</li>\n<li>value of nums is greater than equals to -10 and less than equals to 10</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>[1,2,3] → [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>Start with Backtracking first. iterater each element in array. If current list contains value then skip. If current list contains any value in the array then move on. If the current list size is equals to length of nums, add list to answer list. when it returns remove the last value of current list.  TIme complexity is O(size of nums * size of nums * size of nums)</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2758459a-267d-48ee-8da0-3faa3cc71a80/24E71F87-DFDB-4826-B6D9-7D31B6A335FA.jpeg\" alt=\"24E71F87-DFDB-4826-B6D9-7D31B6A335FA.jpeg\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    dfs(nums, <span class=\"number\">0</span>, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> idx, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(list.size() == nums.length) &#123;</span><br><span class=\"line\">        res.add(<span class=\"keyword\">new</span> ArrayList(list));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(list.contains(nums[i])) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tlist.add(nums[i]);</span><br><span class=\"line\">\t\t\tdfs(nums, i, list);</span><br><span class=\"line\">\t\t\tlist.remove(list.size()-<span class=\"number\">1</span>); <span class=\"comment\">// pop the last value</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    dfs(nums, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(list.size() == nums.length) &#123;</span><br><span class=\"line\">        res.add(<span class=\"keyword\">new</span> ArrayList(list));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(list.contains(nums[i])) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        list.add(nums[i]);</span><br><span class=\"line\">        dfs(nums, list);</span><br><span class=\"line\">        list.remove(list.size()-<span class=\"number\">1</span>); <span class=\"comment\">// pop the last value</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        dfs(nums, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(list.size() == nums.length) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList(list));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(list.contains(nums[i])) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            list.add(nums[i]);</span><br><span class=\"line\">            dfs(nums, list);</span><br><span class=\"line\">            list.remove(list.size()-<span class=\"number\">1</span>); <span class=\"comment\">// pop the last value</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e149b8f7-c3ef-41ea-ade2-89b3ecad912d/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>Backtracking is a good approach for permutation</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>Given array nums is distinct integers array</li>\n<li>return all the possible permutations in any order</li>\n<li>length of nums is less than equals to 6</li>\n<li>value of nums is greater than equals to -10 and less than equals to 10</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>[1,2,3] → [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>Start with Backtracking first. iterater each element in array. If current list contains value then skip. If current list contains any value in the array then move on. If the current list size is equals to length of nums, add list to answer list. when it returns remove the last value of current list.  TIme complexity is O(size of nums * size of nums * size of nums)</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2758459a-267d-48ee-8da0-3faa3cc71a80/24E71F87-DFDB-4826-B6D9-7D31B6A335FA.jpeg\" alt=\"24E71F87-DFDB-4826-B6D9-7D31B6A335FA.jpeg\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    dfs(nums, <span class=\"number\">0</span>, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> idx, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(list.size() == nums.length) &#123;</span><br><span class=\"line\">        res.add(<span class=\"keyword\">new</span> ArrayList(list));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(list.contains(nums[i])) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tlist.add(nums[i]);</span><br><span class=\"line\">\t\t\tdfs(nums, i, list);</span><br><span class=\"line\">\t\t\tlist.remove(list.size()-<span class=\"number\">1</span>); <span class=\"comment\">// pop the last value</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    dfs(nums, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(list.size() == nums.length) &#123;</span><br><span class=\"line\">        res.add(<span class=\"keyword\">new</span> ArrayList(list));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(list.contains(nums[i])) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        list.add(nums[i]);</span><br><span class=\"line\">        dfs(nums, list);</span><br><span class=\"line\">        list.remove(list.size()-<span class=\"number\">1</span>); <span class=\"comment\">// pop the last value</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        dfs(nums, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(list.size() == nums.length) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> ArrayList(list));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(list.contains(nums[i])) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            list.add(nums[i]);</span><br><span class=\"line\">            dfs(nums, list);</span><br><span class=\"line\">            list.remove(list.size()-<span class=\"number\">1</span>); <span class=\"comment\">// pop the last value</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e149b8f7-c3ef-41ea-ade2-89b3ecad912d/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>Backtracking is a good approach for permutation</li>\n</ol>\n"},{"title":"48. Rotate Image","catalog":true,"date":"2022-09-13T16:05:58.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- rotate the image by 90 degree (clockwise)\n- DO NOT allocate another 2D matrix and do the rotation.\n- matrix has the same length of rows and colums\n\n## Solve by hands first\n\n---\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public void rotate(int[][] m) {\n        \n        int l = 0, r = m.length - 1;\n        \n        while(l < r) {\n            for(int i = 0; i < r - l; i++) {\n                int t = l, b = r;\n                \n                int tmp = m[t][l+i];\n                m[t][l+i] = m[b-i][l];\n                m[b-i][l] = m[b][r-i];\n                m[b][r-i] = m[t+i][r];\n                m[t+i][r] = tmp;\n            }\n            l++; r--;    \n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6aed74aa-881d-4834-a98c-45d412a716cf/Untitled.png)\n\nrange of left and right index is 0 to 3. The coordination to be replaced will be (0,0) (0,3) (3,3) (3,0) and (0, 1) (1, 3) (3, 2) (2, 0) in the next loop. in general form will be (0,0 + i ) (0 + i,3) (3,3 - i) (3 - i,0). the range of index i is 0 to 2 so we can reuse the left and right index\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7687e7f2-d272-4e68-9afc-f686d4d55363/Untitled.png)\n\nafter processing most outer layer of the array, we will move on to the inner layer. **To do this, we can increase left index and decrease right index**.\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ab5a6c73-8cdf-47dd-b520-72a822c6aadf/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. it’s import to have a valid range for matrix problem\n\n```java\nwhile(l < r) {\n    for(int i = 0; i < r - l; i++) {\n\n    }\n    l++; r--;    \n}\n```\n\n1. use the actual number at first \n\n```java\nwhile(l < r) {\n    for(int i = 0; i < r - l; i++) {\n        int t = l, b = r;\n        \n        int tmp = m[0][0];\n        m[0][0] = m[3][0];\n        m[3][0] = m[3][3];\n        m[3][3] = m[0][3];\n        m[0][3] = tmp;\n    }\n    l++; r--;    \n}\n```\n","source":"_posts/48-Rotate-Image.md","raw":"---\ntitle: \"48.\\_Rotate Image\"\ncatalog: true\ndate: 2022-09-14 01:05:58\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- rotate the image by 90 degree (clockwise)\n- DO NOT allocate another 2D matrix and do the rotation.\n- matrix has the same length of rows and colums\n\n## Solve by hands first\n\n---\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public void rotate(int[][] m) {\n        \n        int l = 0, r = m.length - 1;\n        \n        while(l < r) {\n            for(int i = 0; i < r - l; i++) {\n                int t = l, b = r;\n                \n                int tmp = m[t][l+i];\n                m[t][l+i] = m[b-i][l];\n                m[b-i][l] = m[b][r-i];\n                m[b][r-i] = m[t+i][r];\n                m[t+i][r] = tmp;\n            }\n            l++; r--;    \n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6aed74aa-881d-4834-a98c-45d412a716cf/Untitled.png)\n\nrange of left and right index is 0 to 3. The coordination to be replaced will be (0,0) (0,3) (3,3) (3,0) and (0, 1) (1, 3) (3, 2) (2, 0) in the next loop. in general form will be (0,0 + i ) (0 + i,3) (3,3 - i) (3 - i,0). the range of index i is 0 to 2 so we can reuse the left and right index\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7687e7f2-d272-4e68-9afc-f686d4d55363/Untitled.png)\n\nafter processing most outer layer of the array, we will move on to the inner layer. **To do this, we can increase left index and decrease right index**.\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ab5a6c73-8cdf-47dd-b520-72a822c6aadf/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. it’s import to have a valid range for matrix problem\n\n```java\nwhile(l < r) {\n    for(int i = 0; i < r - l; i++) {\n\n    }\n    l++; r--;    \n}\n```\n\n1. use the actual number at first \n\n```java\nwhile(l < r) {\n    for(int i = 0; i < r - l; i++) {\n        int t = l, b = r;\n        \n        int tmp = m[0][0];\n        m[0][0] = m[3][0];\n        m[3][0] = m[3][3];\n        m[3][3] = m[0][3];\n        m[0][3] = tmp;\n    }\n    l++; r--;    \n}\n```\n","slug":"48-Rotate-Image","published":1,"updated":"2022-09-13T16:06:25.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1d001mqkcciwpkst5c","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>rotate the image by 90 degree (clockwise)</li>\n<li>DO NOT allocate another 2D matrix and do the rotation.</li>\n<li>matrix has the same length of rows and colums</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] m)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = m.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r - l; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> t = l, b = r;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp = m[t][l+i];</span><br><span class=\"line\">                m[t][l+i] = m[b-i][l];</span><br><span class=\"line\">                m[b-i][l] = m[b][r-i];</span><br><span class=\"line\">                m[b][r-i] = m[t+i][r];</span><br><span class=\"line\">                m[t+i][r] = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            l++; r--;    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6aed74aa-881d-4834-a98c-45d412a716cf/Untitled.png\" alt=\"Untitled\"></p>\n<p>range of left and right index is 0 to 3. The coordination to be replaced will be (0,0) (0,3) (3,3) (3,0) and (0, 1) (1, 3) (3, 2) (2, 0) in the next loop. in general form will be (0,0 + i ) (0 + i,3) (3,3 - i) (3 - i,0). the range of index i is 0 to 2 so we can reuse the left and right index</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7687e7f2-d272-4e68-9afc-f686d4d55363/Untitled.png\" alt=\"Untitled\"></p>\n<p>after processing most outer layer of the array, we will move on to the inner layer. <strong>To do this, we can increase left index and decrease right index</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ab5a6c73-8cdf-47dd-b520-72a822c6aadf/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>it’s import to have a valid range for matrix problem</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r - l; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l++; r--;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>use the actual number at first</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r - l; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = l, b = r;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = m[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        m[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = m[<span class=\"number\">3</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        m[<span class=\"number\">3</span>][<span class=\"number\">0</span>] = m[<span class=\"number\">3</span>][<span class=\"number\">3</span>];</span><br><span class=\"line\">        m[<span class=\"number\">3</span>][<span class=\"number\">3</span>] = m[<span class=\"number\">0</span>][<span class=\"number\">3</span>];</span><br><span class=\"line\">        m[<span class=\"number\">0</span>][<span class=\"number\">3</span>] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l++; r--;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>rotate the image by 90 degree (clockwise)</li>\n<li>DO NOT allocate another 2D matrix and do the rotation.</li>\n<li>matrix has the same length of rows and colums</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] m)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = m.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r - l; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> t = l, b = r;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp = m[t][l+i];</span><br><span class=\"line\">                m[t][l+i] = m[b-i][l];</span><br><span class=\"line\">                m[b-i][l] = m[b][r-i];</span><br><span class=\"line\">                m[b][r-i] = m[t+i][r];</span><br><span class=\"line\">                m[t+i][r] = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            l++; r--;    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6aed74aa-881d-4834-a98c-45d412a716cf/Untitled.png\" alt=\"Untitled\"></p>\n<p>range of left and right index is 0 to 3. The coordination to be replaced will be (0,0) (0,3) (3,3) (3,0) and (0, 1) (1, 3) (3, 2) (2, 0) in the next loop. in general form will be (0,0 + i ) (0 + i,3) (3,3 - i) (3 - i,0). the range of index i is 0 to 2 so we can reuse the left and right index</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7687e7f2-d272-4e68-9afc-f686d4d55363/Untitled.png\" alt=\"Untitled\"></p>\n<p>after processing most outer layer of the array, we will move on to the inner layer. <strong>To do this, we can increase left index and decrease right index</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ab5a6c73-8cdf-47dd-b520-72a822c6aadf/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>it’s import to have a valid range for matrix problem</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r - l; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l++; r--;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>use the actual number at first</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r - l; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = l, b = r;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = m[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        m[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = m[<span class=\"number\">3</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        m[<span class=\"number\">3</span>][<span class=\"number\">0</span>] = m[<span class=\"number\">3</span>][<span class=\"number\">3</span>];</span><br><span class=\"line\">        m[<span class=\"number\">3</span>][<span class=\"number\">3</span>] = m[<span class=\"number\">0</span>][<span class=\"number\">3</span>];</span><br><span class=\"line\">        m[<span class=\"number\">0</span>][<span class=\"number\">3</span>] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l++; r--;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"449. Serialize and Deserialize BST","catalog":true,"date":"2022-09-24T02:56:00.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- Design an algorithm to serialize and deserialize a **binary search tree**\n- binary search tree can be serialized to a string\n- this string can be deserialized to the original tree structure\n- **The encoded string should be as compact as possible.**\n- • The input tree is **guaranteed** to be a binary search tree.\n\n## Solve by hands first\n\n---\n\nwe need to keep the **preorder of BST** while serializing. so if input is [2,1,3] which is in preorder, we can keep this order in the string in output. it makes easier to deserialize. Time complexity of serialization and deserialization is O(n)\n\n## Solution\n\n---\n\n```java\npublic class Codec {\n    \n    int idx = 0;\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if(root == null) return \"null\";\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        return dfs(data.split(\",\"));\n    }\n    \n    private TreeNode dfs(String[] sl) {\n        String s = sl[this.idx];\n        \n        TreeNode node = null;\n        this.idx++;\n        \n        if(s.equals(\"null\")) return node;\n        else node = new TreeNode(Integer.parseInt(s));\n\n        node.left = dfs(sl);\n        node.right = dfs(sl);\n        return node;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b1bc672-c028-4731-aab9-b85fe4fe08f4/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. preorder tree (parent → left → right)\n2. create node in dfs method and return the node\n    - I have never thought of **creating TreeNode in the method and return it**. only made a TreeNode outside of method and pass through parameter\n    - it makes easy to connect to the each left and right child node from the created node in method\n    \n    ```java\n    private TreeNode dfs(String[] sl) {\n        String s = sl[this.idx];\n        \n        TreeNode node = null;\n        this.idx++;\n        \n        if(s.equals(\"null\")) return node;\n        else node = new TreeNode(Integer.parseInt(s));\n    \n        node.left = dfs(sl);\n        node.right = dfs(sl);\n        return node;\n    }\n    ```\n    \n3. utilize the instance variable in class\n    - the pointer has to shift right in every call of dfs method\n    \n    ```java\n    private TreeNode dfs(String[] sl) {\n        String s = sl[this.idx];\n    }\n    ```\n","source":"_posts/449-Serialize-and-Deserialize-BST.md","raw":"---\ntitle: \"449.\\_Serialize and Deserialize BST\"\ncatalog: true\ndate: 2022-09-24 11:56:00\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- Design an algorithm to serialize and deserialize a **binary search tree**\n- binary search tree can be serialized to a string\n- this string can be deserialized to the original tree structure\n- **The encoded string should be as compact as possible.**\n- • The input tree is **guaranteed** to be a binary search tree.\n\n## Solve by hands first\n\n---\n\nwe need to keep the **preorder of BST** while serializing. so if input is [2,1,3] which is in preorder, we can keep this order in the string in output. it makes easier to deserialize. Time complexity of serialization and deserialization is O(n)\n\n## Solution\n\n---\n\n```java\npublic class Codec {\n    \n    int idx = 0;\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if(root == null) return \"null\";\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        return dfs(data.split(\",\"));\n    }\n    \n    private TreeNode dfs(String[] sl) {\n        String s = sl[this.idx];\n        \n        TreeNode node = null;\n        this.idx++;\n        \n        if(s.equals(\"null\")) return node;\n        else node = new TreeNode(Integer.parseInt(s));\n\n        node.left = dfs(sl);\n        node.right = dfs(sl);\n        return node;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b1bc672-c028-4731-aab9-b85fe4fe08f4/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. preorder tree (parent → left → right)\n2. create node in dfs method and return the node\n    - I have never thought of **creating TreeNode in the method and return it**. only made a TreeNode outside of method and pass through parameter\n    - it makes easy to connect to the each left and right child node from the created node in method\n    \n    ```java\n    private TreeNode dfs(String[] sl) {\n        String s = sl[this.idx];\n        \n        TreeNode node = null;\n        this.idx++;\n        \n        if(s.equals(\"null\")) return node;\n        else node = new TreeNode(Integer.parseInt(s));\n    \n        node.left = dfs(sl);\n        node.right = dfs(sl);\n        return node;\n    }\n    ```\n    \n3. utilize the instance variable in class\n    - the pointer has to shift right in every call of dfs method\n    \n    ```java\n    private TreeNode dfs(String[] sl) {\n        String s = sl[this.idx];\n    }\n    ```\n","slug":"449-Serialize-and-Deserialize-BST","published":1,"updated":"2022-09-24T02:56:46.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1e001nqkccatzzleko","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong></li>\n<li>binary search tree can be serialized to a string</li>\n<li>this string can be deserialized to the original tree structure</li>\n<li><strong>The encoded string should be as compact as possible.</strong></li>\n<li>• The input tree is <strong>guaranteed</strong> to be a binary search tree.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we need to keep the <strong>preorder of BST</strong> while serializing. so if input is [2,1,3] which is in preorder, we can keep this order in the string in output. it makes easier to deserialize. Time complexity of serialization and deserialization is O(n)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Codec</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Encodes a tree to a single string.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">serialize</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"null\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.val + <span class=\"string\">\",\"</span> + serialize(root.left) + <span class=\"string\">\",\"</span> + serialize(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Decodes your encoded data to tree.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">deserialize</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(data.split(<span class=\"string\">\",\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">dfs</span><span class=\"params\">(String[] sl)</span> </span>&#123;</span><br><span class=\"line\">        String s = sl[<span class=\"keyword\">this</span>.idx];</span><br><span class=\"line\">        </span><br><span class=\"line\">        TreeNode node = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.idx++;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.equals(<span class=\"string\">\"null\"</span>)) <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> node = <span class=\"keyword\">new</span> TreeNode(Integer.parseInt(s));</span><br><span class=\"line\"></span><br><span class=\"line\">        node.left = dfs(sl);</span><br><span class=\"line\">        node.right = dfs(sl);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b1bc672-c028-4731-aab9-b85fe4fe08f4/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>preorder tree (parent → left → right)</p>\n</li>\n<li>\n<p>create node in dfs method and return the node</p>\n<ul>\n<li>I have never thought of <strong>creating TreeNode in the method and return it</strong>. only made a TreeNode outside of method and pass through parameter</li>\n<li>it makes easy to connect to the each left and right child node from the created node in method</li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">dfs</span><span class=\"params\">(String[] sl)</span> </span>&#123;</span><br><span class=\"line\">    String s = sl[<span class=\"keyword\">this</span>.idx];</span><br><span class=\"line\">    </span><br><span class=\"line\">    TreeNode node = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.idx++;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.equals(<span class=\"string\">\"null\"</span>)) <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> node = <span class=\"keyword\">new</span> TreeNode(Integer.parseInt(s));</span><br><span class=\"line\"></span><br><span class=\"line\">    node.left = dfs(sl);</span><br><span class=\"line\">    node.right = dfs(sl);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>utilize the instance variable in class</p>\n<ul>\n<li>the pointer has to shift right in every call of dfs method</li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">dfs</span><span class=\"params\">(String[] sl)</span> </span>&#123;</span><br><span class=\"line\">    String s = sl[<span class=\"keyword\">this</span>.idx];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong></li>\n<li>binary search tree can be serialized to a string</li>\n<li>this string can be deserialized to the original tree structure</li>\n<li><strong>The encoded string should be as compact as possible.</strong></li>\n<li>• The input tree is <strong>guaranteed</strong> to be a binary search tree.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we need to keep the <strong>preorder of BST</strong> while serializing. so if input is [2,1,3] which is in preorder, we can keep this order in the string in output. it makes easier to deserialize. Time complexity of serialization and deserialization is O(n)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Codec</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Encodes a tree to a single string.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">serialize</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"null\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.val + <span class=\"string\">\",\"</span> + serialize(root.left) + <span class=\"string\">\",\"</span> + serialize(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Decodes your encoded data to tree.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">deserialize</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(data.split(<span class=\"string\">\",\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">dfs</span><span class=\"params\">(String[] sl)</span> </span>&#123;</span><br><span class=\"line\">        String s = sl[<span class=\"keyword\">this</span>.idx];</span><br><span class=\"line\">        </span><br><span class=\"line\">        TreeNode node = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.idx++;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.equals(<span class=\"string\">\"null\"</span>)) <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> node = <span class=\"keyword\">new</span> TreeNode(Integer.parseInt(s));</span><br><span class=\"line\"></span><br><span class=\"line\">        node.left = dfs(sl);</span><br><span class=\"line\">        node.right = dfs(sl);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b1bc672-c028-4731-aab9-b85fe4fe08f4/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>preorder tree (parent → left → right)</p>\n</li>\n<li>\n<p>create node in dfs method and return the node</p>\n<ul>\n<li>I have never thought of <strong>creating TreeNode in the method and return it</strong>. only made a TreeNode outside of method and pass through parameter</li>\n<li>it makes easy to connect to the each left and right child node from the created node in method</li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">dfs</span><span class=\"params\">(String[] sl)</span> </span>&#123;</span><br><span class=\"line\">    String s = sl[<span class=\"keyword\">this</span>.idx];</span><br><span class=\"line\">    </span><br><span class=\"line\">    TreeNode node = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.idx++;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.equals(<span class=\"string\">\"null\"</span>)) <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> node = <span class=\"keyword\">new</span> TreeNode(Integer.parseInt(s));</span><br><span class=\"line\"></span><br><span class=\"line\">    node.left = dfs(sl);</span><br><span class=\"line\">    node.right = dfs(sl);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>utilize the instance variable in class</p>\n<ul>\n<li>the pointer has to shift right in every call of dfs method</li>\n</ul>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">dfs</span><span class=\"params\">(String[] sl)</span> </span>&#123;</span><br><span class=\"line\">    String s = sl[<span class=\"keyword\">this</span>.idx];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"49. Group Anagrams","catalog":true,"date":"2022-09-14T13:30:43.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- **Anagram** is the word can formed by rearranging the letters of another. typically using all the letters once (cinema → iceman)\n- answer can be any order\n\n## Solve by hands first\n\n---\n\nwe can start with Brute Force. We can go through the strings one by one but **each string has to be store somewhere to compare to other string.** we need to choose the right data structure. we have to find the **anagram which has the same length of letter with the different order**. so **if anagram is sorted, it turn into the same word**. Map is a good option in this case. its time complexity is O(1). so total timecomplexity will be O(m*n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        \n        Map<String, List<String>> m = new HashMap();\n        \n        for(int i = 0; i < strs.length; i++) {\n            char[] c = strs[i].toCharArray(); \n            Arrays.sort(c);\n            String s = String.valueOf(c); \n            \n            if(!m.containsKey(s)) m.put(s, new ArrayList());\n            m.get(s).add(strs[i]);\n        }\n        \n        return new ArrayList(m.values());\n    }\n}\n```\n\n## Lesson I learnt\n\n---\n\n1. **Anagram** has the same size of characters but different order → **sort**\n2. **Map** can be a good option for **anagram** problem\n","source":"_posts/49-Group-Anagrams.md","raw":"---\ntitle: \"49.\\_Group Anagrams\"\ncatalog: true\ndate: 2022-09-14 22:30:43\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- **Anagram** is the word can formed by rearranging the letters of another. typically using all the letters once (cinema → iceman)\n- answer can be any order\n\n## Solve by hands first\n\n---\n\nwe can start with Brute Force. We can go through the strings one by one but **each string has to be store somewhere to compare to other string.** we need to choose the right data structure. we have to find the **anagram which has the same length of letter with the different order**. so **if anagram is sorted, it turn into the same word**. Map is a good option in this case. its time complexity is O(1). so total timecomplexity will be O(m*n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        \n        Map<String, List<String>> m = new HashMap();\n        \n        for(int i = 0; i < strs.length; i++) {\n            char[] c = strs[i].toCharArray(); \n            Arrays.sort(c);\n            String s = String.valueOf(c); \n            \n            if(!m.containsKey(s)) m.put(s, new ArrayList());\n            m.get(s).add(strs[i]);\n        }\n        \n        return new ArrayList(m.values());\n    }\n}\n```\n\n## Lesson I learnt\n\n---\n\n1. **Anagram** has the same size of characters but different order → **sort**\n2. **Map** can be a good option for **anagram** problem\n","slug":"49-Group-Anagrams","published":1,"updated":"2022-09-14T13:31:02.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1e001oqkcc81i356k6","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li><strong>Anagram</strong> is the word can formed by rearranging the letters of another. typically using all the letters once (cinema → iceman)</li>\n<li>answer can be any order</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can start with Brute Force. We can go through the strings one by one but <strong>each string has to be store somewhere to compare to other string.</strong> we need to choose the right data structure. we have to find the <strong>anagram which has the same length of letter with the different order</strong>. so <strong>if anagram is sorted, it turn into the same word</strong>. Map is a good option in this case. its time complexity is O(1). so total timecomplexity will be O(m*n)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Map&lt;String, List&lt;String&gt;&gt; m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span>[] c = strs[i].toCharArray(); </span><br><span class=\"line\">            Arrays.sort(c);</span><br><span class=\"line\">            String s = String.valueOf(c); </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!m.containsKey(s)) m.put(s, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">            m.get(s).add(strs[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList(m.values());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li><strong>Anagram</strong> has the same size of characters but different order → <strong>sort</strong></li>\n<li><strong>Map</strong> can be a good option for <strong>anagram</strong> problem</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li><strong>Anagram</strong> is the word can formed by rearranging the letters of another. typically using all the letters once (cinema → iceman)</li>\n<li>answer can be any order</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can start with Brute Force. We can go through the strings one by one but <strong>each string has to be store somewhere to compare to other string.</strong> we need to choose the right data structure. we have to find the <strong>anagram which has the same length of letter with the different order</strong>. so <strong>if anagram is sorted, it turn into the same word</strong>. Map is a good option in this case. its time complexity is O(1). so total timecomplexity will be O(m*n)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Map&lt;String, List&lt;String&gt;&gt; m = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span>[] c = strs[i].toCharArray(); </span><br><span class=\"line\">            Arrays.sort(c);</span><br><span class=\"line\">            String s = String.valueOf(c); </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!m.containsKey(s)) m.put(s, <span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">            m.get(s).add(strs[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList(m.values());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li><strong>Anagram</strong> has the same size of characters but different order → <strong>sort</strong></li>\n<li><strong>Map</strong> can be a good option for <strong>anagram</strong> problem</li>\n</ol>\n"},{"title":"53. Maximum Subarray","catalog":true,"date":"2022-10-22T07:14:28.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- find the contiguous subarray (at least contain 1 value) which has the largest sum\n- return the sum\n- num is between -10^4 and 10^4 which means contain negative value and 0\n\n### **Edge cases**\n\n---\n\n- [1, 0, 2, -1, 3, 5, -3]\n    - [1, 0, 2, -1, 3, 5, -3] → 7\n    - [1, 0, 2, -1, 3, 5] → 10\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nWe can start with Brute force way. Iterate each index and calculate the sum of contiguous subarrays. find the maximum value out of that. Time complexity is O(n^2) and space complexity is O(1)\n\n```java\nint max = nums[0];\nfor(int i = 0; i < nums.length; i++) {\n    int sum = nums[i];\n    max = Math.max(max, sum);\n    for(int j = i+1; j < nums.length; j++) {\n        sum += nums[j];\n        max = Math.max(max, sum);\n    }\n}\nreturn max;\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can optimize above solution to O(n) with sliding window. The tip is the contiguous subarray contains the largest sum and the range of the value in array contains negative value. it means we don’t need any negative value to make the largest sum. So, when sum of the contiguous subarray becomes negative which means can’t be the largest sum. we drop the current subarray and reset the contiguous subarray starting from current index. Time complexity is O(n) and space complexity is O(1);\n\n```java\nint max = nums[0];\nint sum = 0;\nfor(int n : nums) {\n\tif(sum < 0) sum = 0;\n\tsum += n;\n\tmax = Math.max(max, sum);\n}\nreturn max;\n\n```\n\n![C18E9EEF-7299-45BE-9BBD-D3774F20B083.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cf2aafb1-1772-4a95-9a6e-c808e24899b7/C18E9EEF-7299-45BE-9BBD-D3774F20B083.jpeg)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int max = nums[0];\n        int sum = 0;\n        for(int n : nums) {\n            if(sum < 0) sum = 0;\n            sum += n;\n            max = Math.max(max, sum);\n        }\n        return max;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/80c55d1c-b08f-4a3e-b74e-fbb5c18de642/Untitled.png)\n\n### What I learned\n\n---\n\n1. Sliding window is a good solution in array problem\n2. Find the core logic or patterns in the problem. carefully read the problem and find the key. in this problem, the key was the **contiguous** **subarray** and **largest sum**.\n","source":"_posts/53-Maximum-Subarray.md","raw":"---\ntitle: \"53.\\_Maximum Subarray\"\ncatalog: true\ndate: 2022-10-22 16:14:28\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- find the contiguous subarray (at least contain 1 value) which has the largest sum\n- return the sum\n- num is between -10^4 and 10^4 which means contain negative value and 0\n\n### **Edge cases**\n\n---\n\n- [1, 0, 2, -1, 3, 5, -3]\n    - [1, 0, 2, -1, 3, 5, -3] → 7\n    - [1, 0, 2, -1, 3, 5] → 10\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nWe can start with Brute force way. Iterate each index and calculate the sum of contiguous subarrays. find the maximum value out of that. Time complexity is O(n^2) and space complexity is O(1)\n\n```java\nint max = nums[0];\nfor(int i = 0; i < nums.length; i++) {\n    int sum = nums[i];\n    max = Math.max(max, sum);\n    for(int j = i+1; j < nums.length; j++) {\n        sum += nums[j];\n        max = Math.max(max, sum);\n    }\n}\nreturn max;\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nWe can optimize above solution to O(n) with sliding window. The tip is the contiguous subarray contains the largest sum and the range of the value in array contains negative value. it means we don’t need any negative value to make the largest sum. So, when sum of the contiguous subarray becomes negative which means can’t be the largest sum. we drop the current subarray and reset the contiguous subarray starting from current index. Time complexity is O(n) and space complexity is O(1);\n\n```java\nint max = nums[0];\nint sum = 0;\nfor(int n : nums) {\n\tif(sum < 0) sum = 0;\n\tsum += n;\n\tmax = Math.max(max, sum);\n}\nreturn max;\n\n```\n\n![C18E9EEF-7299-45BE-9BBD-D3774F20B083.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cf2aafb1-1772-4a95-9a6e-c808e24899b7/C18E9EEF-7299-45BE-9BBD-D3774F20B083.jpeg)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int max = nums[0];\n        int sum = 0;\n        for(int n : nums) {\n            if(sum < 0) sum = 0;\n            sum += n;\n            max = Math.max(max, sum);\n        }\n        return max;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/80c55d1c-b08f-4a3e-b74e-fbb5c18de642/Untitled.png)\n\n### What I learned\n\n---\n\n1. Sliding window is a good solution in array problem\n2. Find the core logic or patterns in the problem. carefully read the problem and find the key. in this problem, the key was the **contiguous** **subarray** and **largest sum**.\n","slug":"53-Maximum-Subarray","published":1,"updated":"2022-10-22T07:14:47.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1e001pqkccub5sgf74","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>find the contiguous subarray (at least contain 1 value) which has the largest sum</li>\n<li>return the sum</li>\n<li>num is between -10^4 and 10^4 which means contain negative value and 0</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>[1, 0, 2, -1, 3, 5, -3]\n<ul>\n<li>[1, 0, 2, -1, 3, 5, -3] → 7</li>\n<li>[1, 0, 2, -1, 3, 5] → 10</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>We can start with Brute force way. Iterate each index and calculate the sum of contiguous subarrays. find the maximum value out of that. Time complexity is O(n^2) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> max = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = nums[i];</span><br><span class=\"line\">    max = Math.max(max, sum);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">        sum += nums[j];</span><br><span class=\"line\">        max = Math.max(max, sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>We can optimize above solution to O(n) with sliding window. The tip is the contiguous subarray contains the largest sum and the range of the value in array contains negative value. it means we don’t need any negative value to make the largest sum. So, when sum of the contiguous subarray becomes negative which means can’t be the largest sum. we drop the current subarray and reset the contiguous subarray starting from current index. Time complexity is O(n) and space complexity is O(1);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> max = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(sum &lt; <span class=\"number\">0</span>) sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsum += n;</span><br><span class=\"line\">\tmax = Math.max(max, sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cf2aafb1-1772-4a95-9a6e-c808e24899b7/C18E9EEF-7299-45BE-9BBD-D3774F20B083.jpeg\" alt=\"C18E9EEF-7299-45BE-9BBD-D3774F20B083.jpeg\"></p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum &lt; <span class=\"number\">0</span>) sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            sum += n;</span><br><span class=\"line\">            max = Math.max(max, sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/80c55d1c-b08f-4a3e-b74e-fbb5c18de642/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>Sliding window is a good solution in array problem</li>\n<li>Find the core logic or patterns in the problem. carefully read the problem and find the key. in this problem, the key was the <strong>contiguous</strong> <strong>subarray</strong> and <strong>largest sum</strong>.</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>find the contiguous subarray (at least contain 1 value) which has the largest sum</li>\n<li>return the sum</li>\n<li>num is between -10^4 and 10^4 which means contain negative value and 0</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>[1, 0, 2, -1, 3, 5, -3]\n<ul>\n<li>[1, 0, 2, -1, 3, 5, -3] → 7</li>\n<li>[1, 0, 2, -1, 3, 5] → 10</li>\n</ul>\n</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>We can start with Brute force way. Iterate each index and calculate the sum of contiguous subarrays. find the maximum value out of that. Time complexity is O(n^2) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> max = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = nums[i];</span><br><span class=\"line\">    max = Math.max(max, sum);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">        sum += nums[j];</span><br><span class=\"line\">        max = Math.max(max, sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max;</span><br></pre></td></tr></table></figure>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>We can optimize above solution to O(n) with sliding window. The tip is the contiguous subarray contains the largest sum and the range of the value in array contains negative value. it means we don’t need any negative value to make the largest sum. So, when sum of the contiguous subarray becomes negative which means can’t be the largest sum. we drop the current subarray and reset the contiguous subarray starting from current index. Time complexity is O(n) and space complexity is O(1);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> max = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(sum &lt; <span class=\"number\">0</span>) sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsum += n;</span><br><span class=\"line\">\tmax = Math.max(max, sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> max;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cf2aafb1-1772-4a95-9a6e-c808e24899b7/C18E9EEF-7299-45BE-9BBD-D3774F20B083.jpeg\" alt=\"C18E9EEF-7299-45BE-9BBD-D3774F20B083.jpeg\"></p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum &lt; <span class=\"number\">0</span>) sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            sum += n;</span><br><span class=\"line\">            max = Math.max(max, sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/80c55d1c-b08f-4a3e-b74e-fbb5c18de642/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>Sliding window is a good solution in array problem</li>\n<li>Find the core logic or patterns in the problem. carefully read the problem and find the key. in this problem, the key was the <strong>contiguous</strong> <strong>subarray</strong> and <strong>largest sum</strong>.</li>\n</ol>\n"},{"title":"5. Longest Palindromic Substring","catalog":true,"date":"2022-10-09T06:54:32.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- return *the longest palindromic substring* in `s`\n\n## Solve by hands first\n\n---\n\nThere are various way of solving Palindrome problem. in this case, we can search through each letters and expanding each letter from the middle. for instance, there is word “abc”, to check if it’s Palindrome, starting from b and expand left and right letter at a time. then it will be “abc”. if left and right letter is the same, then we can call it Palindrome\n\nBut there are two cases, even and odd size of palindrome. so we have to check both cases\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public String longestPalindrome(String s) {\n        \n        String ans = \"\";\n        for(int i = 0; i < s.length(); i++) {\n            \n            // odd string\n            int l = i, r = i;\n            while(l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n                if(ans.length() < r - l + 1) {\n                    ans = s.substring(l, r+1);\n                } \n                l--;\n                r++;\n            }\n            \n            // even string\n            l = i; r = i+1;\n            while(l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n                if(ans.length() < r - l + 1) {\n                    ans = s.substring(l, r+1);\n                } \n                l--;\n                r++;\n            }\n        }\n        \n        return ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ea3660bc-2fa5-4846-942e-dc1e35360eff/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Palindrome solution\n\n```java\n// odd string\nint l = i, r = i;\nwhile(l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n    l--;\n    r++;\n}\n```\n\n```java\n\n// even string\nl = i; r = i+1;\nwhile(l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n    l--;\n    r++;\n}\n```\n","source":"_posts/5-Longest-Palindromic-Substring.md","raw":"---\ntitle: \"5.\\_Longest Palindromic Substring\"\ncatalog: true\ndate: 2022-10-09 15:54:32\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- return *the longest palindromic substring* in `s`\n\n## Solve by hands first\n\n---\n\nThere are various way of solving Palindrome problem. in this case, we can search through each letters and expanding each letter from the middle. for instance, there is word “abc”, to check if it’s Palindrome, starting from b and expand left and right letter at a time. then it will be “abc”. if left and right letter is the same, then we can call it Palindrome\n\nBut there are two cases, even and odd size of palindrome. so we have to check both cases\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public String longestPalindrome(String s) {\n        \n        String ans = \"\";\n        for(int i = 0; i < s.length(); i++) {\n            \n            // odd string\n            int l = i, r = i;\n            while(l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n                if(ans.length() < r - l + 1) {\n                    ans = s.substring(l, r+1);\n                } \n                l--;\n                r++;\n            }\n            \n            // even string\n            l = i; r = i+1;\n            while(l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n                if(ans.length() < r - l + 1) {\n                    ans = s.substring(l, r+1);\n                } \n                l--;\n                r++;\n            }\n        }\n        \n        return ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ea3660bc-2fa5-4846-942e-dc1e35360eff/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Palindrome solution\n\n```java\n// odd string\nint l = i, r = i;\nwhile(l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n    l--;\n    r++;\n}\n```\n\n```java\n\n// even string\nl = i; r = i+1;\nwhile(l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n    l--;\n    r++;\n}\n```\n","slug":"5-Longest-Palindromic-Substring","published":1,"updated":"2022-10-09T06:54:53.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1e001qqkcczjwkc01h","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>return <em>the longest palindromic substring</em> in <code>s</code></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>There are various way of solving Palindrome problem. in this case, we can search through each letters and expanding each letter from the middle. for instance, there is word “abc”, to check if it’s Palindrome, starting from b and expand left and right letter at a time. then it will be “abc”. if left and right letter is the same, then we can call it Palindrome</p>\n<p>But there are two cases, even and odd size of palindrome. so we have to check both cases</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String ans = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// odd string</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> l = i, r = i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l &gt;= <span class=\"number\">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ans.length() &lt; r - l + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    ans = s.substring(l, r+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">                l--;</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// even string</span></span><br><span class=\"line\">            l = i; r = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l &gt;= <span class=\"number\">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ans.length() &lt; r - l + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    ans = s.substring(l, r+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">                l--;</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ea3660bc-2fa5-4846-942e-dc1e35360eff/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>Palindrome solution</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// odd string</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> l = i, r = i;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l &gt;= <span class=\"number\">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class=\"line\">    l--;</span><br><span class=\"line\">    r++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// even string</span></span><br><span class=\"line\">l = i; r = i+<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l &gt;= <span class=\"number\">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class=\"line\">    l--;</span><br><span class=\"line\">    r++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>return <em>the longest palindromic substring</em> in <code>s</code></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>There are various way of solving Palindrome problem. in this case, we can search through each letters and expanding each letter from the middle. for instance, there is word “abc”, to check if it’s Palindrome, starting from b and expand left and right letter at a time. then it will be “abc”. if left and right letter is the same, then we can call it Palindrome</p>\n<p>But there are two cases, even and odd size of palindrome. so we have to check both cases</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        String ans = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// odd string</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> l = i, r = i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l &gt;= <span class=\"number\">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ans.length() &lt; r - l + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    ans = s.substring(l, r+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">                l--;</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// even string</span></span><br><span class=\"line\">            l = i; r = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l &gt;= <span class=\"number\">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ans.length() &lt; r - l + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    ans = s.substring(l, r+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">                l--;</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ea3660bc-2fa5-4846-942e-dc1e35360eff/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>Palindrome solution</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// odd string</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> l = i, r = i;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l &gt;= <span class=\"number\">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class=\"line\">    l--;</span><br><span class=\"line\">    r++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// even string</span></span><br><span class=\"line\">l = i; r = i+<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l &gt;= <span class=\"number\">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class=\"line\">    l--;</span><br><span class=\"line\">    r++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"371. Sum of Two Integers","catalog":true,"date":"2022-09-23T11:36:05.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- return *the sum of the two integers without using the operators* `+` *and* `-`\n\n## Solve by hands first\n\n---\n\nif we take a look at the first digit of plus operation, **it would act like XOR operation**. both of the digits are the same then it will have 1 in the output. otherwise only one of the two digits is 1 then we will have a 1 in the output \n\n- 0 + 0 = 0\n- 1 + 1 = 0\n- 1 + 0 = 1\n- 0 + 1 = 1\n\nbut in case of 1 + 1, we will have a carry after operation. **we need to add 1 as carry at the left digit**. we can use AND operation to have 1 in the ouput and shift to left and add up to the result of OXR operation.\n\n- 1 + 1 = 1\n\nFor instance 2 + 2 = 4 and 10 + 10 = 100 as binary form\n\n```java\n\t\t      10 \n\t\t      10\n-------------\nXOR\t      00\nAND << 1 100\n-------------\n         100\n```\n\nif result of **AND << 1 opration is 0 which mean there is nothing to carry**.(more precisly the result of AND operation since << 1 won’t make any changes) so at that moment we can return the result\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int getSum(int a, int b) {\n        while(b != 0) {\n            int tmp = (a & b) << 1;\n            a = a ^ b;\n            b = tmp;\n        }\n        return a;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/97d780a7-2225-4635-82a6-051956034cb1/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. bite manipulation\n    - [https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/tutorial/](https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/tutorial/)\n\n| X | Y | X & Y (AND) | X | Y (OR) | X ^ Y (XOR) | ~(X) |\n| --- | --- | --- | --- | --- | --- |\n| 0 | 0 | 0 | 0 | 0 | 1 |\n| 1 | 0 | 0 | 1 | 1 | 0 |\n| 0 | 1 | 0 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 | 0 | 0 |\n1. XOR  = a ^ b \n    - one of the value has 1 then it will have 1 in the output\n    - otherwise return 0\n2. AND = a & b\n    - both of the digits are 1 then return 1\n    - otherwise return 0\n","source":"_posts/371-Sum-of-Two-Integers.md","raw":"---\ntitle: \"371.\\_Sum of Two Integers\"\ncatalog: true\ndate: 2022-09-23 20:36:05\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- return *the sum of the two integers without using the operators* `+` *and* `-`\n\n## Solve by hands first\n\n---\n\nif we take a look at the first digit of plus operation, **it would act like XOR operation**. both of the digits are the same then it will have 1 in the output. otherwise only one of the two digits is 1 then we will have a 1 in the output \n\n- 0 + 0 = 0\n- 1 + 1 = 0\n- 1 + 0 = 1\n- 0 + 1 = 1\n\nbut in case of 1 + 1, we will have a carry after operation. **we need to add 1 as carry at the left digit**. we can use AND operation to have 1 in the ouput and shift to left and add up to the result of OXR operation.\n\n- 1 + 1 = 1\n\nFor instance 2 + 2 = 4 and 10 + 10 = 100 as binary form\n\n```java\n\t\t      10 \n\t\t      10\n-------------\nXOR\t      00\nAND << 1 100\n-------------\n         100\n```\n\nif result of **AND << 1 opration is 0 which mean there is nothing to carry**.(more precisly the result of AND operation since << 1 won’t make any changes) so at that moment we can return the result\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int getSum(int a, int b) {\n        while(b != 0) {\n            int tmp = (a & b) << 1;\n            a = a ^ b;\n            b = tmp;\n        }\n        return a;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/97d780a7-2225-4635-82a6-051956034cb1/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. bite manipulation\n    - [https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/tutorial/](https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/tutorial/)\n\n| X | Y | X & Y (AND) | X | Y (OR) | X ^ Y (XOR) | ~(X) |\n| --- | --- | --- | --- | --- | --- |\n| 0 | 0 | 0 | 0 | 0 | 1 |\n| 1 | 0 | 0 | 1 | 1 | 0 |\n| 0 | 1 | 0 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 | 0 | 0 |\n1. XOR  = a ^ b \n    - one of the value has 1 then it will have 1 in the output\n    - otherwise return 0\n2. AND = a & b\n    - both of the digits are 1 then return 1\n    - otherwise return 0\n","slug":"371-Sum-of-Two-Integers","published":1,"updated":"2022-09-23T11:36:28.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1e001rqkcc8u7k27u2","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>return <em>the sum of the two integers without using the operators</em> <code>+</code> <em>and</em> <code>-</code></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>if we take a look at the first digit of plus operation, <strong>it would act like XOR operation</strong>. both of the digits are the same then it will have 1 in the output. otherwise only one of the two digits is 1 then we will have a 1 in the output</p>\n<ul>\n<li>0 + 0 = 0</li>\n<li>1 + 1 = 0</li>\n<li>1 + 0 = 1</li>\n<li>0 + 1 = 1</li>\n</ul>\n<p>but in case of 1 + 1, we will have a carry after operation. <strong>we need to add 1 as carry at the left digit</strong>. we can use AND operation to have 1 in the ouput and shift to left and add up to the result of OXR operation.</p>\n<ul>\n<li>1 + 1 = 1</li>\n</ul>\n<p>For instance 2 + 2 = 4 and 10 + 10 = 100 as binary form</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t      <span class=\"number\">10</span> </span><br><span class=\"line\">\t\t      <span class=\"number\">10</span></span><br><span class=\"line\">-------------</span><br><span class=\"line\">XOR\t      <span class=\"number\">00</span></span><br><span class=\"line\">AND &lt;&lt; <span class=\"number\">1</span> <span class=\"number\">100</span></span><br><span class=\"line\">-------------</span><br><span class=\"line\">         <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<p>if result of <strong>AND &lt;&lt; 1 opration is 0 which mean there is nothing to carry</strong>.(more precisly the result of AND operation since &lt;&lt; 1 won’t make any changes) so at that moment we can return the result</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(b != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = (a &amp; b) &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            a = a ^ b;</span><br><span class=\"line\">            b = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/97d780a7-2225-4635-82a6-051956034cb1/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>bite manipulation\n<ul>\n<li><a href=\"https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/tutorial/\" target=\"_blank\" rel=\"noopener\">https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/tutorial/</a></li>\n</ul>\n</li>\n</ol>\n<p>| X | Y | X &amp; Y (AND) | X | Y (OR) | X ^ Y (XOR) | ~(X) |<br>\n| — | — | — | — | — | — |<br>\n| 0 | 0 | 0 | 0 | 0 | 1 |<br>\n| 1 | 0 | 0 | 1 | 1 | 0 |<br>\n| 0 | 1 | 0 | 1 | 1 | 1 |<br>\n| 1 | 1 | 1 | 1 | 0 | 0 |</p>\n<ol>\n<li>XOR  = a ^ b\n<ul>\n<li>one of the value has 1 then it will have 1 in the output</li>\n<li>otherwise return 0</li>\n</ul>\n</li>\n<li>AND = a &amp; b\n<ul>\n<li>both of the digits are 1 then return 1</li>\n<li>otherwise return 0</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>return <em>the sum of the two integers without using the operators</em> <code>+</code> <em>and</em> <code>-</code></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>if we take a look at the first digit of plus operation, <strong>it would act like XOR operation</strong>. both of the digits are the same then it will have 1 in the output. otherwise only one of the two digits is 1 then we will have a 1 in the output</p>\n<ul>\n<li>0 + 0 = 0</li>\n<li>1 + 1 = 0</li>\n<li>1 + 0 = 1</li>\n<li>0 + 1 = 1</li>\n</ul>\n<p>but in case of 1 + 1, we will have a carry after operation. <strong>we need to add 1 as carry at the left digit</strong>. we can use AND operation to have 1 in the ouput and shift to left and add up to the result of OXR operation.</p>\n<ul>\n<li>1 + 1 = 1</li>\n</ul>\n<p>For instance 2 + 2 = 4 and 10 + 10 = 100 as binary form</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t      <span class=\"number\">10</span> </span><br><span class=\"line\">\t\t      <span class=\"number\">10</span></span><br><span class=\"line\">-------------</span><br><span class=\"line\">XOR\t      <span class=\"number\">00</span></span><br><span class=\"line\">AND &lt;&lt; <span class=\"number\">1</span> <span class=\"number\">100</span></span><br><span class=\"line\">-------------</span><br><span class=\"line\">         <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<p>if result of <strong>AND &lt;&lt; 1 opration is 0 which mean there is nothing to carry</strong>.(more precisly the result of AND operation since &lt;&lt; 1 won’t make any changes) so at that moment we can return the result</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(b != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = (a &amp; b) &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            a = a ^ b;</span><br><span class=\"line\">            b = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/97d780a7-2225-4635-82a6-051956034cb1/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>bite manipulation\n<ul>\n<li><a href=\"https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/tutorial/\" target=\"_blank\" rel=\"noopener\">https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/tutorial/</a></li>\n</ul>\n</li>\n</ol>\n<p>| X | Y | X &amp; Y (AND) | X | Y (OR) | X ^ Y (XOR) | ~(X) |<br>\n| — | — | — | — | — | — |<br>\n| 0 | 0 | 0 | 0 | 0 | 1 |<br>\n| 1 | 0 | 0 | 1 | 1 | 0 |<br>\n| 0 | 1 | 0 | 1 | 1 | 1 |<br>\n| 1 | 1 | 1 | 1 | 0 | 0 |</p>\n<ol>\n<li>XOR  = a ^ b\n<ul>\n<li>one of the value has 1 then it will have 1 in the output</li>\n<li>otherwise return 0</li>\n</ul>\n</li>\n<li>AND = a &amp; b\n<ul>\n<li>both of the digits are 1 then return 1</li>\n<li>otherwise return 0</li>\n</ul>\n</li>\n</ol>\n"},{"title":"55. Jump Game","catalog":true,"date":"2022-09-16T12:31:49.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- You are initially positioned at the array's first index\n- 1 <= nums.length <= 10^4\n- 0 <= nums[i] <= 10^5\n\n## Solve by hands first\n\n---\n\nThis is typical dynamic programing question. but the problem is \n\n## Solution\n\n---\n\n1. **dynamic programming**\n\n```java\nclass Solution {\n    \n    public boolean canJump(int[] nums) {\n        return dfs(nums, 0);\n    }\n    \n    private boolean dfs(int[] nums, int idx) {\n        if(idx == nums.length - 1) return true;\n        if(nums[idx] == 0) return false;\n        \n        boolean t = false;\n        for(int i = 1; i <= nums[idx]; i++) {\n            t |= dfs(nums, idx + i);\n        }\n        \n        return t;\n    }  \n}\n```\n\n![79E23087-0712-4445-8EC9-DC6C3ECBBACC.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a03d7e11-37f5-494c-a2fd-1bb5307d27e2/79E23087-0712-4445-8EC9-DC6C3ECBBACC.jpeg)\n\nproblem of this solution was it gonna run throught the same decision tree again which will end up cause the time limit. The time complexity will be O(m^n) (m: the largest element in array, n: length of array)\n\n![0F8571B2-E301-4976-BF77-C5F862F4C946.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/580f2ae7-af19-448b-9476-b5be187beb42/0F8571B2-E301-4976-BF77-C5F862F4C946.jpeg)\n\nwe can handled the issue by using memoization. Time complexity will be O(n) with more space\n\n1. **greedy**\n\n```java\nclass Solution {\n    \n    public boolean canJump(int[] nums) {\n        int max = 0;\n        for(int i = 0; i < nums.length; i++) {\n            if(max < i) return false;\n            max = Math.max(max, nums[i] + i);\n        }\n        return true;\n    }\n}\n```\n\nwe can come up with greedy solution. so we don’t need either dynamic programing or cahce memory for this. Time complexity will be O(n) in this case. **The key point is that the farest index on each element is less than any index before last index which means we can’t reach to the last index**.\n\n![B8991A57-0642-490D-A2BC-8C8B57797066.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5421fb21-5f0d-4ba8-95c4-8bf1341e544c/B8991A57-0642-490D-A2BC-8C8B57797066.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. Time complexity of dynamic programming is **O(height of tree*max value among elements)**\n2. **I should’ve compared at lease 2 different cases (true and false cases)**\n3. **greedy can be a good alternative on dynamic programming**\n","source":"_posts/55-Jump-Game.md","raw":"---\ntitle: \"55.\\_Jump Game\"\ncatalog: true\ndate: 2022-09-16 21:31:49\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- You are initially positioned at the array's first index\n- 1 <= nums.length <= 10^4\n- 0 <= nums[i] <= 10^5\n\n## Solve by hands first\n\n---\n\nThis is typical dynamic programing question. but the problem is \n\n## Solution\n\n---\n\n1. **dynamic programming**\n\n```java\nclass Solution {\n    \n    public boolean canJump(int[] nums) {\n        return dfs(nums, 0);\n    }\n    \n    private boolean dfs(int[] nums, int idx) {\n        if(idx == nums.length - 1) return true;\n        if(nums[idx] == 0) return false;\n        \n        boolean t = false;\n        for(int i = 1; i <= nums[idx]; i++) {\n            t |= dfs(nums, idx + i);\n        }\n        \n        return t;\n    }  \n}\n```\n\n![79E23087-0712-4445-8EC9-DC6C3ECBBACC.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a03d7e11-37f5-494c-a2fd-1bb5307d27e2/79E23087-0712-4445-8EC9-DC6C3ECBBACC.jpeg)\n\nproblem of this solution was it gonna run throught the same decision tree again which will end up cause the time limit. The time complexity will be O(m^n) (m: the largest element in array, n: length of array)\n\n![0F8571B2-E301-4976-BF77-C5F862F4C946.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/580f2ae7-af19-448b-9476-b5be187beb42/0F8571B2-E301-4976-BF77-C5F862F4C946.jpeg)\n\nwe can handled the issue by using memoization. Time complexity will be O(n) with more space\n\n1. **greedy**\n\n```java\nclass Solution {\n    \n    public boolean canJump(int[] nums) {\n        int max = 0;\n        for(int i = 0; i < nums.length; i++) {\n            if(max < i) return false;\n            max = Math.max(max, nums[i] + i);\n        }\n        return true;\n    }\n}\n```\n\nwe can come up with greedy solution. so we don’t need either dynamic programing or cahce memory for this. Time complexity will be O(n) in this case. **The key point is that the farest index on each element is less than any index before last index which means we can’t reach to the last index**.\n\n![B8991A57-0642-490D-A2BC-8C8B57797066.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5421fb21-5f0d-4ba8-95c4-8bf1341e544c/B8991A57-0642-490D-A2BC-8C8B57797066.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. Time complexity of dynamic programming is **O(height of tree*max value among elements)**\n2. **I should’ve compared at lease 2 different cases (true and false cases)**\n3. **greedy can be a good alternative on dynamic programming**\n","slug":"55-Jump-Game","published":1,"updated":"2022-09-16T12:32:16.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1e001sqkccmardc9gj","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>You are initially positioned at the array’s first index</li>\n<li>1 &lt;= nums.length &lt;= 10^4</li>\n<li>0 &lt;= nums[i] &lt;= 10^5</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>This is typical dynamic programing question. but the problem is</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<ol>\n<li><strong>dynamic programming</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(idx == nums.length - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[idx] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> t = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= nums[idx]; i++) &#123;</span><br><span class=\"line\">            t |= dfs(nums, idx + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a03d7e11-37f5-494c-a2fd-1bb5307d27e2/79E23087-0712-4445-8EC9-DC6C3ECBBACC.jpeg\" alt=\"79E23087-0712-4445-8EC9-DC6C3ECBBACC.jpeg\"></p>\n<p>problem of this solution was it gonna run throught the same decision tree again which will end up cause the time limit. The time complexity will be O(m^n) (m: the largest element in array, n: length of array)</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/580f2ae7-af19-448b-9476-b5be187beb42/0F8571B2-E301-4976-BF77-C5F862F4C946.jpeg\" alt=\"0F8571B2-E301-4976-BF77-C5F862F4C946.jpeg\"></p>\n<p>we can handled the issue by using memoization. Time complexity will be O(n) with more space</p>\n<ol>\n<li><strong>greedy</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(max &lt; i) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            max = Math.max(max, nums[i] + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>we can come up with greedy solution. so we don’t need either dynamic programing or cahce memory for this. Time complexity will be O(n) in this case. <strong>The key point is that the farest index on each element is less than any index before last index which means we can’t reach to the last index</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5421fb21-5f0d-4ba8-95c4-8bf1341e544c/B8991A57-0642-490D-A2BC-8C8B57797066.jpeg\" alt=\"B8991A57-0642-490D-A2BC-8C8B57797066.jpeg\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>Time complexity of dynamic programming is <em><em>O(height of tree</em>max value among elements)</em>*</li>\n<li><strong>I should’ve compared at lease 2 different cases (true and false cases)</strong></li>\n<li><strong>greedy can be a good alternative on dynamic programming</strong></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>You are initially positioned at the array’s first index</li>\n<li>1 &lt;= nums.length &lt;= 10^4</li>\n<li>0 &lt;= nums[i] &lt;= 10^5</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>This is typical dynamic programing question. but the problem is</p>\n<h2>Solution</h2>\n<hr>\n<ol>\n<li><strong>dynamic programming</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(idx == nums.length - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[idx] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> t = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= nums[idx]; i++) &#123;</span><br><span class=\"line\">            t |= dfs(nums, idx + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a03d7e11-37f5-494c-a2fd-1bb5307d27e2/79E23087-0712-4445-8EC9-DC6C3ECBBACC.jpeg\" alt=\"79E23087-0712-4445-8EC9-DC6C3ECBBACC.jpeg\"></p>\n<p>problem of this solution was it gonna run throught the same decision tree again which will end up cause the time limit. The time complexity will be O(m^n) (m: the largest element in array, n: length of array)</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/580f2ae7-af19-448b-9476-b5be187beb42/0F8571B2-E301-4976-BF77-C5F862F4C946.jpeg\" alt=\"0F8571B2-E301-4976-BF77-C5F862F4C946.jpeg\"></p>\n<p>we can handled the issue by using memoization. Time complexity will be O(n) with more space</p>\n<ol>\n<li><strong>greedy</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(max &lt; i) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            max = Math.max(max, nums[i] + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>we can come up with greedy solution. so we don’t need either dynamic programing or cahce memory for this. Time complexity will be O(n) in this case. <strong>The key point is that the farest index on each element is less than any index before last index which means we can’t reach to the last index</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5421fb21-5f0d-4ba8-95c4-8bf1341e544c/B8991A57-0642-490D-A2BC-8C8B57797066.jpeg\" alt=\"B8991A57-0642-490D-A2BC-8C8B57797066.jpeg\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>Time complexity of dynamic programming is <em><em>O(height of tree</em>max value among elements)</em>*</li>\n<li><strong>I should’ve compared at lease 2 different cases (true and false cases)</strong></li>\n<li><strong>greedy can be a good alternative on dynamic programming</strong></li>\n</ol>\n"},{"title":"54. Spiral Matrix","catalog":true,"date":"2022-09-15T11:19:35.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- return all of the elements of matrix in spiral order\n\n## Solve by hands first\n\n---\n\nIn the most of the matrix problem, we have to consider the four ways (left → right, top → bottom, right → left, bottom → top)\n\n```java\nleft -> rigth : m[0][0] m[0][1] m[0][2]\ntop -> bottom : m[1][2] m[2][2]\nright -> left : m[2][1] m[2][0]\nbottom -> top : m[1][0]\n```\n\nthen we can find some patterns\n\n```java\nleft -> rigth : m[top][0]    m[top][1]    m[top][2]\ntop -> bottom : m[1][right]  m[2][right]\nright -> left : m[bottom][1] m[bottom][0]\nbottom -> top : m[1][left]\n```\n\nin each row or column index, there are the fixed value (top, right, bottom, left) and its columns or rows are increased or decreased. range of the increase or decrease value can be (bottom - top) or (right - left)\n\n```java\nleft -> rigth : m[top][0]    m[top][1]    m[top][2] (right - left)\ntop -> bottom : m[1][right]  m[2][right]            (bottom - top)\nright -> left : m[bottom][1] m[bottom][0]           (right - left)\nbottom -> top : m[1][left]                          (bottom - top)\n```\n\nafter checking the most outlayer done, all we need to do is narrow down the scope (left++, right--, top++, bottom--)\n\n## Solution\n\n---\n\n```python\nclass Solution {\n    public List<Integer> spiralOrder(int[][] m) {\n        \n        List<Integer> list = new ArrayList();\n        \n        int t = 0, b = m.length-1, l = 0, r = m[0].length-1;\n        \n        while(l <= r && t <= b) {\n            \n            for(int i = l; i <= r; i++) { \n                list.add(m[t][i]);\n            }\n            t++;\n            \n            for(int i = t; i <= b; i++) {\n                list.add(m[i][r]);\n            }\n            r--;\n\n            for(int i = r; t <= b && i >= l; i--) {\n                list.add(m[b][i]);\n            }\n            b--;\n            \n            for(int i = b; l <= r && i >= t; i--) {\n                list.add(m[i][l]);\n            }\n            l++;\n        }\n        \n        return list;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eff2ad78-06df-40f2-b00b-655469371d5b/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. we have to consider four different ways in matrix problem \n    - left → right\n    - top → bottom\n    - right → left\n    - bottom → top\n2. In case of top is greater than bottom. so it has to be skipped\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/45e05793-13f6-4fee-87e5-b21107b848cd/Untitled.png)\n\n```java\n// t = 2, b = 1 \nfor(int i = r; t <= b && i >= l; i--) { \n    list.add(m[b][i]);\n}\nb--;\n\nfor(int i = b; l <= r && i >= t; i--) {\n    list.add(m[i][l]);\n}\nl++;\n```\n","source":"_posts/54-Spiral-Matrix.md","raw":"---\ntitle: \"54.\\_Spiral Matrix\"\ncatalog: true\ndate: 2022-09-15 20:19:35\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- return all of the elements of matrix in spiral order\n\n## Solve by hands first\n\n---\n\nIn the most of the matrix problem, we have to consider the four ways (left → right, top → bottom, right → left, bottom → top)\n\n```java\nleft -> rigth : m[0][0] m[0][1] m[0][2]\ntop -> bottom : m[1][2] m[2][2]\nright -> left : m[2][1] m[2][0]\nbottom -> top : m[1][0]\n```\n\nthen we can find some patterns\n\n```java\nleft -> rigth : m[top][0]    m[top][1]    m[top][2]\ntop -> bottom : m[1][right]  m[2][right]\nright -> left : m[bottom][1] m[bottom][0]\nbottom -> top : m[1][left]\n```\n\nin each row or column index, there are the fixed value (top, right, bottom, left) and its columns or rows are increased or decreased. range of the increase or decrease value can be (bottom - top) or (right - left)\n\n```java\nleft -> rigth : m[top][0]    m[top][1]    m[top][2] (right - left)\ntop -> bottom : m[1][right]  m[2][right]            (bottom - top)\nright -> left : m[bottom][1] m[bottom][0]           (right - left)\nbottom -> top : m[1][left]                          (bottom - top)\n```\n\nafter checking the most outlayer done, all we need to do is narrow down the scope (left++, right--, top++, bottom--)\n\n## Solution\n\n---\n\n```python\nclass Solution {\n    public List<Integer> spiralOrder(int[][] m) {\n        \n        List<Integer> list = new ArrayList();\n        \n        int t = 0, b = m.length-1, l = 0, r = m[0].length-1;\n        \n        while(l <= r && t <= b) {\n            \n            for(int i = l; i <= r; i++) { \n                list.add(m[t][i]);\n            }\n            t++;\n            \n            for(int i = t; i <= b; i++) {\n                list.add(m[i][r]);\n            }\n            r--;\n\n            for(int i = r; t <= b && i >= l; i--) {\n                list.add(m[b][i]);\n            }\n            b--;\n            \n            for(int i = b; l <= r && i >= t; i--) {\n                list.add(m[i][l]);\n            }\n            l++;\n        }\n        \n        return list;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eff2ad78-06df-40f2-b00b-655469371d5b/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. we have to consider four different ways in matrix problem \n    - left → right\n    - top → bottom\n    - right → left\n    - bottom → top\n2. In case of top is greater than bottom. so it has to be skipped\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/45e05793-13f6-4fee-87e5-b21107b848cd/Untitled.png)\n\n```java\n// t = 2, b = 1 \nfor(int i = r; t <= b && i >= l; i--) { \n    list.add(m[b][i]);\n}\nb--;\n\nfor(int i = b; l <= r && i >= t; i--) {\n    list.add(m[i][l]);\n}\nl++;\n```\n","slug":"54-Spiral-Matrix","published":1,"updated":"2022-09-15T11:19:58.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1e001tqkccx1i8usl9","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>return all of the elements of matrix in spiral order</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>In the most of the matrix problem, we have to consider the four ways (left → right, top → bottom, right → left, bottom → top)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">left -&gt; rigth : m[<span class=\"number\">0</span>][<span class=\"number\">0</span>] m[<span class=\"number\">0</span>][<span class=\"number\">1</span>] m[<span class=\"number\">0</span>][<span class=\"number\">2</span>]</span><br><span class=\"line\">top -&gt; bottom : m[<span class=\"number\">1</span>][<span class=\"number\">2</span>] m[<span class=\"number\">2</span>][<span class=\"number\">2</span>]</span><br><span class=\"line\">right -&gt; left : m[<span class=\"number\">2</span>][<span class=\"number\">1</span>] m[<span class=\"number\">2</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">bottom -&gt; top : m[<span class=\"number\">1</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>then we can find some patterns</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">left -&gt; rigth : m[top][<span class=\"number\">0</span>]    m[top][<span class=\"number\">1</span>]    m[top][<span class=\"number\">2</span>]</span><br><span class=\"line\">top -&gt; bottom : m[<span class=\"number\">1</span>][right]  m[<span class=\"number\">2</span>][right]</span><br><span class=\"line\">right -&gt; left : m[bottom][<span class=\"number\">1</span>] m[bottom][<span class=\"number\">0</span>]</span><br><span class=\"line\">bottom -&gt; top : m[<span class=\"number\">1</span>][left]</span><br></pre></td></tr></table></figure>\n<p>in each row or column index, there are the fixed value (top, right, bottom, left) and its columns or rows are increased or decreased. range of the increase or decrease value can be (bottom - top) or (right - left)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">left -&gt; rigth : m[top][<span class=\"number\">0</span>]    m[top][<span class=\"number\">1</span>]    m[top][<span class=\"number\">2</span>] (right - left)</span><br><span class=\"line\">top -&gt; bottom : m[<span class=\"number\">1</span>][right]  m[<span class=\"number\">2</span>][right]            (bottom - top)</span><br><span class=\"line\">right -&gt; left : m[bottom][<span class=\"number\">1</span>] m[bottom][<span class=\"number\">0</span>]           (right - left)</span><br><span class=\"line\">bottom -&gt; top : m[<span class=\"number\">1</span>][left]                          (bottom - top)</span><br></pre></td></tr></table></figure>\n<p>after checking the most outlayer done, all we need to do is narrow down the scope (left++, right–, top++, bottom–)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;Integer&gt; spiralOrder(int[][] m) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList();</span><br><span class=\"line\">        </span><br><span class=\"line\">        int t = <span class=\"number\">0</span>, b = m.length<span class=\"number\">-1</span>, l = <span class=\"number\">0</span>, r = m[<span class=\"number\">0</span>].length<span class=\"number\">-1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r &amp;&amp; t &lt;= b) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(int i = l; i &lt;= r; i++) &#123; </span><br><span class=\"line\">                list.add(m[t][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            t++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(int i = t; i &lt;= b; i++) &#123;</span><br><span class=\"line\">                list.add(m[i][r]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            r--;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(int i = r; t &lt;= b &amp;&amp; i &gt;= l; i--) &#123;</span><br><span class=\"line\">                list.add(m[b][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            b--;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(int i = b; l &lt;= r &amp;&amp; i &gt;= t; i--) &#123;</span><br><span class=\"line\">                list.add(m[i][l]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eff2ad78-06df-40f2-b00b-655469371d5b/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>we have to consider four different ways in matrix problem\n<ul>\n<li>left → right</li>\n<li>top → bottom</li>\n<li>right → left</li>\n<li>bottom → top</li>\n</ul>\n</li>\n<li>In case of top is greater than bottom. so it has to be skipped</li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/45e05793-13f6-4fee-87e5-b21107b848cd/Untitled.png\" alt=\"Untitled\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// t = 2, b = 1 </span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = r; t &lt;= b &amp;&amp; i &gt;= l; i--) &#123; </span><br><span class=\"line\">    list.add(m[b][i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">b--;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = b; l &lt;= r &amp;&amp; i &gt;= t; i--) &#123;</span><br><span class=\"line\">    list.add(m[i][l]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">l++;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>return all of the elements of matrix in spiral order</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>In the most of the matrix problem, we have to consider the four ways (left → right, top → bottom, right → left, bottom → top)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">left -&gt; rigth : m[<span class=\"number\">0</span>][<span class=\"number\">0</span>] m[<span class=\"number\">0</span>][<span class=\"number\">1</span>] m[<span class=\"number\">0</span>][<span class=\"number\">2</span>]</span><br><span class=\"line\">top -&gt; bottom : m[<span class=\"number\">1</span>][<span class=\"number\">2</span>] m[<span class=\"number\">2</span>][<span class=\"number\">2</span>]</span><br><span class=\"line\">right -&gt; left : m[<span class=\"number\">2</span>][<span class=\"number\">1</span>] m[<span class=\"number\">2</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">bottom -&gt; top : m[<span class=\"number\">1</span>][<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>then we can find some patterns</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">left -&gt; rigth : m[top][<span class=\"number\">0</span>]    m[top][<span class=\"number\">1</span>]    m[top][<span class=\"number\">2</span>]</span><br><span class=\"line\">top -&gt; bottom : m[<span class=\"number\">1</span>][right]  m[<span class=\"number\">2</span>][right]</span><br><span class=\"line\">right -&gt; left : m[bottom][<span class=\"number\">1</span>] m[bottom][<span class=\"number\">0</span>]</span><br><span class=\"line\">bottom -&gt; top : m[<span class=\"number\">1</span>][left]</span><br></pre></td></tr></table></figure>\n<p>in each row or column index, there are the fixed value (top, right, bottom, left) and its columns or rows are increased or decreased. range of the increase or decrease value can be (bottom - top) or (right - left)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">left -&gt; rigth : m[top][<span class=\"number\">0</span>]    m[top][<span class=\"number\">1</span>]    m[top][<span class=\"number\">2</span>] (right - left)</span><br><span class=\"line\">top -&gt; bottom : m[<span class=\"number\">1</span>][right]  m[<span class=\"number\">2</span>][right]            (bottom - top)</span><br><span class=\"line\">right -&gt; left : m[bottom][<span class=\"number\">1</span>] m[bottom][<span class=\"number\">0</span>]           (right - left)</span><br><span class=\"line\">bottom -&gt; top : m[<span class=\"number\">1</span>][left]                          (bottom - top)</span><br></pre></td></tr></table></figure>\n<p>after checking the most outlayer done, all we need to do is narrow down the scope (left++, right–, top++, bottom–)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;Integer&gt; spiralOrder(int[][] m) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList();</span><br><span class=\"line\">        </span><br><span class=\"line\">        int t = <span class=\"number\">0</span>, b = m.length<span class=\"number\">-1</span>, l = <span class=\"number\">0</span>, r = m[<span class=\"number\">0</span>].length<span class=\"number\">-1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r &amp;&amp; t &lt;= b) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(int i = l; i &lt;= r; i++) &#123; </span><br><span class=\"line\">                list.add(m[t][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            t++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(int i = t; i &lt;= b; i++) &#123;</span><br><span class=\"line\">                list.add(m[i][r]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            r--;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(int i = r; t &lt;= b &amp;&amp; i &gt;= l; i--) &#123;</span><br><span class=\"line\">                list.add(m[b][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            b--;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(int i = b; l &lt;= r &amp;&amp; i &gt;= t; i--) &#123;</span><br><span class=\"line\">                list.add(m[i][l]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eff2ad78-06df-40f2-b00b-655469371d5b/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>we have to consider four different ways in matrix problem\n<ul>\n<li>left → right</li>\n<li>top → bottom</li>\n<li>right → left</li>\n<li>bottom → top</li>\n</ul>\n</li>\n<li>In case of top is greater than bottom. so it has to be skipped</li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/45e05793-13f6-4fee-87e5-b21107b848cd/Untitled.png\" alt=\"Untitled\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// t = 2, b = 1 </span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = r; t &lt;= b &amp;&amp; i &gt;= l; i--) &#123; </span><br><span class=\"line\">    list.add(m[b][i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">b--;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = b; l &lt;= r &amp;&amp; i &gt;= t; i--) &#123;</span><br><span class=\"line\">    list.add(m[i][l]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">l++;</span><br></pre></td></tr></table></figure>\n"},{"title":"56. Merge Intervals","catalog":true,"date":"2022-10-07T14:32:18.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- merge all overlapping intervals\n- return *an array of the non-overlapping intervals that cover all the intervals in the input*\n\n## Solve by hands first\n\n---\n\nwe can sort the array by the start. it makes easy to find the overlappig intervals. we compare the first and next interval, if start of next interval is less than equals to first interval, then we can merge those two intervals. otherwise add the merged interval to list and update the start and end point.\n\nThe problem is when to merge \n\n```java\nint s = intervals[0][0], e = intervals[0][1];\nfor(int[] interval : intervals) {\n    int ns = interval[0];\n    int ne = interval[1];\n    \n\t\t// next start point is less than equals to first end point\n\t\t// then choose whichever larger end from first or next interval\n    if(ns <= e) {\n        e = Math.max(e,ne);\n    } \n}\n```\n\n![9F363ABE-7C34-4109-89C5-DF2BFE5DD8F1.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/62e02e15-07cd-4802-b91b-104c9443c7ff/9F363ABE-7C34-4109-89C5-DF2BFE5DD8F1.jpeg)\n\nAnother problem is when it will added in the list. add start and end when it’s not overlapped. it always leaves the last interval so we need to add it after finishing loop\n\n```java\nint s = intervals[0][0], e = intervals[0][1];\nfor(int[] interval : intervals) {\n    int ns = interval[0];\n    int ne = interval[1];\n    \n    if(ns <= e) {\n        e = Math.max(e,ne);\n    } else {\n        ans.add(new int[]{s, e});\n        s = ns;\n        e = ne;\n    }\n}\nans.add(new int[]{s, e});\n```\n\nTime complexity is O(length of intervals)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        \n        List<int[]> ans = new ArrayList();\n        \n        int s = intervals[0][0], e = intervals[0][1];\n        for(int[] interval : intervals) {\n            int ns = interval[0];\n            int ne = interval[1];\n            \n            if(ns <= e) {\n                e = Math.max(e,ne);\n            } else {\n                ans.add(new int[]{s, e});\n                s = ns;\n                e = ne;\n            }\n        }\n        ans.add(new int[]{s, e});\n\n        return ans.toArray(new int[ans.size()][]);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9a404349-936f-4907-b237-b9719588f132/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. List to array\n    \n    ```java\n    list.toArray(new int[list.size()][]); \n    ```\n","source":"_posts/56-Merge-Intervals.md","raw":"---\ntitle: \"56.\\_Merge Intervals\"\ncatalog: true\ndate: 2022-10-07 23:32:18\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- merge all overlapping intervals\n- return *an array of the non-overlapping intervals that cover all the intervals in the input*\n\n## Solve by hands first\n\n---\n\nwe can sort the array by the start. it makes easy to find the overlappig intervals. we compare the first and next interval, if start of next interval is less than equals to first interval, then we can merge those two intervals. otherwise add the merged interval to list and update the start and end point.\n\nThe problem is when to merge \n\n```java\nint s = intervals[0][0], e = intervals[0][1];\nfor(int[] interval : intervals) {\n    int ns = interval[0];\n    int ne = interval[1];\n    \n\t\t// next start point is less than equals to first end point\n\t\t// then choose whichever larger end from first or next interval\n    if(ns <= e) {\n        e = Math.max(e,ne);\n    } \n}\n```\n\n![9F363ABE-7C34-4109-89C5-DF2BFE5DD8F1.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/62e02e15-07cd-4802-b91b-104c9443c7ff/9F363ABE-7C34-4109-89C5-DF2BFE5DD8F1.jpeg)\n\nAnother problem is when it will added in the list. add start and end when it’s not overlapped. it always leaves the last interval so we need to add it after finishing loop\n\n```java\nint s = intervals[0][0], e = intervals[0][1];\nfor(int[] interval : intervals) {\n    int ns = interval[0];\n    int ne = interval[1];\n    \n    if(ns <= e) {\n        e = Math.max(e,ne);\n    } else {\n        ans.add(new int[]{s, e});\n        s = ns;\n        e = ne;\n    }\n}\nans.add(new int[]{s, e});\n```\n\nTime complexity is O(length of intervals)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        \n        List<int[]> ans = new ArrayList();\n        \n        int s = intervals[0][0], e = intervals[0][1];\n        for(int[] interval : intervals) {\n            int ns = interval[0];\n            int ne = interval[1];\n            \n            if(ns <= e) {\n                e = Math.max(e,ne);\n            } else {\n                ans.add(new int[]{s, e});\n                s = ns;\n                e = ne;\n            }\n        }\n        ans.add(new int[]{s, e});\n\n        return ans.toArray(new int[ans.size()][]);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9a404349-936f-4907-b237-b9719588f132/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. List to array\n    \n    ```java\n    list.toArray(new int[list.size()][]); \n    ```\n","slug":"56-Merge-Intervals","published":1,"updated":"2022-10-07T14:32:33.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1f001uqkccc6lzydg1","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>merge all overlapping intervals</li>\n<li>return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can sort the array by the start. it makes easy to find the overlappig intervals. we compare the first and next interval, if start of next interval is less than equals to first interval, then we can merge those two intervals. otherwise add the merged interval to list and update the start and end point.</p>\n<p>The problem is when to merge</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> s = intervals[<span class=\"number\">0</span>][<span class=\"number\">0</span>], e = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>[] interval : intervals) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ns = interval[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ne = interval[<span class=\"number\">1</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">// next start point is less than equals to first end point</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// then choose whichever larger end from first or next interval</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ns &lt;= e) &#123;</span><br><span class=\"line\">        e = Math.max(e,ne);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/62e02e15-07cd-4802-b91b-104c9443c7ff/9F363ABE-7C34-4109-89C5-DF2BFE5DD8F1.jpeg\" alt=\"9F363ABE-7C34-4109-89C5-DF2BFE5DD8F1.jpeg\"></p>\n<p>Another problem is when it will added in the list. add start and end when it’s not overlapped. it always leaves the last interval so we need to add it after finishing loop</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> s = intervals[<span class=\"number\">0</span>][<span class=\"number\">0</span>], e = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>[] interval : intervals) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ns = interval[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ne = interval[<span class=\"number\">1</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ns &lt;= e) &#123;</span><br><span class=\"line\">        e = Math.max(e,ne);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ans.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;s, e&#125;);</span><br><span class=\"line\">        s = ns;</span><br><span class=\"line\">        e = ne;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ans.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;s, e&#125;);</span><br></pre></td></tr></table></figure>\n<p>Time complexity is O(length of intervals)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] merge(<span class=\"keyword\">int</span>[][] intervals) &#123;</span><br><span class=\"line\">        Arrays.sort(intervals, (a, b) -&gt; a[<span class=\"number\">0</span>] - b[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;<span class=\"keyword\">int</span>[]&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = intervals[<span class=\"number\">0</span>][<span class=\"number\">0</span>], e = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>[] interval : intervals) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ns = interval[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ne = interval[<span class=\"number\">1</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ns &lt;= e) &#123;</span><br><span class=\"line\">                e = Math.max(e,ne);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;s, e&#125;);</span><br><span class=\"line\">                s = ns;</span><br><span class=\"line\">                e = ne;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;s, e&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.toArray(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[ans.size()][]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9a404349-936f-4907-b237-b9719588f132/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>List to array</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.toArray(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[list.size()][]);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>merge all overlapping intervals</li>\n<li>return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can sort the array by the start. it makes easy to find the overlappig intervals. we compare the first and next interval, if start of next interval is less than equals to first interval, then we can merge those two intervals. otherwise add the merged interval to list and update the start and end point.</p>\n<p>The problem is when to merge</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> s = intervals[<span class=\"number\">0</span>][<span class=\"number\">0</span>], e = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>[] interval : intervals) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ns = interval[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ne = interval[<span class=\"number\">1</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">// next start point is less than equals to first end point</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// then choose whichever larger end from first or next interval</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ns &lt;= e) &#123;</span><br><span class=\"line\">        e = Math.max(e,ne);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/62e02e15-07cd-4802-b91b-104c9443c7ff/9F363ABE-7C34-4109-89C5-DF2BFE5DD8F1.jpeg\" alt=\"9F363ABE-7C34-4109-89C5-DF2BFE5DD8F1.jpeg\"></p>\n<p>Another problem is when it will added in the list. add start and end when it’s not overlapped. it always leaves the last interval so we need to add it after finishing loop</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> s = intervals[<span class=\"number\">0</span>][<span class=\"number\">0</span>], e = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>[] interval : intervals) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ns = interval[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ne = interval[<span class=\"number\">1</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ns &lt;= e) &#123;</span><br><span class=\"line\">        e = Math.max(e,ne);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ans.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;s, e&#125;);</span><br><span class=\"line\">        s = ns;</span><br><span class=\"line\">        e = ne;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ans.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;s, e&#125;);</span><br></pre></td></tr></table></figure>\n<p>Time complexity is O(length of intervals)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] merge(<span class=\"keyword\">int</span>[][] intervals) &#123;</span><br><span class=\"line\">        Arrays.sort(intervals, (a, b) -&gt; a[<span class=\"number\">0</span>] - b[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;<span class=\"keyword\">int</span>[]&gt; ans = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = intervals[<span class=\"number\">0</span>][<span class=\"number\">0</span>], e = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>[] interval : intervals) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ns = interval[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ne = interval[<span class=\"number\">1</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ns &lt;= e) &#123;</span><br><span class=\"line\">                e = Math.max(e,ne);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;s, e&#125;);</span><br><span class=\"line\">                s = ns;</span><br><span class=\"line\">                e = ne;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;s, e&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.toArray(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[ans.size()][]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9a404349-936f-4907-b237-b9719588f132/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>List to array</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list.toArray(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[list.size()][]);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"57. Insert Interval","catalog":true,"date":"2022-09-25T02:50:20.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- Return `intervals` *after the insertion*\n- 0 <= starti <= endi <= 105\n- `intervals` is sorted by `starti` in **ascending** order.\n\n## Solve by hands first\n\n---\n\nif the start point of new intervals is greater than start and end point of current interval then it can not be overlapped. start point of new interval is greater than equals to start of current interval and less than end of current interval which means it is overlapping interval. now we can overlap the current interval and new interval which has new start and end point. it’s important to understand that **we should compare to newly created interval and next current interval**. for instance current interval is [3, 5] and new interval is [4, 8], after overlapping new interval becomes [3, 8] now we have to compare with this values.\n\n![1A0BBFAC-7F63-4FFA-B4E3-C5FC5A7E6E00.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/05bfd3b3-dd79-4bb2-8873-8cdf33ff492c/1A0BBFAC-7F63-4FFA-B4E3-C5FC5A7E6E00.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int[][] insert(int[][] inv, int[] nInv) {\n        List<int[]> list = new ArrayList();\n        \n        for(int i = 0; i < inv.length; i++) {  \n            int cs = inv[i][0];\n            int ce = inv[i][1];\n            \n            int ns = nInv[0];\n            int ne = nInv[1];\n            \n            if(ce < ns) {\n                list.add(inv[i]);\n            } else if(cs > ne) {\n                list.add(nInv);\n                // insert the rest of interval\n                for(;i < inv.length; i++) {\n                    list.add(inv[i]);\n                }\n                return toMetrix(list);\n            } else {\n                // overlapping\n                nInv[0] = Math.min(cs, ns);\n                nInv[1] = Math.max(ce, ne);\n            }\n        }   \n        \n        list.add(nInv);\n        \n        return toMetrix(list);\n    }\n    \n    private int[][] toMetrix(List<int[]> list) {\n        int[][] ans = new int[list.size()][2];\n        for(int i = 0; i < list.size(); i++) {\n            ans[i] = list.get(i);\n        }\n        return ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/350b4862-fd6c-4c02-9ad3-eab435f18454/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. define the edge case first!\n    \n    ```java\n    if(ce < ns) {\n    \t// current interval is alway less than new interval\t= edge case\n    } else if(cs > ne) {\n    \t// current interval is alway greater than new interval = edge case\n    } else {\n    \t// overlapping case\n    }\n    ```\n    \n2. can return within the loop if it doesn’t need to iterate to the end\n    \n    ```java\n    else if(cs > ne) {\n        list.add(nInv);\n        for(;i < inv.length; i++) {\n            list.add(inv[i]);\n        }\n        return toMetrix(list); // we don't need to check rest of metrix\n    }\n    ```\n    \n3. in case of return in the middle of loop, there must be cases that did not check the condition has the return statement. so we have to add the logic in the condition out of loop \n    \n    ```java\n    for(int i = 0; i < inv.length; i++) {        \n          if(ce < ns) {\n              list.add(inv[i]);\n          } else if(cs > ne) {\n              list.add(nInv);  // this can not be called!\n              for(;i < inv.length; i++) {\n                  list.add(inv[i]);\n              }\n              return toMetrix(list);\n          } else {\n              nInv[0] = Math.min(cs, ns);\n              nInv[1] = Math.max(ce, ne);\n          }\n      }   \n      \n      list.add(nInv);  // so we have to add that logic\n    ```\n","source":"_posts/57-Insert-Interval.md","raw":"---\ntitle: \"57.\\_Insert Interval\"\ncatalog: true\ndate: 2022-09-25 11:50:20\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- Return `intervals` *after the insertion*\n- 0 <= starti <= endi <= 105\n- `intervals` is sorted by `starti` in **ascending** order.\n\n## Solve by hands first\n\n---\n\nif the start point of new intervals is greater than start and end point of current interval then it can not be overlapped. start point of new interval is greater than equals to start of current interval and less than end of current interval which means it is overlapping interval. now we can overlap the current interval and new interval which has new start and end point. it’s important to understand that **we should compare to newly created interval and next current interval**. for instance current interval is [3, 5] and new interval is [4, 8], after overlapping new interval becomes [3, 8] now we have to compare with this values.\n\n![1A0BBFAC-7F63-4FFA-B4E3-C5FC5A7E6E00.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/05bfd3b3-dd79-4bb2-8873-8cdf33ff492c/1A0BBFAC-7F63-4FFA-B4E3-C5FC5A7E6E00.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public int[][] insert(int[][] inv, int[] nInv) {\n        List<int[]> list = new ArrayList();\n        \n        for(int i = 0; i < inv.length; i++) {  \n            int cs = inv[i][0];\n            int ce = inv[i][1];\n            \n            int ns = nInv[0];\n            int ne = nInv[1];\n            \n            if(ce < ns) {\n                list.add(inv[i]);\n            } else if(cs > ne) {\n                list.add(nInv);\n                // insert the rest of interval\n                for(;i < inv.length; i++) {\n                    list.add(inv[i]);\n                }\n                return toMetrix(list);\n            } else {\n                // overlapping\n                nInv[0] = Math.min(cs, ns);\n                nInv[1] = Math.max(ce, ne);\n            }\n        }   \n        \n        list.add(nInv);\n        \n        return toMetrix(list);\n    }\n    \n    private int[][] toMetrix(List<int[]> list) {\n        int[][] ans = new int[list.size()][2];\n        for(int i = 0; i < list.size(); i++) {\n            ans[i] = list.get(i);\n        }\n        return ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/350b4862-fd6c-4c02-9ad3-eab435f18454/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. define the edge case first!\n    \n    ```java\n    if(ce < ns) {\n    \t// current interval is alway less than new interval\t= edge case\n    } else if(cs > ne) {\n    \t// current interval is alway greater than new interval = edge case\n    } else {\n    \t// overlapping case\n    }\n    ```\n    \n2. can return within the loop if it doesn’t need to iterate to the end\n    \n    ```java\n    else if(cs > ne) {\n        list.add(nInv);\n        for(;i < inv.length; i++) {\n            list.add(inv[i]);\n        }\n        return toMetrix(list); // we don't need to check rest of metrix\n    }\n    ```\n    \n3. in case of return in the middle of loop, there must be cases that did not check the condition has the return statement. so we have to add the logic in the condition out of loop \n    \n    ```java\n    for(int i = 0; i < inv.length; i++) {        \n          if(ce < ns) {\n              list.add(inv[i]);\n          } else if(cs > ne) {\n              list.add(nInv);  // this can not be called!\n              for(;i < inv.length; i++) {\n                  list.add(inv[i]);\n              }\n              return toMetrix(list);\n          } else {\n              nInv[0] = Math.min(cs, ns);\n              nInv[1] = Math.max(ce, ne);\n          }\n      }   \n      \n      list.add(nInv);  // so we have to add that logic\n    ```\n","slug":"57-Insert-Interval","published":1,"updated":"2022-09-25T02:50:43.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1f001vqkcc5mqoyln0","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>Return <code>intervals</code> <em>after the insertion</em></li>\n<li>0 &lt;= starti &lt;= endi &lt;= 105</li>\n<li><code>intervals</code> is sorted by <code>starti</code> in <strong>ascending</strong> order.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>if the start point of new intervals is greater than start and end point of current interval then it can not be overlapped. start point of new interval is greater than equals to start of current interval and less than end of current interval which means it is overlapping interval. now we can overlap the current interval and new interval which has new start and end point. it’s important to understand that <strong>we should compare to newly created interval and next current interval</strong>. for instance current interval is [3, 5] and new interval is [4, 8], after overlapping new interval becomes [3, 8] now we have to compare with this values.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/05bfd3b3-dd79-4bb2-8873-8cdf33ff492c/1A0BBFAC-7F63-4FFA-B4E3-C5FC5A7E6E00.jpeg\" alt=\"1A0BBFAC-7F63-4FFA-B4E3-C5FC5A7E6E00.jpeg\"></p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] insert(<span class=\"keyword\">int</span>[][] inv, <span class=\"keyword\">int</span>[] nInv) &#123;</span><br><span class=\"line\">        List&lt;<span class=\"keyword\">int</span>[]&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; inv.length; i++) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> cs = inv[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ce = inv[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> ns = nInv[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ne = nInv[<span class=\"number\">1</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ce &lt; ns) &#123;</span><br><span class=\"line\">                list.add(inv[i]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(cs &gt; ne) &#123;</span><br><span class=\"line\">                list.add(nInv);</span><br><span class=\"line\">                <span class=\"comment\">// insert the rest of interval</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(;i &lt; inv.length; i++) &#123;</span><br><span class=\"line\">                    list.add(inv[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> toMetrix(list);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// overlapping</span></span><br><span class=\"line\">                nInv[<span class=\"number\">0</span>] = Math.min(cs, ns);</span><br><span class=\"line\">                nInv[<span class=\"number\">1</span>] = Math.max(ce, ne);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        </span><br><span class=\"line\">        list.add(nInv);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> toMetrix(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] toMetrix(List&lt;<span class=\"keyword\">int</span>[]&gt; list) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[list.size()][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">            ans[i] = list.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/350b4862-fd6c-4c02-9ad3-eab435f18454/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>define the edge case first!</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(ce &lt; ns) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// current interval is alway less than new interval\t= edge case</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(cs &gt; ne) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// current interval is alway greater than new interval = edge case</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// overlapping case</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>can return within the loop if it doesn’t need to iterate to the end</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(cs &gt; ne) &#123;</span><br><span class=\"line\">    list.add(nInv);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i &lt; inv.length; i++) &#123;</span><br><span class=\"line\">        list.add(inv[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> toMetrix(list); <span class=\"comment\">// we don't need to check rest of metrix</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>in case of return in the middle of loop, there must be cases that did not check the condition has the return statement. so we have to add the logic in the condition out of loop</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; inv.length; i++) &#123;        </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(ce &lt; ns) &#123;</span><br><span class=\"line\">          list.add(inv[i]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(cs &gt; ne) &#123;</span><br><span class=\"line\">          list.add(nInv);  <span class=\"comment\">// this can not be called!</span></span><br><span class=\"line\">          <span class=\"keyword\">for</span>(;i &lt; inv.length; i++) &#123;</span><br><span class=\"line\">              list.add(inv[i]);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> toMetrix(list);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          nInv[<span class=\"number\">0</span>] = Math.min(cs, ns);</span><br><span class=\"line\">          nInv[<span class=\"number\">1</span>] = Math.max(ce, ne);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\">  </span><br><span class=\"line\">  list.add(nInv);  <span class=\"comment\">// so we have to add that logic</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>Return <code>intervals</code> <em>after the insertion</em></li>\n<li>0 &lt;= starti &lt;= endi &lt;= 105</li>\n<li><code>intervals</code> is sorted by <code>starti</code> in <strong>ascending</strong> order.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>if the start point of new intervals is greater than start and end point of current interval then it can not be overlapped. start point of new interval is greater than equals to start of current interval and less than end of current interval which means it is overlapping interval. now we can overlap the current interval and new interval which has new start and end point. it’s important to understand that <strong>we should compare to newly created interval and next current interval</strong>. for instance current interval is [3, 5] and new interval is [4, 8], after overlapping new interval becomes [3, 8] now we have to compare with this values.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/05bfd3b3-dd79-4bb2-8873-8cdf33ff492c/1A0BBFAC-7F63-4FFA-B4E3-C5FC5A7E6E00.jpeg\" alt=\"1A0BBFAC-7F63-4FFA-B4E3-C5FC5A7E6E00.jpeg\"></p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] insert(<span class=\"keyword\">int</span>[][] inv, <span class=\"keyword\">int</span>[] nInv) &#123;</span><br><span class=\"line\">        List&lt;<span class=\"keyword\">int</span>[]&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; inv.length; i++) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> cs = inv[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ce = inv[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">int</span> ns = nInv[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ne = nInv[<span class=\"number\">1</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ce &lt; ns) &#123;</span><br><span class=\"line\">                list.add(inv[i]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(cs &gt; ne) &#123;</span><br><span class=\"line\">                list.add(nInv);</span><br><span class=\"line\">                <span class=\"comment\">// insert the rest of interval</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(;i &lt; inv.length; i++) &#123;</span><br><span class=\"line\">                    list.add(inv[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> toMetrix(list);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// overlapping</span></span><br><span class=\"line\">                nInv[<span class=\"number\">0</span>] = Math.min(cs, ns);</span><br><span class=\"line\">                nInv[<span class=\"number\">1</span>] = Math.max(ce, ne);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        </span><br><span class=\"line\">        list.add(nInv);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> toMetrix(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] toMetrix(List&lt;<span class=\"keyword\">int</span>[]&gt; list) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[list.size()][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">            ans[i] = list.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/350b4862-fd6c-4c02-9ad3-eab435f18454/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>define the edge case first!</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(ce &lt; ns) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// current interval is alway less than new interval\t= edge case</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(cs &gt; ne) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// current interval is alway greater than new interval = edge case</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// overlapping case</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>can return within the loop if it doesn’t need to iterate to the end</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(cs &gt; ne) &#123;</span><br><span class=\"line\">    list.add(nInv);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i &lt; inv.length; i++) &#123;</span><br><span class=\"line\">        list.add(inv[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> toMetrix(list); <span class=\"comment\">// we don't need to check rest of metrix</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>in case of return in the middle of loop, there must be cases that did not check the condition has the return statement. so we have to add the logic in the condition out of loop</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; inv.length; i++) &#123;        </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(ce &lt; ns) &#123;</span><br><span class=\"line\">          list.add(inv[i]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(cs &gt; ne) &#123;</span><br><span class=\"line\">          list.add(nInv);  <span class=\"comment\">// this can not be called!</span></span><br><span class=\"line\">          <span class=\"keyword\">for</span>(;i &lt; inv.length; i++) &#123;</span><br><span class=\"line\">              list.add(inv[i]);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> toMetrix(list);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          nInv[<span class=\"number\">0</span>] = Math.min(cs, ns);</span><br><span class=\"line\">          nInv[<span class=\"number\">1</span>] = Math.max(ce, ne);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\">  </span><br><span class=\"line\">  list.add(nInv);  <span class=\"comment\">// so we have to add that logic</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"62. Unique Paths","catalog":true,"date":"2022-10-06T14:24:34.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- The robot tries to move to the **bottom-right corner**\n- The robot can only move either down or right at any point in time.\n- return *the number of possible unique paths that the robot can take to reach the bottom-right corner*\n- so that the answer will be less than or equal to `2 * 10^9`\n\n## Solve by hands first\n\n---\n\nwe can use dynamic programming with memoization. we can implement both bottom-up and top-down approach. \n\nThe point is first rows and columns is always filled with 1. because it only can go to right or bottom. **it is base case.** The general term of dynamic programming is `*dp[i][j] = dp[i-1][j] + dp[i][j-1]*`\n\n## Solution\n\n---\n\n### bottom up\n\n```java\nclass Solution {\n    \n    public int uniquePaths(int m, int n) (int m, int n) {\n        dp = new Integer[m+1][n+1];\n        return dfs(m,n);\n    }\n    \n    private int dfs(int m, int n) {\n        if(m == 1 && n == 1) return 1;\n        if(m == 1 || n == 1) return 1;\n        if(dp[m][n] != null) return dp[m][n];\n        \n        return dp[m][n] = dfs(m-1, n) + dfs(m, n-1);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b6b8db8-883e-423e-b2e8-a89e00235ea9/Untitled.png)\n\n![97D7AA1E-D074-44F0-93F0-0F3D8BDF628D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/911fadb1-473a-4682-a6bd-26c34851e7ea/97D7AA1E-D074-44F0-93F0-0F3D8BDF628D.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. Similar problems\n    - [91. Decode Ways](https://leetcode.com/problems/decode-ways)\n    - [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)\n    - [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)\n2. it is very important to define the base case\n\n```java\nprivate int dfs(int m, int n) {\n\t\t// base case\n    if(m == 1 && n == 1) return 1;\n    if(m == 1 || n == 1) return 1;\n    \n    return dp[m][n] = dfs(m-1, n) + dfs(m, n-1);\n}\n```\n        int[][] dp = new int[m+1][n+1];\n        \n        for(int i = 0; i <= m; i++) dp[i][0] = 1;\n        for(int i = 0; i <= n; i++) dp[0][i] = 1;\n       \n        for(int i = 1; i < m; i++) {\n            for(int j = 1; j < n; j++) {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n        \n        return dp[m-1][n-1];\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0c48bc8d-800a-4250-80e0-2b9d9a2570b8/Untitled.png)\n\n![333F363A-7719-4EC4-B252-49E36731A98C.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bf6268b6-7926-4a33-8dab-317c38e4ef12/333F363A-7719-4EC4-B252-49E36731A98C.jpeg)\n\n### top down\n\n```java\nclass Solution {\n    \n    Integer[][] dp;\n    \n    public int uniquePaths{\n","source":"_posts/62-Unique-Paths.md","raw":"---\ntitle: \"62.\\_Unique Paths\"\ncatalog: true\ndate: 2022-10-06 23:24:34\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- The robot tries to move to the **bottom-right corner**\n- The robot can only move either down or right at any point in time.\n- return *the number of possible unique paths that the robot can take to reach the bottom-right corner*\n- so that the answer will be less than or equal to `2 * 10^9`\n\n## Solve by hands first\n\n---\n\nwe can use dynamic programming with memoization. we can implement both bottom-up and top-down approach. \n\nThe point is first rows and columns is always filled with 1. because it only can go to right or bottom. **it is base case.** The general term of dynamic programming is `*dp[i][j] = dp[i-1][j] + dp[i][j-1]*`\n\n## Solution\n\n---\n\n### bottom up\n\n```java\nclass Solution {\n    \n    public int uniquePaths(int m, int n) (int m, int n) {\n        dp = new Integer[m+1][n+1];\n        return dfs(m,n);\n    }\n    \n    private int dfs(int m, int n) {\n        if(m == 1 && n == 1) return 1;\n        if(m == 1 || n == 1) return 1;\n        if(dp[m][n] != null) return dp[m][n];\n        \n        return dp[m][n] = dfs(m-1, n) + dfs(m, n-1);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b6b8db8-883e-423e-b2e8-a89e00235ea9/Untitled.png)\n\n![97D7AA1E-D074-44F0-93F0-0F3D8BDF628D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/911fadb1-473a-4682-a6bd-26c34851e7ea/97D7AA1E-D074-44F0-93F0-0F3D8BDF628D.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. Similar problems\n    - [91. Decode Ways](https://leetcode.com/problems/decode-ways)\n    - [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)\n    - [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)\n2. it is very important to define the base case\n\n```java\nprivate int dfs(int m, int n) {\n\t\t// base case\n    if(m == 1 && n == 1) return 1;\n    if(m == 1 || n == 1) return 1;\n    \n    return dp[m][n] = dfs(m-1, n) + dfs(m, n-1);\n}\n```\n        int[][] dp = new int[m+1][n+1];\n        \n        for(int i = 0; i <= m; i++) dp[i][0] = 1;\n        for(int i = 0; i <= n; i++) dp[0][i] = 1;\n       \n        for(int i = 1; i < m; i++) {\n            for(int j = 1; j < n; j++) {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n        \n        return dp[m-1][n-1];\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0c48bc8d-800a-4250-80e0-2b9d9a2570b8/Untitled.png)\n\n![333F363A-7719-4EC4-B252-49E36731A98C.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bf6268b6-7926-4a33-8dab-317c38e4ef12/333F363A-7719-4EC4-B252-49E36731A98C.jpeg)\n\n### top down\n\n```java\nclass Solution {\n    \n    Integer[][] dp;\n    \n    public int uniquePaths{\n","slug":"62-Unique-Paths","published":1,"updated":"2022-10-06T14:24:48.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1f001wqkccblivr9ll","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>The robot tries to move to the <strong>bottom-right corner</strong></li>\n<li>The robot can only move either down or right at any point in time.</li>\n<li>return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em></li>\n<li>so that the answer will be less than or equal to <code>2 * 10^9</code></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can use dynamic programming with memoization. we can implement both bottom-up and top-down approach.</p>\n<p>The point is first rows and columns is always filled with 1. because it only can go to right or bottom. <strong>it is base case.</strong> The general term of dynamic programming is <code>*dp[i][j] = dp[i-1][j] + dp[i][j-1]*</code></p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<h3><span id=\"bottom-up\">bottom up</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> <span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> Integer[m+<span class=\"number\">1</span>][n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(m,n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m == <span class=\"number\">1</span> &amp;&amp; n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m == <span class=\"number\">1</span> || n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[m][n] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n] = dfs(m-<span class=\"number\">1</span>, n) + dfs(m, n-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b6b8db8-883e-423e-b2e8-a89e00235ea9/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/911fadb1-473a-4682-a6bd-26c34851e7ea/97D7AA1E-D074-44F0-93F0-0F3D8BDF628D.jpeg\" alt=\"97D7AA1E-D074-44F0-93F0-0F3D8BDF628D.jpeg\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>Similar problems\n<ul>\n<li><a href=\"https://leetcode.com/problems/decode-ways\" target=\"_blank\" rel=\"noopener\">91. Decode Ways</a></li>\n<li><a href=\"https://leetcode.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">70. Climbing Stairs</a></li>\n<li><a href=\"https://leetcode.com/problems/fibonacci-number/\" target=\"_blank\" rel=\"noopener\">509. Fibonacci Number</a></li>\n</ul>\n</li>\n<li>it is very important to define the base case</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// base case</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m == <span class=\"number\">1</span> &amp;&amp; n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m == <span class=\"number\">1</span> || n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[m][n] = dfs(m-<span class=\"number\">1</span>, n) + dfs(m, n-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>    int[][] dp = new int[m+1][n+1];\n    \n    for(int i = 0; i &lt;= m; i++) dp[i][0] = 1;\n    for(int i = 0; i &lt;= n; i++) dp[0][i] = 1;\n   \n    for(int i = 1; i &lt; m; i++) {\n        for(int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n    \n    return dp[m-1][n-1];\n}\n</code></pre>\n<p>}</p>\n<pre><code>\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0c48bc8d-800a-4250-80e0-2b9d9a2570b8/Untitled.png)\n\n![333F363A-7719-4EC4-B252-49E36731A98C.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bf6268b6-7926-4a33-8dab-317c38e4ef12/333F363A-7719-4EC4-B252-49E36731A98C.jpeg)\n\n### top down\n\n```java\nclass Solution {\n    \n    Integer[][] dp;\n    \n    public int uniquePaths{\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>The robot tries to move to the <strong>bottom-right corner</strong></li>\n<li>The robot can only move either down or right at any point in time.</li>\n<li>return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em></li>\n<li>so that the answer will be less than or equal to <code>2 * 10^9</code></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can use dynamic programming with memoization. we can implement both bottom-up and top-down approach.</p>\n<p>The point is first rows and columns is always filled with 1. because it only can go to right or bottom. <strong>it is base case.</strong> The general term of dynamic programming is <code>*dp[i][j] = dp[i-1][j] + dp[i][j-1]*</code></p>\n<h2>Solution</h2>\n<hr>\n<h3>bottom up</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> <span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> Integer[m+<span class=\"number\">1</span>][n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(m,n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m == <span class=\"number\">1</span> &amp;&amp; n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m == <span class=\"number\">1</span> || n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[m][n] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n] = dfs(m-<span class=\"number\">1</span>, n) + dfs(m, n-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b6b8db8-883e-423e-b2e8-a89e00235ea9/Untitled.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/911fadb1-473a-4682-a6bd-26c34851e7ea/97D7AA1E-D074-44F0-93F0-0F3D8BDF628D.jpeg\" alt=\"97D7AA1E-D074-44F0-93F0-0F3D8BDF628D.jpeg\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>Similar problems\n<ul>\n<li><a href=\"https://leetcode.com/problems/decode-ways\" target=\"_blank\" rel=\"noopener\">91. Decode Ways</a></li>\n<li><a href=\"https://leetcode.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">70. Climbing Stairs</a></li>\n<li><a href=\"https://leetcode.com/problems/fibonacci-number/\" target=\"_blank\" rel=\"noopener\">509. Fibonacci Number</a></li>\n</ul>\n</li>\n<li>it is very important to define the base case</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// base case</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m == <span class=\"number\">1</span> &amp;&amp; n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m == <span class=\"number\">1</span> || n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[m][n] = dfs(m-<span class=\"number\">1</span>, n) + dfs(m, n-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>    int[][] dp = new int[m+1][n+1];\n    \n    for(int i = 0; i &lt;= m; i++) dp[i][0] = 1;\n    for(int i = 0; i &lt;= n; i++) dp[0][i] = 1;\n   \n    for(int i = 1; i &lt; m; i++) {\n        for(int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n    \n    return dp[m-1][n-1];\n}\n</code></pre>\n<p>}</p>\n<pre><code>\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0c48bc8d-800a-4250-80e0-2b9d9a2570b8/Untitled.png)\n\n![333F363A-7719-4EC4-B252-49E36731A98C.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bf6268b6-7926-4a33-8dab-317c38e4ef12/333F363A-7719-4EC4-B252-49E36731A98C.jpeg)\n\n### top down\n\n```java\nclass Solution {\n    \n    Integer[][] dp;\n    \n    public int uniquePaths{\n</code></pre>\n"},{"title":"572. Subtree of Another Tree","catalog":true,"date":"2022-09-28T01:17:44.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- two **binary trees** `root` and `subRoot`\n- return `true` if there is a subtree of `root` with the same structure and node values of `subRoot`\n\n## Solve by hands first\n\n---\n\nwe can start with DFS first. one we find the value of subRoot in root Tree, then move to the same direction of child node for both of subRoot and root tree. once complete traverse subRoot tree then return true if root tree has the same subtree otherwise false\n\nOne of the constraint that I couldn’t notice is tree does not have child node in terms of the same structure. so it can be easier to return condition at DFS algorithm\n\n![FE9CC412-5EEC-45B2-9259-794EAD021E8D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a33c168f-daaf-4e31-b112-466585656805/FE9CC412-5EEC-45B2-9259-794EAD021E8D.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        if(root == null) return false;\n \n        if(isSame(root, subRoot)) return true;\n        \n        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n    }\n    \n    private boolean isSame(TreeNode root, TreeNode subRoot) {\n        if(root == null && subRoot == null) return true;\n        if(root == null || subRoot == null) return false;\n        \n        if(root.val != subRoot.val) return false;\n\n        return isSame(root.left, subRoot.left) && isSame(root.right, subRoot.right);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a763a04-c2e4-4b79-a4a2-d2475f472a65/Untitled.png)\n\nThere are two ways of traversal\n\n1. traverse binary tree until last node (left or right)\n2. traverse the same structured and value node until both of node are null (left or right)\n\nfirst case is that we need to traverse left and right node until the last node. in the meantime we have to check if the value of root and subRoot is the same or not. if it is true, then we start traverse to see if both of tree have the same structure and value\n\n```java\npublic boolean isSubtree(TreeNode root, TreeNode subRoot) {\n    if(root == null) return false; // return when it's last node\n    \n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}\n```\n\nsecond case is that we can back on to normal binary tree traversal when both of value is not the same. it means that it keep traversing the root tree to the last node. so it’s important to know that we can return to binary tree traveresal when it’s not the same value.\n\nthen if the value of both trees has the same value then return true or if one of the node has child node then return false since it doesn’t have same structure. \n\nwhen spilt to left and right node, we used `&&` which mean all of the child node has to be the same. if there is false from one of the descentant, then return false \n\n```java\nprivate boolean isSame(TreeNode root, TreeNode subRoot) {\n    if(root == null && subRoot == null) return true; // if both last node is null, it could be same structure\n    if(root == null || subRoot == null) return false; // if one of the node has child node, it doesn't have same structure\n    \n    if(root.val != subRoot.val) return false; // if it's not the same value we can go back to normal traverse which is isSubtree method\n\n    return isSame(root.left, subRoot.left) && isSame(root.right, subRoot.right); \n}\n```\n\n## Lesson I learnt\n\n---\n\n1. DFS has another DFS stream \n2. important to set return point in DFS\n","source":"_posts/572-Subtree-of-Another-Tree.md","raw":"---\ntitle: \"572.\\_Subtree of Another Tree\"\ncatalog: true\ndate: 2022-09-28 10:17:44\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- two **binary trees** `root` and `subRoot`\n- return `true` if there is a subtree of `root` with the same structure and node values of `subRoot`\n\n## Solve by hands first\n\n---\n\nwe can start with DFS first. one we find the value of subRoot in root Tree, then move to the same direction of child node for both of subRoot and root tree. once complete traverse subRoot tree then return true if root tree has the same subtree otherwise false\n\nOne of the constraint that I couldn’t notice is tree does not have child node in terms of the same structure. so it can be easier to return condition at DFS algorithm\n\n![FE9CC412-5EEC-45B2-9259-794EAD021E8D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a33c168f-daaf-4e31-b112-466585656805/FE9CC412-5EEC-45B2-9259-794EAD021E8D.jpeg)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        if(root == null) return false;\n \n        if(isSame(root, subRoot)) return true;\n        \n        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n    }\n    \n    private boolean isSame(TreeNode root, TreeNode subRoot) {\n        if(root == null && subRoot == null) return true;\n        if(root == null || subRoot == null) return false;\n        \n        if(root.val != subRoot.val) return false;\n\n        return isSame(root.left, subRoot.left) && isSame(root.right, subRoot.right);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a763a04-c2e4-4b79-a4a2-d2475f472a65/Untitled.png)\n\nThere are two ways of traversal\n\n1. traverse binary tree until last node (left or right)\n2. traverse the same structured and value node until both of node are null (left or right)\n\nfirst case is that we need to traverse left and right node until the last node. in the meantime we have to check if the value of root and subRoot is the same or not. if it is true, then we start traverse to see if both of tree have the same structure and value\n\n```java\npublic boolean isSubtree(TreeNode root, TreeNode subRoot) {\n    if(root == null) return false; // return when it's last node\n    \n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}\n```\n\nsecond case is that we can back on to normal binary tree traversal when both of value is not the same. it means that it keep traversing the root tree to the last node. so it’s important to know that we can return to binary tree traveresal when it’s not the same value.\n\nthen if the value of both trees has the same value then return true or if one of the node has child node then return false since it doesn’t have same structure. \n\nwhen spilt to left and right node, we used `&&` which mean all of the child node has to be the same. if there is false from one of the descentant, then return false \n\n```java\nprivate boolean isSame(TreeNode root, TreeNode subRoot) {\n    if(root == null && subRoot == null) return true; // if both last node is null, it could be same structure\n    if(root == null || subRoot == null) return false; // if one of the node has child node, it doesn't have same structure\n    \n    if(root.val != subRoot.val) return false; // if it's not the same value we can go back to normal traverse which is isSubtree method\n\n    return isSame(root.left, subRoot.left) && isSame(root.right, subRoot.right); \n}\n```\n\n## Lesson I learnt\n\n---\n\n1. DFS has another DFS stream \n2. important to set return point in DFS\n","slug":"572-Subtree-of-Another-Tree","published":1,"updated":"2022-09-28T01:22:16.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1f001xqkcc442rgkn0","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>two <strong>binary trees</strong> <code>root</code> and <code>subRoot</code></li>\n<li>return <code>true</code> if there is a subtree of <code>root</code> with the same structure and node values of <code>subRoot</code></li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can start with DFS first. one we find the value of subRoot in root Tree, then move to the same direction of child node for both of subRoot and root tree. once complete traverse subRoot tree then return true if root tree has the same subtree otherwise false</p>\n<p>One of the constraint that I couldn’t notice is tree does not have child node in terms of the same structure. so it can be easier to return condition at DFS algorithm</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a33c168f-daaf-4e31-b112-466585656805/FE9CC412-5EEC-45B2-9259-794EAD021E8D.jpeg\" alt=\"FE9CC412-5EEC-45B2-9259-794EAD021E8D.jpeg\"></p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSubtree</span><span class=\"params\">(TreeNode root, TreeNode subRoot)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isSame(root, subRoot)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSame</span><span class=\"params\">(TreeNode root, TreeNode subRoot)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span> &amp;&amp; subRoot == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span> || subRoot == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val != subRoot.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSame(root.left, subRoot.left) &amp;&amp; isSame(root.right, subRoot.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a763a04-c2e4-4b79-a4a2-d2475f472a65/Untitled.png\" alt=\"Untitled\"></p>\n<p>There are two ways of traversal</p>\n<ol>\n<li>traverse binary tree until last node (left or right)</li>\n<li>traverse the same structured and value node until both of node are null (left or right)</li>\n</ol>\n<p>first case is that we need to traverse left and right node until the last node. in the meantime we have to check if the value of root and subRoot is the same or not. if it is true, then we start traverse to see if both of tree have the same structure and value</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSubtree</span><span class=\"params\">(TreeNode root, TreeNode subRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">// return when it's last node</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>second case is that we can back on to normal binary tree traversal when both of value is not the same. it means that it keep traversing the root tree to the last node. so it’s important to know that we can return to binary tree traveresal when it’s not the same value.</p>\n<p>then if the value of both trees has the same value then return true or if one of the node has child node then return false since it doesn’t have same structure.</p>\n<p>when spilt to left and right node, we used <code>&amp;&amp;</code> which mean all of the child node has to be the same. if there is false from one of the descentant, then return false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSame</span><span class=\"params\">(TreeNode root, TreeNode subRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span> &amp;&amp; subRoot == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">// if both last node is null, it could be same structure</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span> || subRoot == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">// if one of the node has child node, it doesn't have same structure</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root.val != subRoot.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">// if it's not the same value we can go back to normal traverse which is isSubtree method</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> isSame(root.left, subRoot.left) &amp;&amp; isSame(root.right, subRoot.right); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>DFS has another DFS stream</li>\n<li>important to set return point in DFS</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>two <strong>binary trees</strong> <code>root</code> and <code>subRoot</code></li>\n<li>return <code>true</code> if there is a subtree of <code>root</code> with the same structure and node values of <code>subRoot</code></li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can start with DFS first. one we find the value of subRoot in root Tree, then move to the same direction of child node for both of subRoot and root tree. once complete traverse subRoot tree then return true if root tree has the same subtree otherwise false</p>\n<p>One of the constraint that I couldn’t notice is tree does not have child node in terms of the same structure. so it can be easier to return condition at DFS algorithm</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a33c168f-daaf-4e31-b112-466585656805/FE9CC412-5EEC-45B2-9259-794EAD021E8D.jpeg\" alt=\"FE9CC412-5EEC-45B2-9259-794EAD021E8D.jpeg\"></p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSubtree</span><span class=\"params\">(TreeNode root, TreeNode subRoot)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isSame(root, subRoot)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSame</span><span class=\"params\">(TreeNode root, TreeNode subRoot)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span> &amp;&amp; subRoot == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span> || subRoot == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val != subRoot.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSame(root.left, subRoot.left) &amp;&amp; isSame(root.right, subRoot.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a763a04-c2e4-4b79-a4a2-d2475f472a65/Untitled.png\" alt=\"Untitled\"></p>\n<p>There are two ways of traversal</p>\n<ol>\n<li>traverse binary tree until last node (left or right)</li>\n<li>traverse the same structured and value node until both of node are null (left or right)</li>\n</ol>\n<p>first case is that we need to traverse left and right node until the last node. in the meantime we have to check if the value of root and subRoot is the same or not. if it is true, then we start traverse to see if both of tree have the same structure and value</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSubtree</span><span class=\"params\">(TreeNode root, TreeNode subRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">// return when it's last node</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>second case is that we can back on to normal binary tree traversal when both of value is not the same. it means that it keep traversing the root tree to the last node. so it’s important to know that we can return to binary tree traveresal when it’s not the same value.</p>\n<p>then if the value of both trees has the same value then return true or if one of the node has child node then return false since it doesn’t have same structure.</p>\n<p>when spilt to left and right node, we used <code>&amp;&amp;</code> which mean all of the child node has to be the same. if there is false from one of the descentant, then return false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSame</span><span class=\"params\">(TreeNode root, TreeNode subRoot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span> &amp;&amp; subRoot == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">// if both last node is null, it could be same structure</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span> || subRoot == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">// if one of the node has child node, it doesn't have same structure</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root.val != subRoot.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">// if it's not the same value we can go back to normal traverse which is isSubtree method</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> isSame(root.left, subRoot.left) &amp;&amp; isSame(root.right, subRoot.right); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>DFS has another DFS stream</li>\n<li>important to set return point in DFS</li>\n</ol>\n"},{"title":"659. Encode and Decode Strings","catalog":true,"date":"2022-10-19T12:27:00.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- encode a list of strings to string\n- decode string to a list of strings\n\n### **Edge cases**\n\n---\n\n- input and output has to be the same\n- which character can be belong to string like `,`\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nTo encode a list of strings to string, concat the strings in the list with the delimiter like `,` , `:` . [”a”,”b”,”c”] turns into a,b,c. Time complexity for encoding process is O(n), space complexity is O(1) If we use StringBuilder\n\nTo decode a string to list of strings, split by the delimiter and turn it into list. For instance a,b,c turns into [”a”,”b”,”c”]. Time complexity is O(n)\n\n```java\n// encode\nStringBuilder sb = new StringBuilder();\nfor(int i = 0; i < strs.size(); i++) {\n\tsb.append(strs.get(i));\n\tif(i != strs.size()-1) sb.append(\",\");\n}\nreturn sb.toString();\n```\n\n```java\n// decode\nreturn Arrays.asList(str.split(\",\"));\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nBut the problem of this approach can get us in trouble. what if there is delimeter in the middle of the string in the list. then we will have different answer\n\nInstead we can use the custome delimiter to solve this issue. it’s length of each string with delimiter. For instance [”abc”,”cd”] turns into 4:abc2:cd. we know the length of following substring. so it’s easy to split the string\n\n```java\n// encode\nStringBuilder sb = new StringBuilder();\nfor(String str : strs) {\n\tsb.append(str.length()).append(\":\").append(str);\n}\nreturn sb.toString();\n```\n\n```java\n// decode\nList<String> list = new ArrayList();\nint i = 0;\nwhile(i < str.length()) {\n    int j = i;\n    while(str.charAt(j) != ':') j++;\n    int len = Integer.parseInt(str.substring(i, j));\n    list.add(str.substring(j + 1, j + 1 + len));\n    i = j + 1 + len;\n}\nreturn list;\n\n```\n\n### **Coding**\n\n---\n\n```java\npublic class Solution {\n    \n    public String encode(List<String> strs) {\n        StringBuilder sb = new StringBuilder();\n        for(String str : strs) {\n            sb.append(str.length()).append(\":\").append(str);\n        }\n        return sb.toString();\n    }\n\n    public List<String> decode(String str) {\n        List<String> list = new ArrayList();\n        int i = 0;\n        while(i < str.length()) {\n            int j = i;\n            while(str.charAt(j) != ':') j++;\n            int len = Integer.parseInt(str.substring(i, j));\n            list.add(str.substring(j + 1, j + 1 + len));\n            i = j + 1 + len;\n        }\n        return list;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/affd0201-84e9-4c4c-b9ee-572641c99f17/Untitled.png)\n\n### What I learned\n\n---\n\n1. Consider the custom delimiter required since the special character can be within a given string\n\n```java\n[\"a$b\",\"b_e\",\"a:b\"]\n```\n","source":"_posts/659-Encode-and-Decode-Strings.md","raw":"---\ntitle: 659. Encode and Decode Strings\ncatalog: true\ndate: 2022-10-19 21:27:00\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- encode a list of strings to string\n- decode string to a list of strings\n\n### **Edge cases**\n\n---\n\n- input and output has to be the same\n- which character can be belong to string like `,`\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nTo encode a list of strings to string, concat the strings in the list with the delimiter like `,` , `:` . [”a”,”b”,”c”] turns into a,b,c. Time complexity for encoding process is O(n), space complexity is O(1) If we use StringBuilder\n\nTo decode a string to list of strings, split by the delimiter and turn it into list. For instance a,b,c turns into [”a”,”b”,”c”]. Time complexity is O(n)\n\n```java\n// encode\nStringBuilder sb = new StringBuilder();\nfor(int i = 0; i < strs.size(); i++) {\n\tsb.append(strs.get(i));\n\tif(i != strs.size()-1) sb.append(\",\");\n}\nreturn sb.toString();\n```\n\n```java\n// decode\nreturn Arrays.asList(str.split(\",\"));\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nBut the problem of this approach can get us in trouble. what if there is delimeter in the middle of the string in the list. then we will have different answer\n\nInstead we can use the custome delimiter to solve this issue. it’s length of each string with delimiter. For instance [”abc”,”cd”] turns into 4:abc2:cd. we know the length of following substring. so it’s easy to split the string\n\n```java\n// encode\nStringBuilder sb = new StringBuilder();\nfor(String str : strs) {\n\tsb.append(str.length()).append(\":\").append(str);\n}\nreturn sb.toString();\n```\n\n```java\n// decode\nList<String> list = new ArrayList();\nint i = 0;\nwhile(i < str.length()) {\n    int j = i;\n    while(str.charAt(j) != ':') j++;\n    int len = Integer.parseInt(str.substring(i, j));\n    list.add(str.substring(j + 1, j + 1 + len));\n    i = j + 1 + len;\n}\nreturn list;\n\n```\n\n### **Coding**\n\n---\n\n```java\npublic class Solution {\n    \n    public String encode(List<String> strs) {\n        StringBuilder sb = new StringBuilder();\n        for(String str : strs) {\n            sb.append(str.length()).append(\":\").append(str);\n        }\n        return sb.toString();\n    }\n\n    public List<String> decode(String str) {\n        List<String> list = new ArrayList();\n        int i = 0;\n        while(i < str.length()) {\n            int j = i;\n            while(str.charAt(j) != ':') j++;\n            int len = Integer.parseInt(str.substring(i, j));\n            list.add(str.substring(j + 1, j + 1 + len));\n            i = j + 1 + len;\n        }\n        return list;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/affd0201-84e9-4c4c-b9ee-572641c99f17/Untitled.png)\n\n### What I learned\n\n---\n\n1. Consider the custom delimiter required since the special character can be within a given string\n\n```java\n[\"a$b\",\"b_e\",\"a:b\"]\n```\n","slug":"659-Encode-and-Decode-Strings","published":1,"updated":"2022-10-19T12:27:18.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1f001yqkccgkw5tygt","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>encode a list of strings to string</li>\n<li>decode string to a list of strings</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>input and output has to be the same</li>\n<li>which character can be belong to string like <code>,</code></li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>To encode a list of strings to string, concat the strings in the list with the delimiter like <code>,</code> , <code>:</code> . [”a”,”b”,”c”] turns into a,b,c. Time complexity for encoding process is O(n), space complexity is O(1) If we use StringBuilder</p>\n<p>To decode a string to list of strings, split by the delimiter and turn it into list. For instance a,b,c turns into [”a”,”b”,”c”]. Time complexity is O(n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// encode</span></span><br><span class=\"line\">StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strs.size(); i++) &#123;</span><br><span class=\"line\">\tsb.append(strs.get(i));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i != strs.size()-<span class=\"number\">1</span>) sb.append(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> sb.toString();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// decode</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> Arrays.asList(str.split(<span class=\"string\">\",\"</span>));</span><br></pre></td></tr></table></figure>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>But the problem of this approach can get us in trouble. what if there is delimeter in the middle of the string in the list. then we will have different answer</p>\n<p>Instead we can use the custome delimiter to solve this issue. it’s length of each string with delimiter. For instance [”abc”,”cd”] turns into 4:abc2:cd. we know the length of following substring. so it’s easy to split the string</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// encode</span></span><br><span class=\"line\">StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(String str : strs) &#123;</span><br><span class=\"line\">\tsb.append(str.length()).append(<span class=\"string\">\":\"</span>).append(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> sb.toString();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// decode</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(i &lt; str.length()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = i;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str.charAt(j) != <span class=\"string\">':'</span>) j++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = Integer.parseInt(str.substring(i, j));</span><br><span class=\"line\">    list.add(str.substring(j + <span class=\"number\">1</span>, j + <span class=\"number\">1</span> + len));</span><br><span class=\"line\">    i = j + <span class=\"number\">1</span> + len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> list;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">encode</span><span class=\"params\">(List&lt;String&gt; strs)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String str : strs) &#123;</span><br><span class=\"line\">            sb.append(str.length()).append(<span class=\"string\">\":\"</span>).append(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">decode</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; str.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(str.charAt(j) != <span class=\"string\">':'</span>) j++;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = Integer.parseInt(str.substring(i, j));</span><br><span class=\"line\">            list.add(str.substring(j + <span class=\"number\">1</span>, j + <span class=\"number\">1</span> + len));</span><br><span class=\"line\">            i = j + <span class=\"number\">1</span> + len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/affd0201-84e9-4c4c-b9ee-572641c99f17/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>Consider the custom delimiter required since the special character can be within a given string</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">\"a$b\"</span>,<span class=\"string\">\"b_e\"</span>,<span class=\"string\">\"a:b\"</span>]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>encode a list of strings to string</li>\n<li>decode string to a list of strings</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>input and output has to be the same</li>\n<li>which character can be belong to string like <code>,</code></li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>To encode a list of strings to string, concat the strings in the list with the delimiter like <code>,</code> , <code>:</code> . [”a”,”b”,”c”] turns into a,b,c. Time complexity for encoding process is O(n), space complexity is O(1) If we use StringBuilder</p>\n<p>To decode a string to list of strings, split by the delimiter and turn it into list. For instance a,b,c turns into [”a”,”b”,”c”]. Time complexity is O(n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// encode</span></span><br><span class=\"line\">StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strs.size(); i++) &#123;</span><br><span class=\"line\">\tsb.append(strs.get(i));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i != strs.size()-<span class=\"number\">1</span>) sb.append(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> sb.toString();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// decode</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> Arrays.asList(str.split(<span class=\"string\">\",\"</span>));</span><br></pre></td></tr></table></figure>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>But the problem of this approach can get us in trouble. what if there is delimeter in the middle of the string in the list. then we will have different answer</p>\n<p>Instead we can use the custome delimiter to solve this issue. it’s length of each string with delimiter. For instance [”abc”,”cd”] turns into 4:abc2:cd. we know the length of following substring. so it’s easy to split the string</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// encode</span></span><br><span class=\"line\">StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(String str : strs) &#123;</span><br><span class=\"line\">\tsb.append(str.length()).append(<span class=\"string\">\":\"</span>).append(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> sb.toString();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// decode</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(i &lt; str.length()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = i;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(str.charAt(j) != <span class=\"string\">':'</span>) j++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = Integer.parseInt(str.substring(i, j));</span><br><span class=\"line\">    list.add(str.substring(j + <span class=\"number\">1</span>, j + <span class=\"number\">1</span> + len));</span><br><span class=\"line\">    i = j + <span class=\"number\">1</span> + len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> list;</span><br></pre></td></tr></table></figure>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">encode</span><span class=\"params\">(List&lt;String&gt; strs)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String str : strs) &#123;</span><br><span class=\"line\">            sb.append(str.length()).append(<span class=\"string\">\":\"</span>).append(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">decode</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; str.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(str.charAt(j) != <span class=\"string\">':'</span>) j++;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = Integer.parseInt(str.substring(i, j));</span><br><span class=\"line\">            list.add(str.substring(j + <span class=\"number\">1</span>, j + <span class=\"number\">1</span> + len));</span><br><span class=\"line\">            i = j + <span class=\"number\">1</span> + len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/affd0201-84e9-4c4c-b9ee-572641c99f17/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>Consider the custom delimiter required since the special character can be within a given string</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">\"a$b\"</span>,<span class=\"string\">\"b_e\"</span>,<span class=\"string\">\"a:b\"</span>]</span><br></pre></td></tr></table></figure>\n"},{"title":"647. Palindromic Substrings","catalog":true,"date":"2022-09-11T12:32:32.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- palindrome is the string can be read the same backward and forward\n\n## Solve by hands first\n\n---\n\nSince palindrome is the string when it reads the same forward and backward. it can consist of either even or odd number of characters. **So we have to treat it differently depending on size**. For odd number of string, it can start from size one and for even number of string, it can start from size two. **we need to expand the start index to left and last index to right**. \n\n```java\nex) aabaa\n\n     i j\n-------------------------------------------------\nodd  0 0 → a  → -1 1 \neven 0 1 → aa → -1 2\n-------------------------------------------------\nodd  1 1 → a  →  0 2 → aab\neven 1 2 → ab \n-------------------------------------------------\nodd  2 2 → b  →  1 3 → aba → 0 4 → aabaa\neven 2 3 → ba →  1 4 → abaa\n-------------------------------------------------\nodd  3 3 → a  →  2 4 → baa\neven 3 4 → ba\n-------------------------------------------------\nodd  4 4 → a  \n```\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    int count = 0;\n    public int countSubstrings(String s) {    \n        for(int i = 0; i < s.length(); i++) {\n            expand(s, i, i); // odd\n            expand(s, i, i+1); // even\n        }\n        return count;\n    }\n    \n    private void expand(String s, int i, int j) {\n        while(i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {\n            count++; i--; j++;\n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/252f3d33-fc19-4922-b198-c5c4801d0e1b/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Another way to solve **Palindrome problem by expanding the start and last index**\n\n```java\nexpand(s, i, i); // odd\nexpand(s, i, i+1); // even\n\nprivate void expand(String s, int i, int j) {\n    // the same first and last letter within boundary and expand\n    while(i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {\n        count++; i--; j++;\n    }\n}\n```\n","source":"_posts/647-Palindromic-Substrings.md","raw":"---\ntitle: \"647.\\_Palindromic Substrings\"\ncatalog: true\ndate: 2022-09-11 21:32:32\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- palindrome is the string can be read the same backward and forward\n\n## Solve by hands first\n\n---\n\nSince palindrome is the string when it reads the same forward and backward. it can consist of either even or odd number of characters. **So we have to treat it differently depending on size**. For odd number of string, it can start from size one and for even number of string, it can start from size two. **we need to expand the start index to left and last index to right**. \n\n```java\nex) aabaa\n\n     i j\n-------------------------------------------------\nodd  0 0 → a  → -1 1 \neven 0 1 → aa → -1 2\n-------------------------------------------------\nodd  1 1 → a  →  0 2 → aab\neven 1 2 → ab \n-------------------------------------------------\nodd  2 2 → b  →  1 3 → aba → 0 4 → aabaa\neven 2 3 → ba →  1 4 → abaa\n-------------------------------------------------\nodd  3 3 → a  →  2 4 → baa\neven 3 4 → ba\n-------------------------------------------------\nodd  4 4 → a  \n```\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    int count = 0;\n    public int countSubstrings(String s) {    \n        for(int i = 0; i < s.length(); i++) {\n            expand(s, i, i); // odd\n            expand(s, i, i+1); // even\n        }\n        return count;\n    }\n    \n    private void expand(String s, int i, int j) {\n        while(i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {\n            count++; i--; j++;\n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/252f3d33-fc19-4922-b198-c5c4801d0e1b/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Another way to solve **Palindrome problem by expanding the start and last index**\n\n```java\nexpand(s, i, i); // odd\nexpand(s, i, i+1); // even\n\nprivate void expand(String s, int i, int j) {\n    // the same first and last letter within boundary and expand\n    while(i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {\n        count++; i--; j++;\n    }\n}\n```\n","slug":"647-Palindromic-Substrings","published":1,"updated":"2022-09-11T12:33:01.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1f001zqkcch0d8awzi","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>palindrome is the string can be read the same backward and forward</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>Since palindrome is the string when it reads the same forward and backward. it can consist of either even or odd number of characters. <strong>So we have to treat it differently depending on size</strong>. For odd number of string, it can start from size one and for even number of string, it can start from size two. <strong>we need to expand the start index to left and last index to right</strong>.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ex) aabaa</span><br><span class=\"line\"></span><br><span class=\"line\">     i j</span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">odd  <span class=\"number\">0</span> <span class=\"number\">0</span> → a  → -<span class=\"number\">1</span> <span class=\"number\">1</span> </span><br><span class=\"line\">even <span class=\"number\">0</span> <span class=\"number\">1</span> → aa → -<span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">odd  <span class=\"number\">1</span> <span class=\"number\">1</span> → a  →  <span class=\"number\">0</span> <span class=\"number\">2</span> → aab</span><br><span class=\"line\">even <span class=\"number\">1</span> <span class=\"number\">2</span> → ab </span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">odd  <span class=\"number\">2</span> <span class=\"number\">2</span> → b  →  <span class=\"number\">1</span> <span class=\"number\">3</span> → aba → <span class=\"number\">0</span> <span class=\"number\">4</span> → aabaa</span><br><span class=\"line\">even <span class=\"number\">2</span> <span class=\"number\">3</span> → ba →  <span class=\"number\">1</span> <span class=\"number\">4</span> → abaa</span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">odd  <span class=\"number\">3</span> <span class=\"number\">3</span> → a  →  <span class=\"number\">2</span> <span class=\"number\">4</span> → baa</span><br><span class=\"line\">even <span class=\"number\">3</span> <span class=\"number\">4</span> → ba</span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">odd  <span class=\"number\">4</span> <span class=\"number\">4</span> → a</span><br></pre></td></tr></table></figure>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countSubstrings</span><span class=\"params\">(String s)</span> </span>&#123;    </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            expand(s, i, i); <span class=\"comment\">// odd</span></span><br><span class=\"line\">            expand(s, i, i+<span class=\"number\">1</span>); <span class=\"comment\">// even</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expand</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span> &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class=\"line\">            count++; i--; j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/252f3d33-fc19-4922-b198-c5c4801d0e1b/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>Another way to solve <strong>Palindrome problem by expanding the start and last index</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expand(s, i, i); <span class=\"comment\">// odd</span></span><br><span class=\"line\">expand(s, i, i+<span class=\"number\">1</span>); <span class=\"comment\">// even</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expand</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the same first and last letter within boundary and expand</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span> &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class=\"line\">        count++; i--; j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>palindrome is the string can be read the same backward and forward</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>Since palindrome is the string when it reads the same forward and backward. it can consist of either even or odd number of characters. <strong>So we have to treat it differently depending on size</strong>. For odd number of string, it can start from size one and for even number of string, it can start from size two. <strong>we need to expand the start index to left and last index to right</strong>.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ex) aabaa</span><br><span class=\"line\"></span><br><span class=\"line\">     i j</span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">odd  <span class=\"number\">0</span> <span class=\"number\">0</span> → a  → -<span class=\"number\">1</span> <span class=\"number\">1</span> </span><br><span class=\"line\">even <span class=\"number\">0</span> <span class=\"number\">1</span> → aa → -<span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">odd  <span class=\"number\">1</span> <span class=\"number\">1</span> → a  →  <span class=\"number\">0</span> <span class=\"number\">2</span> → aab</span><br><span class=\"line\">even <span class=\"number\">1</span> <span class=\"number\">2</span> → ab </span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">odd  <span class=\"number\">2</span> <span class=\"number\">2</span> → b  →  <span class=\"number\">1</span> <span class=\"number\">3</span> → aba → <span class=\"number\">0</span> <span class=\"number\">4</span> → aabaa</span><br><span class=\"line\">even <span class=\"number\">2</span> <span class=\"number\">3</span> → ba →  <span class=\"number\">1</span> <span class=\"number\">4</span> → abaa</span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">odd  <span class=\"number\">3</span> <span class=\"number\">3</span> → a  →  <span class=\"number\">2</span> <span class=\"number\">4</span> → baa</span><br><span class=\"line\">even <span class=\"number\">3</span> <span class=\"number\">4</span> → ba</span><br><span class=\"line\">-------------------------------------------------</span><br><span class=\"line\">odd  <span class=\"number\">4</span> <span class=\"number\">4</span> → a</span><br></pre></td></tr></table></figure>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countSubstrings</span><span class=\"params\">(String s)</span> </span>&#123;    </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            expand(s, i, i); <span class=\"comment\">// odd</span></span><br><span class=\"line\">            expand(s, i, i+<span class=\"number\">1</span>); <span class=\"comment\">// even</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expand</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span> &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class=\"line\">            count++; i--; j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/252f3d33-fc19-4922-b198-c5c4801d0e1b/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>Another way to solve <strong>Palindrome problem by expanding the start and last index</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expand(s, i, i); <span class=\"comment\">// odd</span></span><br><span class=\"line\">expand(s, i, i+<span class=\"number\">1</span>); <span class=\"comment\">// even</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expand</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the same first and last letter within boundary and expand</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span> &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class=\"line\">        count++; i--; j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"70. Climbing Stairs","catalog":true,"date":"2022-10-16T04:34:34.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- It takes `n` steps to reach the top.\n- Each time you can either climb `1` or `2` steps\n- In how many distinct ways can you climb to the top?\n\n### **Edge cases**\n\n---\n\n- 3\n    - 1 1 1 = dp[2] + 1\n    - 1 2 = dp[1] + 1\n    - 2 1 = dp[2] + 1\n    - dp[2] = 2\n    - dp[1] = 1\n- 2 → [1,1][2]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\n*jump into the optimized solution without brute force. In case they get stuck, it backfires*\n\n*you already have a non-optimized solution in place which is always better than nothing*\n\n*in some instances, brute force is in fact the desired solution*\n\n*mention the complexity of the brute force*\n\n*ask the interviewer if you should code this approach*\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nIn order to reach nth steps. We can take 1 more steps from n-1 th or n-2 th steps. So, recursino formula would be dp[n] = dp[n-1] + dp[n-2]\n\n### **Coding**\n\n---\n\nBottom-up\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1; dp[1] = 1;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n}\n```\n\nTop-down\n\n```java\nclass Solution {\n\t\tInteger[] dp;\n\t\t\n\t\tpublic int climbStairs(int n) {\n\t\t    dp = new Integer[n + 1];\n\t\t    return dfs(n);\n\t\t}\n\t\t\n\t\tprivate int dfs(int n) {\n\t\t    if(n == 1) return 1;\n\t\t    if(n == 2) return 2;\n\t\t    if(dp[n] != null) return dp[n];\n\t\t    return dp[n] = dfs(n-1) + dfs(n-2);\n\t\t}\n}\n```\n\n### **Dry Run**\n\n---\n\n*It is extremely important to run it through a couple of sample test cases*\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/decb965d-ab3e-4a7c-9cfb-cf53f6a288a0/Untitled.png)\n\n### What I learned\n\n---\n","source":"_posts/70-Climbing-Stairs.md","raw":"---\ntitle: \"70.\\_Climbing Stairs\"\ncatalog: true\ndate: 2022-10-16 13:34:34\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- It takes `n` steps to reach the top.\n- Each time you can either climb `1` or `2` steps\n- In how many distinct ways can you climb to the top?\n\n### **Edge cases**\n\n---\n\n- 3\n    - 1 1 1 = dp[2] + 1\n    - 1 2 = dp[1] + 1\n    - 2 1 = dp[2] + 1\n    - dp[2] = 2\n    - dp[1] = 1\n- 2 → [1,1][2]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\n*jump into the optimized solution without brute force. In case they get stuck, it backfires*\n\n*you already have a non-optimized solution in place which is always better than nothing*\n\n*in some instances, brute force is in fact the desired solution*\n\n*mention the complexity of the brute force*\n\n*ask the interviewer if you should code this approach*\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nIn order to reach nth steps. We can take 1 more steps from n-1 th or n-2 th steps. So, recursino formula would be dp[n] = dp[n-1] + dp[n-2]\n\n### **Coding**\n\n---\n\nBottom-up\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1; dp[1] = 1;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n}\n```\n\nTop-down\n\n```java\nclass Solution {\n\t\tInteger[] dp;\n\t\t\n\t\tpublic int climbStairs(int n) {\n\t\t    dp = new Integer[n + 1];\n\t\t    return dfs(n);\n\t\t}\n\t\t\n\t\tprivate int dfs(int n) {\n\t\t    if(n == 1) return 1;\n\t\t    if(n == 2) return 2;\n\t\t    if(dp[n] != null) return dp[n];\n\t\t    return dp[n] = dfs(n-1) + dfs(n-2);\n\t\t}\n}\n```\n\n### **Dry Run**\n\n---\n\n*It is extremely important to run it through a couple of sample test cases*\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/decb965d-ab3e-4a7c-9cfb-cf53f6a288a0/Untitled.png)\n\n### What I learned\n\n---\n","slug":"70-Climbing-Stairs","published":1,"updated":"2022-10-16T04:34:49.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1g0020qkcc82oi415u","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>It takes <code>n</code> steps to reach the top.</li>\n<li>Each time you can either climb <code>1</code> or <code>2</code> steps</li>\n<li>In how many distinct ways can you climb to the top?</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>3\n<ul>\n<li>1 1 1 = dp[2] + 1</li>\n<li>1 2 = dp[1] + 1</li>\n<li>2 1 = dp[2] + 1</li>\n<li>dp[2] = 2</li>\n<li>dp[1] = 1</li>\n</ul>\n</li>\n<li>2 → [1,1][2]</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p><em>jump into the optimized solution without brute force. In case they get stuck, it backfires</em></p>\n<p><em>you already have a non-optimized solution in place which is always better than nothing</em></p>\n<p><em>in some instances, brute force is in fact the desired solution</em></p>\n<p><em>mention the complexity of the brute force</em></p>\n<p><em>ask the interviewer if you should code this approach</em></p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>In order to reach nth steps. We can take 1 more steps from n-1 th or n-2 th steps. So, recursino formula would be dp[n] = dp[n-1] + dp[n-2]</p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<p>Bottom-up</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>; dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[i] = dp[i-<span class=\"number\">1</span>] + dp[i-<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Top-down</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t\tInteger[] dp;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t\t    dp = <span class=\"keyword\">new</span> Integer[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t    <span class=\"keyword\">return</span> dfs(n);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span>(n == <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span>(dp[n] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">\t\t    <span class=\"keyword\">return</span> dp[n] = dfs(n-<span class=\"number\">1</span>) + dfs(n-<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><em>It is extremely important to run it through a couple of sample test cases</em></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/decb965d-ab3e-4a7c-9cfb-cf53f6a288a0/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>It takes <code>n</code> steps to reach the top.</li>\n<li>Each time you can either climb <code>1</code> or <code>2</code> steps</li>\n<li>In how many distinct ways can you climb to the top?</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>3\n<ul>\n<li>1 1 1 = dp[2] + 1</li>\n<li>1 2 = dp[1] + 1</li>\n<li>2 1 = dp[2] + 1</li>\n<li>dp[2] = 2</li>\n<li>dp[1] = 1</li>\n</ul>\n</li>\n<li>2 → [1,1][2]</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p><em>jump into the optimized solution without brute force. In case they get stuck, it backfires</em></p>\n<p><em>you already have a non-optimized solution in place which is always better than nothing</em></p>\n<p><em>in some instances, brute force is in fact the desired solution</em></p>\n<p><em>mention the complexity of the brute force</em></p>\n<p><em>ask the interviewer if you should code this approach</em></p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>In order to reach nth steps. We can take 1 more steps from n-1 th or n-2 th steps. So, recursino formula would be dp[n] = dp[n-1] + dp[n-2]</p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<p>Bottom-up</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>; dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[i] = dp[i-<span class=\"number\">1</span>] + dp[i-<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Top-down</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t\tInteger[] dp;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t\t    dp = <span class=\"keyword\">new</span> Integer[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t    <span class=\"keyword\">return</span> dfs(n);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span>(n == <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span>(dp[n] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">\t\t    <span class=\"keyword\">return</span> dp[n] = dfs(n-<span class=\"number\">1</span>) + dfs(n-<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><em>It is extremely important to run it through a couple of sample test cases</em></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/decb965d-ab3e-4a7c-9cfb-cf53f6a288a0/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n"},{"title":"79. Word Search","catalog":true,"date":"2022-09-17T09:10:53.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- `board` and `word` consists of only lowercase and uppercase English letters.\n- 1 <= m, n <= 6 (max = 6*6 = 36)\n- 1 <= word.length <= 15 (max = 15)\n\n## Solve by hands first\n\n---\n\nI can start with Brute Force way but its Time complexity will be O(m*n*word.length). Instead I can use Trie data structure to store the initial input string and loop through the board[][] then its time compexity will be O(m*n)\n\n## Solution\n\n---\n\nI tried to use Trie data structure to save time. Time complexity is O(m*n) and space complexity is O(127 * n)\n\n```java\nclass Solution {\n    \n    class Trie {\n        Trie[] next = new Trie[127];\n        String word = \"\";\n    }\n    \n    int[] dx = new int[] {1, -1, 0, 0};\n    int[] dy = new int[] {0, 0, 1, -1};\n    \n    boolean[][] visited;\n    \n    public boolean exist(char[][] board, String word) {\n        visited = new boolean[board.length][board[0].length];\n        \n        Trie trie = new Trie();\n        Trie tmp = trie;\n        for(int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            \n            if(trie.next[c] == null) {\n                trie.next[c] = new Trie();\n            }\n            trie = trie.next[c];\n        }\n        trie.word = word;\n        \n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[0].length; j++) {\n                \n                char s = board[i][j];\n                \n                if(tmp.next[s] == null || visited[i][j]) continue;\n                \n                tmp = tmp.next[s];\n                visited[i][j] = true;\n                if(!tmp.word.equals(\"\")) return true;\n                \n                \n                for(int z = 0; z < 4; z++) {\n                    int nx = i + dx[z];\n                    int ny = j + dy[z];\n                    \n                    if(nx < 0 || ny < 0 || nx >= board.length || ny >= board[0].length || visited[nx][ny]) continue;\n                    \n                    char nc = board[nx][ny];    \n                    \n                    if(tmp.next[nc] == null || visited[nx][ny]) continue;\n\n                    tmp = tmp.next[nc];\n                    visited[nx][ny] = true;\n                    \n                    if(!tmp.word.equals(\"\")) return true;\n                }    \n            }\n        }   \n        return false;\n    }   \n}\n```\n\nProblem of this approach is that I loop through the adjacent node vertically and horizontally. **when it reaches to last index, there is no way travel back to previous index**. so we need to use different way. Dynamic programming\n\n```java\nclass Solution {\n    \n    class Trie {\n        Trie[] next = new Trie[127];\n        String word = \"\";\n    }\n    \n    int[] dx = new int[] {1, -1, 0, 0};\n    int[] dy = new int[] {0, 0, 1, -1};\n    \n    boolean[][] visited;\n    \n    public boolean exist(char[][] board, String word) {\n        visited = new boolean[board.length][board[0].length];\n        \n        Trie trie = new Trie();\n        Trie tmp = trie;\n        for(int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            \n            if(trie.next[c] == null) {\n                trie.next[c] = new Trie();\n            }\n            trie = trie.next[c];\n        }\n        trie.word = word;\n        \n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[0].length; j++) {\n                if(dfs(tmp, board, i, j)) return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean dfs(Trie tmp, char[][] board, int i, int j) {\n        \n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j]) return false;\n\n        char s = board[i][j];\n                \n        if(tmp.next[s] == null || visited[i][j]) return false;\n\n        tmp = tmp.next[s];\n        visited[i][j] = true;\n        if(!tmp.word.equals(\"\")) return true;\n        \n        boolean ans = dfs(tmp, board, i+1, j) || dfs(tmp, board, i, j+1) || dfs(tmp, board, i-1, j) || dfs(tmp, board, i, j-1);\n        \n        visited[i][j] = false; // if the character is not in the trie, then check unvisited\n        \n        return ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a8535de-dbc5-4673-843e-353e98a876f6/Untitled.png)\n\nI used the backtracking instead of dynamic programing **because when the current character is not in the trie, then it checks unvisited so that those index can be visited again later in time**.\n\n![83102DB4-5B57-473B-9248-DA95360DB983.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b0abaf9-239f-411e-9311-d16f3f87597e/83102DB4-5B57-473B-9248-DA95360DB983.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. **we can contain 127 ascii characters in trie** (when we don’t really want to care about anything else!)\n\n```java\nclass Trie {\n    Trie[] next = new Trie[127];\n    String word = \"\";\n}\n\nTrie trie = new Trie();\nTrie tmp = trie; // cache the pointer to the head node of trie\nfor(int i = 0; i < word.length(); i++) {\n    char c = word.charAt(i);\n    \n    if(trie.next[c] == null) {\n        trie.next[c] = new Trie();\n    }\n    trie = trie.next[c];\n}\ntrie.word = word;\n```\n\n1. **cache the pointer to the head node of trie**\n\n```java\nTrie trie = new Trie();\nTrie tmp = trie; // cache the pointer to the head node of trie\n```\n\n1. **loop and dynamic programming is different!**\n    - the mistake I made on this question is that loop was enough. but loop doesn’t chain the next node. so if the loop reaches to the last index, there is no way it can traverse to the other nodes\n    - **if we need to traverse other node again! then we have to use dynamic programming**\n\n```java\n// before\nfor(int i = 0; i < board.length; i++) {\n    for(int j = 0; j < board[0].length; j++) {\n        \n        char s = board[i][j];\n        \n        if(tmp.next[s] == null || visited[i][j]) continue;\n        \n        tmp = tmp.next[s];\n        visited[i][j] = true;\n        if(!tmp.word.equals(\"\")) return true;\n        \n        \n        for(int z = 0; z < 4; z++) {\n            int nx = i + dx[z];\n            int ny = j + dy[z];\n            \n            if(nx < 0 || ny < 0 || nx >= board.length || ny >= board[0].length || visited[nx][ny]) continue;\n            \n            char nc = board[nx][ny];    \n            \n            if(tmp.next[nc] == null || visited[nx][ny]) continue;\n\n            tmp = tmp.next[nc];\n            visited[nx][ny] = true;\n            \n            if(!tmp.word.equals(\"\")) return true;\n        }    \n    }\n}   \n```\n\n```java\n// after\nfor(int i = 0; i < board.length; i++) {\n    for(int j = 0; j < board[0].length; j++) {\n        if(dfs(tmp, board, i, j)) return true;\n    }\n}\n\n private boolean dfs(Trie tmp, char[][] board, int i, int j) {\n        \n    if(i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j]) return false;\n\n    char s = board[i][j];\n            \n    if(tmp.next[s] == null || visited[i][j]) return false;\n\n    tmp = tmp.next[s];\n    visited[i][j] = true;\n    if(!tmp.word.equals(\"\")) return true;\n    \n    boolean ans = dfs(tmp, board, i+1, j) || dfs(tmp, board, i, j+1) || dfs(tmp, board, i-1, j) || dfs(tmp, board, i, j-1);\n    \n    visited[i][j] = false; // if the character is not in the trie, then check unvisited\n    \n    return ans;\n}\n```\n\n1. use **the backtracking to initialize the condition in matrix problem**\n","source":"_posts/79-Word-Search.md","raw":"---\ntitle: \"79.\\_Word Search\"\ncatalog: true\ndate: 2022-09-17 18:10:53\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- `board` and `word` consists of only lowercase and uppercase English letters.\n- 1 <= m, n <= 6 (max = 6*6 = 36)\n- 1 <= word.length <= 15 (max = 15)\n\n## Solve by hands first\n\n---\n\nI can start with Brute Force way but its Time complexity will be O(m*n*word.length). Instead I can use Trie data structure to store the initial input string and loop through the board[][] then its time compexity will be O(m*n)\n\n## Solution\n\n---\n\nI tried to use Trie data structure to save time. Time complexity is O(m*n) and space complexity is O(127 * n)\n\n```java\nclass Solution {\n    \n    class Trie {\n        Trie[] next = new Trie[127];\n        String word = \"\";\n    }\n    \n    int[] dx = new int[] {1, -1, 0, 0};\n    int[] dy = new int[] {0, 0, 1, -1};\n    \n    boolean[][] visited;\n    \n    public boolean exist(char[][] board, String word) {\n        visited = new boolean[board.length][board[0].length];\n        \n        Trie trie = new Trie();\n        Trie tmp = trie;\n        for(int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            \n            if(trie.next[c] == null) {\n                trie.next[c] = new Trie();\n            }\n            trie = trie.next[c];\n        }\n        trie.word = word;\n        \n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[0].length; j++) {\n                \n                char s = board[i][j];\n                \n                if(tmp.next[s] == null || visited[i][j]) continue;\n                \n                tmp = tmp.next[s];\n                visited[i][j] = true;\n                if(!tmp.word.equals(\"\")) return true;\n                \n                \n                for(int z = 0; z < 4; z++) {\n                    int nx = i + dx[z];\n                    int ny = j + dy[z];\n                    \n                    if(nx < 0 || ny < 0 || nx >= board.length || ny >= board[0].length || visited[nx][ny]) continue;\n                    \n                    char nc = board[nx][ny];    \n                    \n                    if(tmp.next[nc] == null || visited[nx][ny]) continue;\n\n                    tmp = tmp.next[nc];\n                    visited[nx][ny] = true;\n                    \n                    if(!tmp.word.equals(\"\")) return true;\n                }    \n            }\n        }   \n        return false;\n    }   \n}\n```\n\nProblem of this approach is that I loop through the adjacent node vertically and horizontally. **when it reaches to last index, there is no way travel back to previous index**. so we need to use different way. Dynamic programming\n\n```java\nclass Solution {\n    \n    class Trie {\n        Trie[] next = new Trie[127];\n        String word = \"\";\n    }\n    \n    int[] dx = new int[] {1, -1, 0, 0};\n    int[] dy = new int[] {0, 0, 1, -1};\n    \n    boolean[][] visited;\n    \n    public boolean exist(char[][] board, String word) {\n        visited = new boolean[board.length][board[0].length];\n        \n        Trie trie = new Trie();\n        Trie tmp = trie;\n        for(int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            \n            if(trie.next[c] == null) {\n                trie.next[c] = new Trie();\n            }\n            trie = trie.next[c];\n        }\n        trie.word = word;\n        \n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[0].length; j++) {\n                if(dfs(tmp, board, i, j)) return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean dfs(Trie tmp, char[][] board, int i, int j) {\n        \n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j]) return false;\n\n        char s = board[i][j];\n                \n        if(tmp.next[s] == null || visited[i][j]) return false;\n\n        tmp = tmp.next[s];\n        visited[i][j] = true;\n        if(!tmp.word.equals(\"\")) return true;\n        \n        boolean ans = dfs(tmp, board, i+1, j) || dfs(tmp, board, i, j+1) || dfs(tmp, board, i-1, j) || dfs(tmp, board, i, j-1);\n        \n        visited[i][j] = false; // if the character is not in the trie, then check unvisited\n        \n        return ans;\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a8535de-dbc5-4673-843e-353e98a876f6/Untitled.png)\n\nI used the backtracking instead of dynamic programing **because when the current character is not in the trie, then it checks unvisited so that those index can be visited again later in time**.\n\n![83102DB4-5B57-473B-9248-DA95360DB983.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b0abaf9-239f-411e-9311-d16f3f87597e/83102DB4-5B57-473B-9248-DA95360DB983.jpeg)\n\n## Lesson I learnt\n\n---\n\n1. **we can contain 127 ascii characters in trie** (when we don’t really want to care about anything else!)\n\n```java\nclass Trie {\n    Trie[] next = new Trie[127];\n    String word = \"\";\n}\n\nTrie trie = new Trie();\nTrie tmp = trie; // cache the pointer to the head node of trie\nfor(int i = 0; i < word.length(); i++) {\n    char c = word.charAt(i);\n    \n    if(trie.next[c] == null) {\n        trie.next[c] = new Trie();\n    }\n    trie = trie.next[c];\n}\ntrie.word = word;\n```\n\n1. **cache the pointer to the head node of trie**\n\n```java\nTrie trie = new Trie();\nTrie tmp = trie; // cache the pointer to the head node of trie\n```\n\n1. **loop and dynamic programming is different!**\n    - the mistake I made on this question is that loop was enough. but loop doesn’t chain the next node. so if the loop reaches to the last index, there is no way it can traverse to the other nodes\n    - **if we need to traverse other node again! then we have to use dynamic programming**\n\n```java\n// before\nfor(int i = 0; i < board.length; i++) {\n    for(int j = 0; j < board[0].length; j++) {\n        \n        char s = board[i][j];\n        \n        if(tmp.next[s] == null || visited[i][j]) continue;\n        \n        tmp = tmp.next[s];\n        visited[i][j] = true;\n        if(!tmp.word.equals(\"\")) return true;\n        \n        \n        for(int z = 0; z < 4; z++) {\n            int nx = i + dx[z];\n            int ny = j + dy[z];\n            \n            if(nx < 0 || ny < 0 || nx >= board.length || ny >= board[0].length || visited[nx][ny]) continue;\n            \n            char nc = board[nx][ny];    \n            \n            if(tmp.next[nc] == null || visited[nx][ny]) continue;\n\n            tmp = tmp.next[nc];\n            visited[nx][ny] = true;\n            \n            if(!tmp.word.equals(\"\")) return true;\n        }    \n    }\n}   \n```\n\n```java\n// after\nfor(int i = 0; i < board.length; i++) {\n    for(int j = 0; j < board[0].length; j++) {\n        if(dfs(tmp, board, i, j)) return true;\n    }\n}\n\n private boolean dfs(Trie tmp, char[][] board, int i, int j) {\n        \n    if(i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j]) return false;\n\n    char s = board[i][j];\n            \n    if(tmp.next[s] == null || visited[i][j]) return false;\n\n    tmp = tmp.next[s];\n    visited[i][j] = true;\n    if(!tmp.word.equals(\"\")) return true;\n    \n    boolean ans = dfs(tmp, board, i+1, j) || dfs(tmp, board, i, j+1) || dfs(tmp, board, i-1, j) || dfs(tmp, board, i, j-1);\n    \n    visited[i][j] = false; // if the character is not in the trie, then check unvisited\n    \n    return ans;\n}\n```\n\n1. use **the backtracking to initialize the condition in matrix problem**\n","slug":"79-Word-Search","published":1,"updated":"2022-09-17T09:11:21.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1g0021qkcconhxiajc","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li>\n<li>1 &lt;= m, n &lt;= 6 (max = 6*6 = 36)</li>\n<li>1 &lt;= word.length &lt;= 15 (max = 15)</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>I can start with Brute Force way but its Time complexity will be O(m<em>n</em>word.length). Instead I can use Trie data structure to store the initial input string and loop through the board[][] then its time compexity will be O(m*n)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<p>I tried to use Trie data structure to save time. Time complexity is O(m*n) and space complexity is O(127 * n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">        Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">127</span>];</span><br><span class=\"line\">        String word = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span>[][] visited;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exist</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[board.length][board[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        </span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">        Trie tmp = trie;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[c] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                trie.next[c] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            trie = trie.next[c];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trie.word = word;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">char</span> s = board[i][j];</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp.next[s] == <span class=\"keyword\">null</span> || visited[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">                tmp = tmp.next[s];</span><br><span class=\"line\">                visited[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">4</span>; z++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> nx = i + dx[z];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> ny = j + dy[z];</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= board.length || ny &gt;= board[<span class=\"number\">0</span>].length || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">char</span> nc = board[nx][ny];    </span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(tmp.next[nc] == <span class=\"keyword\">null</span> || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    tmp = tmp.next[nc];</span><br><span class=\"line\">                    visited[nx][ny] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;    </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Problem of this approach is that I loop through the adjacent node vertically and horizontally. <strong>when it reaches to last index, there is no way travel back to previous index</strong>. so we need to use different way. Dynamic programming</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">        Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">127</span>];</span><br><span class=\"line\">        String word = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span>[][] visited;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exist</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[board.length][board[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        </span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">        Trie tmp = trie;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[c] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                trie.next[c] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            trie = trie.next[c];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trie.word = word;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(dfs(tmp, board, i, j)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(Trie tmp, <span class=\"keyword\">char</span>[][] board, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || j &lt; <span class=\"number\">0</span> || i &gt;= board.length || j &gt;= board[<span class=\"number\">0</span>].length || visited[i][j]) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span> s = board[i][j];</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp.next[s] == <span class=\"keyword\">null</span> || visited[i][j]) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp = tmp.next[s];</span><br><span class=\"line\">        visited[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> ans = dfs(tmp, board, i+<span class=\"number\">1</span>, j) || dfs(tmp, board, i, j+<span class=\"number\">1</span>) || dfs(tmp, board, i-<span class=\"number\">1</span>, j) || dfs(tmp, board, i, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        visited[i][j] = <span class=\"keyword\">false</span>; <span class=\"comment\">// if the character is not in the trie, then check unvisited</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a8535de-dbc5-4673-843e-353e98a876f6/Untitled.png\" alt=\"Untitled\"></p>\n<p>I used the backtracking instead of dynamic programing <strong>because when the current character is not in the trie, then it checks unvisited so that those index can be visited again later in time</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b0abaf9-239f-411e-9311-d16f3f87597e/83102DB4-5B57-473B-9248-DA95360DB983.jpeg\" alt=\"83102DB4-5B57-473B-9248-DA95360DB983.jpeg\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li><strong>we can contain 127 ascii characters in trie</strong> (when we don’t really want to care about anything else!)</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">    Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">127</span>];</span><br><span class=\"line\">    String word = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">Trie tmp = trie; <span class=\"comment\">// cache the pointer to the head node of trie</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(trie.next[c] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        trie.next[c] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    trie = trie.next[c];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trie.word = word;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><strong>cache the pointer to the head node of trie</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">Trie tmp = trie; <span class=\"comment\">// cache the pointer to the head node of trie</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li><strong>loop and dynamic programming is different!</strong>\n<ul>\n<li>the mistake I made on this question is that loop was enough. but loop doesn’t chain the next node. so if the loop reaches to the last index, there is no way it can traverse to the other nodes</li>\n<li><strong>if we need to traverse other node again! then we have to use dynamic programming</strong></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">char</span> s = board[i][j];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp.next[s] == <span class=\"keyword\">null</span> || visited[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        tmp = tmp.next[s];</span><br><span class=\"line\">        visited[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">4</span>; z++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nx = i + dx[z];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ny = j + dy[z];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= board.length || ny &gt;= board[<span class=\"number\">0</span>].length || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">char</span> nc = board[nx][ny];    </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.next[nc] == <span class=\"keyword\">null</span> || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            tmp = tmp.next[nc];</span><br><span class=\"line\">            visited[nx][ny] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dfs(tmp, board, i, j)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(Trie tmp, <span class=\"keyword\">char</span>[][] board, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || j &lt; <span class=\"number\">0</span> || i &gt;= board.length || j &gt;= board[<span class=\"number\">0</span>].length || visited[i][j]) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> s = board[i][j];</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp.next[s] == <span class=\"keyword\">null</span> || visited[i][j]) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = tmp.next[s];</span><br><span class=\"line\">    visited[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> ans = dfs(tmp, board, i+<span class=\"number\">1</span>, j) || dfs(tmp, board, i, j+<span class=\"number\">1</span>) || dfs(tmp, board, i-<span class=\"number\">1</span>, j) || dfs(tmp, board, i, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    visited[i][j] = <span class=\"keyword\">false</span>; <span class=\"comment\">// if the character is not in the trie, then check unvisited</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>use <strong>the backtracking to initialize the condition in matrix problem</strong></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li>\n<li>1 &lt;= m, n &lt;= 6 (max = 6*6 = 36)</li>\n<li>1 &lt;= word.length &lt;= 15 (max = 15)</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>I can start with Brute Force way but its Time complexity will be O(m<em>n</em>word.length). Instead I can use Trie data structure to store the initial input string and loop through the board[][] then its time compexity will be O(m*n)</p>\n<h2>Solution</h2>\n<hr>\n<p>I tried to use Trie data structure to save time. Time complexity is O(m*n) and space complexity is O(127 * n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">        Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">127</span>];</span><br><span class=\"line\">        String word = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span>[][] visited;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exist</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[board.length][board[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        </span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">        Trie tmp = trie;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[c] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                trie.next[c] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            trie = trie.next[c];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trie.word = word;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">char</span> s = board[i][j];</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp.next[s] == <span class=\"keyword\">null</span> || visited[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">                tmp = tmp.next[s];</span><br><span class=\"line\">                visited[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">4</span>; z++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> nx = i + dx[z];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> ny = j + dy[z];</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= board.length || ny &gt;= board[<span class=\"number\">0</span>].length || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">char</span> nc = board[nx][ny];    </span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(tmp.next[nc] == <span class=\"keyword\">null</span> || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    tmp = tmp.next[nc];</span><br><span class=\"line\">                    visited[nx][ny] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;    </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Problem of this approach is that I loop through the adjacent node vertically and horizontally. <strong>when it reaches to last index, there is no way travel back to previous index</strong>. so we need to use different way. Dynamic programming</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">        Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">127</span>];</span><br><span class=\"line\">        String word = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span>[][] visited;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exist</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[board.length][board[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        </span><br><span class=\"line\">        Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">        Trie tmp = trie;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(trie.next[c] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                trie.next[c] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            trie = trie.next[c];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trie.word = word;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(dfs(tmp, board, i, j)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(Trie tmp, <span class=\"keyword\">char</span>[][] board, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || j &lt; <span class=\"number\">0</span> || i &gt;= board.length || j &gt;= board[<span class=\"number\">0</span>].length || visited[i][j]) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span> s = board[i][j];</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp.next[s] == <span class=\"keyword\">null</span> || visited[i][j]) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp = tmp.next[s];</span><br><span class=\"line\">        visited[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> ans = dfs(tmp, board, i+<span class=\"number\">1</span>, j) || dfs(tmp, board, i, j+<span class=\"number\">1</span>) || dfs(tmp, board, i-<span class=\"number\">1</span>, j) || dfs(tmp, board, i, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        visited[i][j] = <span class=\"keyword\">false</span>; <span class=\"comment\">// if the character is not in the trie, then check unvisited</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a8535de-dbc5-4673-843e-353e98a876f6/Untitled.png\" alt=\"Untitled\"></p>\n<p>I used the backtracking instead of dynamic programing <strong>because when the current character is not in the trie, then it checks unvisited so that those index can be visited again later in time</strong>.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b0abaf9-239f-411e-9311-d16f3f87597e/83102DB4-5B57-473B-9248-DA95360DB983.jpeg\" alt=\"83102DB4-5B57-473B-9248-DA95360DB983.jpeg\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li><strong>we can contain 127 ascii characters in trie</strong> (when we don’t really want to care about anything else!)</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">    Trie[] next = <span class=\"keyword\">new</span> Trie[<span class=\"number\">127</span>];</span><br><span class=\"line\">    String word = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">Trie tmp = trie; <span class=\"comment\">// cache the pointer to the head node of trie</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = word.charAt(i);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(trie.next[c] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        trie.next[c] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    trie = trie.next[c];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trie.word = word;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><strong>cache the pointer to the head node of trie</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trie trie = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">Trie tmp = trie; <span class=\"comment\">// cache the pointer to the head node of trie</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li><strong>loop and dynamic programming is different!</strong>\n<ul>\n<li>the mistake I made on this question is that loop was enough. but loop doesn’t chain the next node. so if the loop reaches to the last index, there is no way it can traverse to the other nodes</li>\n<li><strong>if we need to traverse other node again! then we have to use dynamic programming</strong></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">char</span> s = board[i][j];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp.next[s] == <span class=\"keyword\">null</span> || visited[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        tmp = tmp.next[s];</span><br><span class=\"line\">        visited[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">4</span>; z++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nx = i + dx[z];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ny = j + dy[z];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= board.length || ny &gt;= board[<span class=\"number\">0</span>].length || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">char</span> nc = board[nx][ny];    </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.next[nc] == <span class=\"keyword\">null</span> || visited[nx][ny]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            tmp = tmp.next[nc];</span><br><span class=\"line\">            visited[nx][ny] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dfs(tmp, board, i, j)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(Trie tmp, <span class=\"keyword\">char</span>[][] board, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || j &lt; <span class=\"number\">0</span> || i &gt;= board.length || j &gt;= board[<span class=\"number\">0</span>].length || visited[i][j]) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> s = board[i][j];</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp.next[s] == <span class=\"keyword\">null</span> || visited[i][j]) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = tmp.next[s];</span><br><span class=\"line\">    visited[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!tmp.word.equals(<span class=\"string\">\"\"</span>)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> ans = dfs(tmp, board, i+<span class=\"number\">1</span>, j) || dfs(tmp, board, i, j+<span class=\"number\">1</span>) || dfs(tmp, board, i-<span class=\"number\">1</span>, j) || dfs(tmp, board, i, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    visited[i][j] = <span class=\"keyword\">false</span>; <span class=\"comment\">// if the character is not in the trie, then check unvisited</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>use <strong>the backtracking to initialize the condition in matrix problem</strong></li>\n</ol>\n"},{"title":"73. Set Matrix Zeroes","catalog":true,"date":"2022-10-05T10:49:51.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- if an element is `0`, set its entire row and column to `0`'s.\n- You must do it [in place](https://en.wikipedia.org/wiki/In-place_algorithm).\n\n## Solve by hands first\n\n---\n\niterate matrix from 0,0. if element at index is 0, makes rows and column to 0. \n\nThe problem is revisiting. **how can we know that entire row and column are 0 when current value is 0 without auxiliary data structure**? Time complexity is O(m*n*m*n)\n\nwe can create the temp matrix `visited[m][n]` in order to check if the element was 0 in the first place. Loop throught the `matrix` and mark 1 at `visited` . Iterate through whole matrix again, if the value in `visited` is 1 then we can fill `matrix` and `visited` with 0, -1 each. it needs to skip when the value in `visited` is 1. because we have to distinguish after filling\n\nTime complexity is O(m*n) and space complexity is also O(m*n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    int[][] visited;\n    \n    public void setZeroes(int[][] matrix) {\n        \n        visited = new int[matrix.length][matrix[0].length];\n        \n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                if(matrix[i][j] == 0) {\n                    visited[i][j] = 1;\n                }\n            }\n        }\n        \n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                if(visited[i][j] == 1) {\n                    fill(matrix, i, j);\n                }\n            }\n        }\n    }\n    \n    private void fill(int[][] matrix, int i, int j) {\n        for(int x = 0; x < matrix.length; x++) {\n            if(visited[x][j] == 1) continue;\n            matrix[x][j] = 0;\n            visited[x][j] = -1;\n        }\n        \n        for(int y = 0; y < matrix[0].length; y++) {\n            if(visited[i][y] == 1) continue;\n            matrix[i][y] = 0;\n            visited[i][y] = -1;\n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ec99712-21b3-448e-85e5-d4f7378bd845/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. [In-place algorithm](https://en.wikipedia.org/wiki/In-place_algorithm)\n    - transform input instead of using extra data structure\n","source":"_posts/73-Set-Matrix-Zeroes.md","raw":"---\ntitle: \"73.\\_Set Matrix Zeroes\"\ncatalog: true\ndate: 2022-10-05 19:49:51\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- if an element is `0`, set its entire row and column to `0`'s.\n- You must do it [in place](https://en.wikipedia.org/wiki/In-place_algorithm).\n\n## Solve by hands first\n\n---\n\niterate matrix from 0,0. if element at index is 0, makes rows and column to 0. \n\nThe problem is revisiting. **how can we know that entire row and column are 0 when current value is 0 without auxiliary data structure**? Time complexity is O(m*n*m*n)\n\nwe can create the temp matrix `visited[m][n]` in order to check if the element was 0 in the first place. Loop throught the `matrix` and mark 1 at `visited` . Iterate through whole matrix again, if the value in `visited` is 1 then we can fill `matrix` and `visited` with 0, -1 each. it needs to skip when the value in `visited` is 1. because we have to distinguish after filling\n\nTime complexity is O(m*n) and space complexity is also O(m*n)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    int[][] visited;\n    \n    public void setZeroes(int[][] matrix) {\n        \n        visited = new int[matrix.length][matrix[0].length];\n        \n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                if(matrix[i][j] == 0) {\n                    visited[i][j] = 1;\n                }\n            }\n        }\n        \n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                if(visited[i][j] == 1) {\n                    fill(matrix, i, j);\n                }\n            }\n        }\n    }\n    \n    private void fill(int[][] matrix, int i, int j) {\n        for(int x = 0; x < matrix.length; x++) {\n            if(visited[x][j] == 1) continue;\n            matrix[x][j] = 0;\n            visited[x][j] = -1;\n        }\n        \n        for(int y = 0; y < matrix[0].length; y++) {\n            if(visited[i][y] == 1) continue;\n            matrix[i][y] = 0;\n            visited[i][y] = -1;\n        }\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ec99712-21b3-448e-85e5-d4f7378bd845/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. [In-place algorithm](https://en.wikipedia.org/wiki/In-place_algorithm)\n    - transform input instead of using extra data structure\n","slug":"73-Set-Matrix-Zeroes","published":1,"updated":"2022-10-05T10:50:10.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1g0022qkccq2u3jg3o","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>if an element is <code>0</code>, set its entire row and column to <code>0</code>'s.</li>\n<li>You must do it <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in place</a>.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>iterate matrix from 0,0. if element at index is 0, makes rows and column to 0.</p>\n<p>The problem is revisiting. <strong>how can we know that entire row and column are 0 when current value is 0 without auxiliary data structure</strong>? Time complexity is O(m<em>n</em>m*n)</p>\n<p>we can create the temp matrix <code>visited[m][n]</code> in order to check if the element was 0 in the first place. Loop throught the <code>matrix</code> and mark 1 at <code>visited</code> . Iterate through whole matrix again, if the value in <code>visited</code> is 1 then we can fill <code>matrix</code> and <code>visited</code> with 0, -1 each. it needs to skip when the value in <code>visited</code> is 1. because we have to distinguish after filling</p>\n<p>Time complexity is O(m<em>n) and space complexity is also O(m</em>n)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] visited;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[matrix.length][matrix[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; matrix[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(matrix[i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    visited[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; matrix[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(visited[i][j] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    fill(matrix, i, j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fill</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt; matrix.length; x++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(visited[x][j] == <span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            matrix[x][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            visited[x][j] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y = <span class=\"number\">0</span>; y &lt; matrix[<span class=\"number\">0</span>].length; y++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(visited[i][y] == <span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            matrix[i][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            visited[i][y] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ec99712-21b3-448e-85e5-d4f7378bd845/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li><a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">In-place algorithm</a>\n<ul>\n<li>transform input instead of using extra data structure</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>if an element is <code>0</code>, set its entire row and column to <code>0</code>'s.</li>\n<li>You must do it <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in place</a>.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>iterate matrix from 0,0. if element at index is 0, makes rows and column to 0.</p>\n<p>The problem is revisiting. <strong>how can we know that entire row and column are 0 when current value is 0 without auxiliary data structure</strong>? Time complexity is O(m<em>n</em>m*n)</p>\n<p>we can create the temp matrix <code>visited[m][n]</code> in order to check if the element was 0 in the first place. Loop throught the <code>matrix</code> and mark 1 at <code>visited</code> . Iterate through whole matrix again, if the value in <code>visited</code> is 1 then we can fill <code>matrix</code> and <code>visited</code> with 0, -1 each. it needs to skip when the value in <code>visited</code> is 1. because we have to distinguish after filling</p>\n<p>Time complexity is O(m<em>n) and space complexity is also O(m</em>n)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] visited;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        visited = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[matrix.length][matrix[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; matrix[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(matrix[i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    visited[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; matrix[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(visited[i][j] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    fill(matrix, i, j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fill</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt; matrix.length; x++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(visited[x][j] == <span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            matrix[x][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            visited[x][j] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y = <span class=\"number\">0</span>; y &lt; matrix[<span class=\"number\">0</span>].length; y++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(visited[i][y] == <span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            matrix[i][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            visited[i][y] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ec99712-21b3-448e-85e5-d4f7378bd845/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li><a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">In-place algorithm</a>\n<ul>\n<li>transform input instead of using extra data structure</li>\n</ul>\n</li>\n</ol>\n"},{"title":"920. Meeting Rooms","catalog":true,"date":"2022-10-19T11:47:00.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- with the given array of meeting time intervals consisting of start and end times, determine if the person could attend all meetings\n\n### **Edge cases**\n\n---\n\n- elements are all positive?\n- element is in ascending order or order doesn’t matter?\n- [] → false\n- [[1,2]] → true\n- [[1,2],[2,3] → false\n- [[1,2],[2,1] → false\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nStarting from intervals[0] and compare intervals[1] … intervals[n]. if the start time of next interval is less than equals to previous interval end time, then return false. otherwise retur true. but it’s only possible when intervals is ordered by start time. For instance [[5,10],[100,200],[20.25]] in this case 20 is less than 200 but person can attend all class\n\nif we order the intervals by the start time, it will look like [[5,10],[20,25][100,200]], in this case we can compare adjacent intervals.\n\n```java\npublic boolean canAttendMeetings(List<Interval> intervals) {\n    Collections.sort(intervals, (a,b) -> a.start - b.start);\n    \n    for(int i = 1; i < intervals.size(); i++) {\n        if(intervals.get(i-1).end > intervals.get(i).start) return false;\n    }\n    return true;\n}\n```\n\nTime complexity is O(dual pivot quick sort) + O(length of intervals) which is O(nlog(n)) + O(n) = O(nlog(n))\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n*the interviewer can provide you with some hints to unblock you*\n\n*it’s okay to ask the interviewer for direction.*\n\n### **Coding**\n\n---\n\n```java\npublic boolean canAttendMeetings(List<Interval> intervals) {\n\t\tif(intervals.size() == 0 || intervals == null) return true;\n\n    Collections.sort(intervals, (a,b) -> a.start - b.start);\n    \n    for(int i = 1; i < intervals.size(); i++) {\n        if(intervals.get(i-1).end > intervals.get(i).start) return false;\n    }\n    return true;\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/48038efb-ce8e-49a7-9a08-10517ab29986/Untitled.png)\n\n### What I learned\n\n---\n\n1. edge case can be a good to decrease the running time\n2. compare previous index and current index. start with index 1 and compare `*i*` and `*i-1*`\n\n```java\n for(int i = 1; i < nums.length; i++) {\n    if(nums[i-1] > nums[i]) return true;\n}\n```\n","source":"_posts/920-Meeting-Rooms.md","raw":"---\ntitle: 920. Meeting Rooms\ncatalog: true\ndate: 2022-10-19 20:47:00\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- with the given array of meeting time intervals consisting of start and end times, determine if the person could attend all meetings\n\n### **Edge cases**\n\n---\n\n- elements are all positive?\n- element is in ascending order or order doesn’t matter?\n- [] → false\n- [[1,2]] → true\n- [[1,2],[2,3] → false\n- [[1,2],[2,1] → false\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nStarting from intervals[0] and compare intervals[1] … intervals[n]. if the start time of next interval is less than equals to previous interval end time, then return false. otherwise retur true. but it’s only possible when intervals is ordered by start time. For instance [[5,10],[100,200],[20.25]] in this case 20 is less than 200 but person can attend all class\n\nif we order the intervals by the start time, it will look like [[5,10],[20,25][100,200]], in this case we can compare adjacent intervals.\n\n```java\npublic boolean canAttendMeetings(List<Interval> intervals) {\n    Collections.sort(intervals, (a,b) -> a.start - b.start);\n    \n    for(int i = 1; i < intervals.size(); i++) {\n        if(intervals.get(i-1).end > intervals.get(i).start) return false;\n    }\n    return true;\n}\n```\n\nTime complexity is O(dual pivot quick sort) + O(length of intervals) which is O(nlog(n)) + O(n) = O(nlog(n))\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n*the interviewer can provide you with some hints to unblock you*\n\n*it’s okay to ask the interviewer for direction.*\n\n### **Coding**\n\n---\n\n```java\npublic boolean canAttendMeetings(List<Interval> intervals) {\n\t\tif(intervals.size() == 0 || intervals == null) return true;\n\n    Collections.sort(intervals, (a,b) -> a.start - b.start);\n    \n    for(int i = 1; i < intervals.size(); i++) {\n        if(intervals.get(i-1).end > intervals.get(i).start) return false;\n    }\n    return true;\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/48038efb-ce8e-49a7-9a08-10517ab29986/Untitled.png)\n\n### What I learned\n\n---\n\n1. edge case can be a good to decrease the running time\n2. compare previous index and current index. start with index 1 and compare `*i*` and `*i-1*`\n\n```java\n for(int i = 1; i < nums.length; i++) {\n    if(nums[i-1] > nums[i]) return true;\n}\n```\n","slug":"920-Meeting-Rooms","published":1,"updated":"2022-10-19T11:47:23.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1g0023qkcc3xjm88vr","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>with the given array of meeting time intervals consisting of start and end times, determine if the person could attend all meetings</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>elements are all positive?</li>\n<li>element is in ascending order or order doesn’t matter?</li>\n<li>[] → false</li>\n<li>[[1,2]] → true</li>\n<li>[[1,2],[2,3] → false</li>\n<li>[[1,2],[2,1] → false</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>Starting from intervals[0] and compare intervals[1] … intervals[n]. if the start time of next interval is less than equals to previous interval end time, then return false. otherwise retur true. but it’s only possible when intervals is ordered by start time. For instance [[5,10],[100,200],[20.25]] in this case 20 is less than 200 but person can attend all class</p>\n<p>if we order the intervals by the start time, it will look like [[5,10],[20,25][100,200]], in this case we can compare adjacent intervals.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canAttendMeetings</span><span class=\"params\">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class=\"line\">    Collections.sort(intervals, (a,b) -&gt; a.start - b.start);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals.get(i-<span class=\"number\">1</span>).end &gt; intervals.get(i).start) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Time complexity is O(dual pivot quick sort) + O(length of intervals) which is O(nlog(n)) + O(n) = O(nlog(n))</p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p><em>the interviewer can provide you with some hints to unblock you</em></p>\n<p><em>it’s okay to ask the interviewer for direction.</em></p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canAttendMeetings</span><span class=\"params\">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(intervals.size() == <span class=\"number\">0</span> || intervals == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Collections.sort(intervals, (a,b) -&gt; a.start - b.start);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals.get(i-<span class=\"number\">1</span>).end &gt; intervals.get(i).start) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/48038efb-ce8e-49a7-9a08-10517ab29986/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>edge case can be a good to decrease the running time</li>\n<li>compare previous index and current index. start with index 1 and compare <code>*i*</code> and <code>*i-1*</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[i-<span class=\"number\">1</span>] &gt; nums[i]) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>with the given array of meeting time intervals consisting of start and end times, determine if the person could attend all meetings</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>elements are all positive?</li>\n<li>element is in ascending order or order doesn’t matter?</li>\n<li>[] → false</li>\n<li>[[1,2]] → true</li>\n<li>[[1,2],[2,3] → false</li>\n<li>[[1,2],[2,1] → false</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>Starting from intervals[0] and compare intervals[1] … intervals[n]. if the start time of next interval is less than equals to previous interval end time, then return false. otherwise retur true. but it’s only possible when intervals is ordered by start time. For instance [[5,10],[100,200],[20.25]] in this case 20 is less than 200 but person can attend all class</p>\n<p>if we order the intervals by the start time, it will look like [[5,10],[20,25][100,200]], in this case we can compare adjacent intervals.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canAttendMeetings</span><span class=\"params\">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class=\"line\">    Collections.sort(intervals, (a,b) -&gt; a.start - b.start);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals.get(i-<span class=\"number\">1</span>).end &gt; intervals.get(i).start) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Time complexity is O(dual pivot quick sort) + O(length of intervals) which is O(nlog(n)) + O(n) = O(nlog(n))</p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p><em>the interviewer can provide you with some hints to unblock you</em></p>\n<p><em>it’s okay to ask the interviewer for direction.</em></p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canAttendMeetings</span><span class=\"params\">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(intervals.size() == <span class=\"number\">0</span> || intervals == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Collections.sort(intervals, (a,b) -&gt; a.start - b.start);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals.get(i-<span class=\"number\">1</span>).end &gt; intervals.get(i).start) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/48038efb-ce8e-49a7-9a08-10517ab29986/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>edge case can be a good to decrease the running time</li>\n<li>compare previous index and current index. start with index 1 and compare <code>*i*</code> and <code>*i-1*</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[i-<span class=\"number\">1</span>] &gt; nums[i]) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"91. Decode Ways","catalog":true,"date":"2022-10-21T13:10:58.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- return the number of ways to decode\n- answer fits in 32 bit integer\n\n### **Edge cases**\n\n---\n\n- 12 → (1, 2), (12) → 2\n- 101 → (10, 1) → 1\n- 01 → 0\n- 226 → (2, 2, 6), (22, 6) (2, 26)\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nWe have to find all possible ways to decode. it can be combination of the numbers in array. dfs can be a good way to start. we visit the first index and visit next index because single digits can be encoded (1 ~ 9 which encoded as A ~ I). There is another possibility on two digits which ranges between 10 to 26. let’s say if the next index value is 1, we could check out next index and if the next index value is between 0 to 9. if the next index value is 2, we could check out enxt index and if the next index valu is between 0 to 6 then we can add the 1 on current possible way of decode. Base case is when the current index is equals to the length of string. because it hits the last character in string. in this case we can simply return 1. it means we found the one way to decode (since we hit at the end of string)\n\nThe problem is number 0. if the current value is 0, there is no way we can decode except previous index was 1 or 2. \n\nnode is index and return value is ways to decode. Time complexity is O(2^(length of input string)) (Since it is binary tree with left child (idx+1) and right child (idx+2)) and space complexity is O(1)\n\n```java\npublic int numDecodings(String s) {\n\treturn dfs(s, 0);\t\n}\n\nprivate int dfs(String s, int idx) {\n\tif(idx == s.length()) return 1;\n\n\tchar c = s.charAt(idx);\n\tif(c == '0') return 0;         // previous index already skip when next value is 0 (only when previous index value was 1 or 2)\n\tint way = dfs(s, idx + 1);\n\tif(idx + 1 < s.length() && (c == '1' || (c == '2' && s.charAt(idx + 1) <= '6'))) {\n\t\tway += dfs(s, idx + 2);\n\t}\n\treturn way;\n}\n```\n\n![80052E58-0727-46EA-931F-E19C41B84D34.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cebad307-3c23-4143-b139-e2965a94dcbe/80052E58-0727-46EA-931F-E19C41B84D34.jpeg)\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nLet’s optimize above solution with memoization. What we are looking for is way to decode which is `way` variable in the code. we can simply switch the variable with integer array. Time complexity is O(n) and space complexity is O(n)\n\n```java\nInteger[] dp;\npublic int numDecodings(String s) {\n\tdp = new Integer[s.length()];\n\treturn dfs(s, 0);\t\n}\n\nprivate int dfs(String s, int idx) {\n\tif(idx == s.length()) return 1;\n\tif(dp[idx] != null) return dp[idx];\n\t\n\tchar c = s.charAt(idx);\n\tif(c == '0') return 0;         // previous index already skip when next value is 0 (only when previous index value was 1 or 2)\n\tdp[idx] = dfs(s, idx + 1);\n\tif(idx + 1 < s.length() && (c == '1' || (c == '2' && s.charAt(idx + 1) <= '6'))) {\n\t\tdp[idx] += dfs(s, idx + 2);\n\t}\n\treturn dp[idx];\n}\n```\n\n![2B732F45-6ED2-49FC-AFA3-230DBDF5104E.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/caf6b618-6234-4ed1-b6c1-a800db88786c/2B732F45-6ED2-49FC-AFA3-230DBDF5104E.jpeg)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n\n    Integer[] dp;\n    public int numDecodings(String s) {\n        dp = new Integer[s.length()];\n        return dfs(s, 0);\t\n    }\n\n    private int dfs(String s, int idx) {\n        if(idx == s.length()) return 1;\n        if(dp[idx] != null) return dp[idx];\n\n        char c = s.charAt(idx);\n        if(c == '0') return 0; // previous index already skip when next value is 0 (only when previous index value was 1 or 2)\n        \n        dp[idx] = dfs(s, idx + 1);\n        if(idx + 1 < s.length() && (c == '1' || (c == '2' && s.charAt(idx + 1) <= '6'))) {\n            dp[idx] += dfs(s, idx + 2);\n        }\n        return dp[idx];\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72dc8806-c7af-4960-b0b0-47d426ad8e9d/Untitled.png)\n\n### What I learned\n\n---\n\n1. **index tree is more intutive than value tree in dynamic programming**\n\n![2E071145-C92A-4F4E-98F4-202A7552C487.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e94b726b-33d6-4e4f-acf7-aaa24689d88a/2E071145-C92A-4F4E-98F4-202A7552C487.jpeg)\n\n![CBFEBF63-59B9-4AFB-B658-A06170A1AB1B.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b28c4bc-99ac-4c32-b9f9-9a239f25755c/CBFEBF63-59B9-4AFB-B658-A06170A1AB1B.jpeg)\n\n1. most of base case in dynamic programming is `n.length()` which is null \n\n```java\nprivate int dfs(String s, int i) {\n    if(i == s.length()) return 1; // quickly return to prev node\n    ...\n    return r;\n}\n```\n\n1. Each line of the if statement can affect other node\n\n```java\nprivate int dfs(String s, int i) {\n    if(i == s.length()) return 1; // don't need care until i reach to the length\n    \n    char c = s.charAt(i);\n    if(c == '0') return 0; // can be point in time        \n    \n    int r = dfs(s, i + 1); \n    if(i + 1 < s.length() && (c == '1' || c == '2' && s.charAt(i + 1) < '7')) { // can't be higher than length anyway\n        r += dfs(s, i + 2);\n    }\n\n    return r;\n}\n```\n\n1. We can skip indices not iterate one index at a time\n\n```java\nif(c == '0') return 0; // 2. so this can be skipped in below condition!\n\nint r = dfs(s, i + 1); \nif(i + 1 < s.length() && (c == '1' || c == '2' && s.charAt(i + 1) < '7')) { // can't be higher than length anyway\n    r += dfs(s, i + 2); // 1. we can skip the 0 value index\n}\n```\n","source":"_posts/91-Decode-Ways.md","raw":"---\ntitle: \"91.\\_Decode Ways\"\ncatalog: true\ndate: 2022-10-21 22:10:58\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- return the number of ways to decode\n- answer fits in 32 bit integer\n\n### **Edge cases**\n\n---\n\n- 12 → (1, 2), (12) → 2\n- 101 → (10, 1) → 1\n- 01 → 0\n- 226 → (2, 2, 6), (22, 6) (2, 26)\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nWe have to find all possible ways to decode. it can be combination of the numbers in array. dfs can be a good way to start. we visit the first index and visit next index because single digits can be encoded (1 ~ 9 which encoded as A ~ I). There is another possibility on two digits which ranges between 10 to 26. let’s say if the next index value is 1, we could check out next index and if the next index value is between 0 to 9. if the next index value is 2, we could check out enxt index and if the next index valu is between 0 to 6 then we can add the 1 on current possible way of decode. Base case is when the current index is equals to the length of string. because it hits the last character in string. in this case we can simply return 1. it means we found the one way to decode (since we hit at the end of string)\n\nThe problem is number 0. if the current value is 0, there is no way we can decode except previous index was 1 or 2. \n\nnode is index and return value is ways to decode. Time complexity is O(2^(length of input string)) (Since it is binary tree with left child (idx+1) and right child (idx+2)) and space complexity is O(1)\n\n```java\npublic int numDecodings(String s) {\n\treturn dfs(s, 0);\t\n}\n\nprivate int dfs(String s, int idx) {\n\tif(idx == s.length()) return 1;\n\n\tchar c = s.charAt(idx);\n\tif(c == '0') return 0;         // previous index already skip when next value is 0 (only when previous index value was 1 or 2)\n\tint way = dfs(s, idx + 1);\n\tif(idx + 1 < s.length() && (c == '1' || (c == '2' && s.charAt(idx + 1) <= '6'))) {\n\t\tway += dfs(s, idx + 2);\n\t}\n\treturn way;\n}\n```\n\n![80052E58-0727-46EA-931F-E19C41B84D34.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cebad307-3c23-4143-b139-e2965a94dcbe/80052E58-0727-46EA-931F-E19C41B84D34.jpeg)\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\nLet’s optimize above solution with memoization. What we are looking for is way to decode which is `way` variable in the code. we can simply switch the variable with integer array. Time complexity is O(n) and space complexity is O(n)\n\n```java\nInteger[] dp;\npublic int numDecodings(String s) {\n\tdp = new Integer[s.length()];\n\treturn dfs(s, 0);\t\n}\n\nprivate int dfs(String s, int idx) {\n\tif(idx == s.length()) return 1;\n\tif(dp[idx] != null) return dp[idx];\n\t\n\tchar c = s.charAt(idx);\n\tif(c == '0') return 0;         // previous index already skip when next value is 0 (only when previous index value was 1 or 2)\n\tdp[idx] = dfs(s, idx + 1);\n\tif(idx + 1 < s.length() && (c == '1' || (c == '2' && s.charAt(idx + 1) <= '6'))) {\n\t\tdp[idx] += dfs(s, idx + 2);\n\t}\n\treturn dp[idx];\n}\n```\n\n![2B732F45-6ED2-49FC-AFA3-230DBDF5104E.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/caf6b618-6234-4ed1-b6c1-a800db88786c/2B732F45-6ED2-49FC-AFA3-230DBDF5104E.jpeg)\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n\n    Integer[] dp;\n    public int numDecodings(String s) {\n        dp = new Integer[s.length()];\n        return dfs(s, 0);\t\n    }\n\n    private int dfs(String s, int idx) {\n        if(idx == s.length()) return 1;\n        if(dp[idx] != null) return dp[idx];\n\n        char c = s.charAt(idx);\n        if(c == '0') return 0; // previous index already skip when next value is 0 (only when previous index value was 1 or 2)\n        \n        dp[idx] = dfs(s, idx + 1);\n        if(idx + 1 < s.length() && (c == '1' || (c == '2' && s.charAt(idx + 1) <= '6'))) {\n            dp[idx] += dfs(s, idx + 2);\n        }\n        return dp[idx];\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72dc8806-c7af-4960-b0b0-47d426ad8e9d/Untitled.png)\n\n### What I learned\n\n---\n\n1. **index tree is more intutive than value tree in dynamic programming**\n\n![2E071145-C92A-4F4E-98F4-202A7552C487.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e94b726b-33d6-4e4f-acf7-aaa24689d88a/2E071145-C92A-4F4E-98F4-202A7552C487.jpeg)\n\n![CBFEBF63-59B9-4AFB-B658-A06170A1AB1B.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b28c4bc-99ac-4c32-b9f9-9a239f25755c/CBFEBF63-59B9-4AFB-B658-A06170A1AB1B.jpeg)\n\n1. most of base case in dynamic programming is `n.length()` which is null \n\n```java\nprivate int dfs(String s, int i) {\n    if(i == s.length()) return 1; // quickly return to prev node\n    ...\n    return r;\n}\n```\n\n1. Each line of the if statement can affect other node\n\n```java\nprivate int dfs(String s, int i) {\n    if(i == s.length()) return 1; // don't need care until i reach to the length\n    \n    char c = s.charAt(i);\n    if(c == '0') return 0; // can be point in time        \n    \n    int r = dfs(s, i + 1); \n    if(i + 1 < s.length() && (c == '1' || c == '2' && s.charAt(i + 1) < '7')) { // can't be higher than length anyway\n        r += dfs(s, i + 2);\n    }\n\n    return r;\n}\n```\n\n1. We can skip indices not iterate one index at a time\n\n```java\nif(c == '0') return 0; // 2. so this can be skipped in below condition!\n\nint r = dfs(s, i + 1); \nif(i + 1 < s.length() && (c == '1' || c == '2' && s.charAt(i + 1) < '7')) { // can't be higher than length anyway\n    r += dfs(s, i + 2); // 1. we can skip the 0 value index\n}\n```\n","slug":"91-Decode-Ways","published":1,"updated":"2022-10-21T13:11:26.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1g0024qkcc808mt2s7","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>return the number of ways to decode</li>\n<li>answer fits in 32 bit integer</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>12 → (1, 2), (12) → 2</li>\n<li>101 → (10, 1) → 1</li>\n<li>01 → 0</li>\n<li>226 → (2, 2, 6), (22, 6) (2, 26)</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>We have to find all possible ways to decode. it can be combination of the numbers in array. dfs can be a good way to start. we visit the first index and visit next index because single digits can be encoded (1 ~ 9 which encoded as A ~ I). There is another possibility on two digits which ranges between 10 to 26. let’s say if the next index value is 1, we could check out next index and if the next index value is between 0 to 9. if the next index value is 2, we could check out enxt index and if the next index valu is between 0 to 6 then we can add the 1 on current possible way of decode. Base case is when the current index is equals to the length of string. because it hits the last character in string. in this case we can simply return 1. it means we found the one way to decode (since we hit at the end of string)</p>\n<p>The problem is number 0. if the current value is 0, there is no way we can decode except previous index was 1 or 2.</p>\n<p>node is index and return value is ways to decode. Time complexity is O(2^(length of input string)) (Since it is binary tree with left child (idx+1) and right child (idx+2)) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dfs(s, <span class=\"number\">0</span>);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(idx == s.length()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> c = s.charAt(idx);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(c == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;         <span class=\"comment\">// previous index already skip when next value is 0 (only when previous index value was 1 or 2)</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> way = dfs(s, idx + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(idx + <span class=\"number\">1</span> &lt; s.length() &amp;&amp; (c == <span class=\"string\">'1'</span> || (c == <span class=\"string\">'2'</span> &amp;&amp; s.charAt(idx + <span class=\"number\">1</span>) &lt;= <span class=\"string\">'6'</span>))) &#123;</span><br><span class=\"line\">\t\tway += dfs(s, idx + <span class=\"number\">2</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> way;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cebad307-3c23-4143-b139-e2965a94dcbe/80052E58-0727-46EA-931F-E19C41B84D34.jpeg\" alt=\"80052E58-0727-46EA-931F-E19C41B84D34.jpeg\"></p>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<p>Let’s optimize above solution with memoization. What we are looking for is way to decode which is <code>way</code> variable in the code. we can simply switch the variable with integer array. Time complexity is O(n) and space complexity is O(n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] dp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">\tdp = <span class=\"keyword\">new</span> Integer[s.length()];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dfs(s, <span class=\"number\">0</span>);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(idx == s.length()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(dp[idx] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> c = s.charAt(idx);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(c == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;         <span class=\"comment\">// previous index already skip when next value is 0 (only when previous index value was 1 or 2)</span></span><br><span class=\"line\">\tdp[idx] = dfs(s, idx + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(idx + <span class=\"number\">1</span> &lt; s.length() &amp;&amp; (c == <span class=\"string\">'1'</span> || (c == <span class=\"string\">'2'</span> &amp;&amp; s.charAt(idx + <span class=\"number\">1</span>) &lt;= <span class=\"string\">'6'</span>))) &#123;</span><br><span class=\"line\">\t\tdp[idx] += dfs(s, idx + <span class=\"number\">2</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/caf6b618-6234-4ed1-b6c1-a800db88786c/2B732F45-6ED2-49FC-AFA3-230DBDF5104E.jpeg\" alt=\"2B732F45-6ED2-49FC-AFA3-230DBDF5104E.jpeg\"></p>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer[] dp;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> Integer[s.length()];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(s, <span class=\"number\">0</span>);\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(idx == s.length()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[idx] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = s.charAt(idx);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// previous index already skip when next value is 0 (only when previous index value was 1 or 2)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dp[idx] = dfs(s, idx + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(idx + <span class=\"number\">1</span> &lt; s.length() &amp;&amp; (c == <span class=\"string\">'1'</span> || (c == <span class=\"string\">'2'</span> &amp;&amp; s.charAt(idx + <span class=\"number\">1</span>) &lt;= <span class=\"string\">'6'</span>))) &#123;</span><br><span class=\"line\">            dp[idx] += dfs(s, idx + <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72dc8806-c7af-4960-b0b0-47d426ad8e9d/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li><strong>index tree is more intutive than value tree in dynamic programming</strong></li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e94b726b-33d6-4e4f-acf7-aaa24689d88a/2E071145-C92A-4F4E-98F4-202A7552C487.jpeg\" alt=\"2E071145-C92A-4F4E-98F4-202A7552C487.jpeg\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b28c4bc-99ac-4c32-b9f9-9a239f25755c/CBFEBF63-59B9-4AFB-B658-A06170A1AB1B.jpeg\" alt=\"CBFEBF63-59B9-4AFB-B658-A06170A1AB1B.jpeg\"></p>\n<ol>\n<li>most of base case in dynamic programming is <code>n.length()</code> which is null</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i == s.length()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// quickly return to prev node</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Each line of the if statement can affect other node</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i == s.length()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// don't need care until i reach to the length</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// can be point in time        </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = dfs(s, i + <span class=\"number\">1</span>); </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i + <span class=\"number\">1</span> &lt; s.length() &amp;&amp; (c == <span class=\"string\">'1'</span> || c == <span class=\"string\">'2'</span> &amp;&amp; s.charAt(i + <span class=\"number\">1</span>) &lt; <span class=\"string\">'7'</span>)) &#123; <span class=\"comment\">// can't be higher than length anyway</span></span><br><span class=\"line\">        r += dfs(s, i + <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>We can skip indices not iterate one index at a time</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(c == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 2. so this can be skipped in below condition!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> r = dfs(s, i + <span class=\"number\">1</span>); </span><br><span class=\"line\"><span class=\"keyword\">if</span>(i + <span class=\"number\">1</span> &lt; s.length() &amp;&amp; (c == <span class=\"string\">'1'</span> || c == <span class=\"string\">'2'</span> &amp;&amp; s.charAt(i + <span class=\"number\">1</span>) &lt; <span class=\"string\">'7'</span>)) &#123; <span class=\"comment\">// can't be higher than length anyway</span></span><br><span class=\"line\">    r += dfs(s, i + <span class=\"number\">2</span>); <span class=\"comment\">// 1. we can skip the 0 value index</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>return the number of ways to decode</li>\n<li>answer fits in 32 bit integer</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>12 → (1, 2), (12) → 2</li>\n<li>101 → (10, 1) → 1</li>\n<li>01 → 0</li>\n<li>226 → (2, 2, 6), (22, 6) (2, 26)</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>We have to find all possible ways to decode. it can be combination of the numbers in array. dfs can be a good way to start. we visit the first index and visit next index because single digits can be encoded (1 ~ 9 which encoded as A ~ I). There is another possibility on two digits which ranges between 10 to 26. let’s say if the next index value is 1, we could check out next index and if the next index value is between 0 to 9. if the next index value is 2, we could check out enxt index and if the next index valu is between 0 to 6 then we can add the 1 on current possible way of decode. Base case is when the current index is equals to the length of string. because it hits the last character in string. in this case we can simply return 1. it means we found the one way to decode (since we hit at the end of string)</p>\n<p>The problem is number 0. if the current value is 0, there is no way we can decode except previous index was 1 or 2.</p>\n<p>node is index and return value is ways to decode. Time complexity is O(2^(length of input string)) (Since it is binary tree with left child (idx+1) and right child (idx+2)) and space complexity is O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dfs(s, <span class=\"number\">0</span>);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(idx == s.length()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> c = s.charAt(idx);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(c == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;         <span class=\"comment\">// previous index already skip when next value is 0 (only when previous index value was 1 or 2)</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> way = dfs(s, idx + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(idx + <span class=\"number\">1</span> &lt; s.length() &amp;&amp; (c == <span class=\"string\">'1'</span> || (c == <span class=\"string\">'2'</span> &amp;&amp; s.charAt(idx + <span class=\"number\">1</span>) &lt;= <span class=\"string\">'6'</span>))) &#123;</span><br><span class=\"line\">\t\tway += dfs(s, idx + <span class=\"number\">2</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> way;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cebad307-3c23-4143-b139-e2965a94dcbe/80052E58-0727-46EA-931F-E19C41B84D34.jpeg\" alt=\"80052E58-0727-46EA-931F-E19C41B84D34.jpeg\"></p>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<p>Let’s optimize above solution with memoization. What we are looking for is way to decode which is <code>way</code> variable in the code. we can simply switch the variable with integer array. Time complexity is O(n) and space complexity is O(n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] dp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">\tdp = <span class=\"keyword\">new</span> Integer[s.length()];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dfs(s, <span class=\"number\">0</span>);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(idx == s.length()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(dp[idx] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> c = s.charAt(idx);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(c == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;         <span class=\"comment\">// previous index already skip when next value is 0 (only when previous index value was 1 or 2)</span></span><br><span class=\"line\">\tdp[idx] = dfs(s, idx + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(idx + <span class=\"number\">1</span> &lt; s.length() &amp;&amp; (c == <span class=\"string\">'1'</span> || (c == <span class=\"string\">'2'</span> &amp;&amp; s.charAt(idx + <span class=\"number\">1</span>) &lt;= <span class=\"string\">'6'</span>))) &#123;</span><br><span class=\"line\">\t\tdp[idx] += dfs(s, idx + <span class=\"number\">2</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/caf6b618-6234-4ed1-b6c1-a800db88786c/2B732F45-6ED2-49FC-AFA3-230DBDF5104E.jpeg\" alt=\"2B732F45-6ED2-49FC-AFA3-230DBDF5104E.jpeg\"></p>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer[] dp;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        dp = <span class=\"keyword\">new</span> Integer[s.length()];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(s, <span class=\"number\">0</span>);\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(idx == s.length()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[idx] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = s.charAt(idx);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// previous index already skip when next value is 0 (only when previous index value was 1 or 2)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dp[idx] = dfs(s, idx + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(idx + <span class=\"number\">1</span> &lt; s.length() &amp;&amp; (c == <span class=\"string\">'1'</span> || (c == <span class=\"string\">'2'</span> &amp;&amp; s.charAt(idx + <span class=\"number\">1</span>) &lt;= <span class=\"string\">'6'</span>))) &#123;</span><br><span class=\"line\">            dp[idx] += dfs(s, idx + <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[idx];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72dc8806-c7af-4960-b0b0-47d426ad8e9d/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li><strong>index tree is more intutive than value tree in dynamic programming</strong></li>\n</ol>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e94b726b-33d6-4e4f-acf7-aaa24689d88a/2E071145-C92A-4F4E-98F4-202A7552C487.jpeg\" alt=\"2E071145-C92A-4F4E-98F4-202A7552C487.jpeg\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b28c4bc-99ac-4c32-b9f9-9a239f25755c/CBFEBF63-59B9-4AFB-B658-A06170A1AB1B.jpeg\" alt=\"CBFEBF63-59B9-4AFB-B658-A06170A1AB1B.jpeg\"></p>\n<ol>\n<li>most of base case in dynamic programming is <code>n.length()</code> which is null</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i == s.length()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// quickly return to prev node</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Each line of the if statement can affect other node</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i == s.length()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// don't need care until i reach to the length</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// can be point in time        </span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = dfs(s, i + <span class=\"number\">1</span>); </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i + <span class=\"number\">1</span> &lt; s.length() &amp;&amp; (c == <span class=\"string\">'1'</span> || c == <span class=\"string\">'2'</span> &amp;&amp; s.charAt(i + <span class=\"number\">1</span>) &lt; <span class=\"string\">'7'</span>)) &#123; <span class=\"comment\">// can't be higher than length anyway</span></span><br><span class=\"line\">        r += dfs(s, i + <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>We can skip indices not iterate one index at a time</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(c == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 2. so this can be skipped in below condition!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> r = dfs(s, i + <span class=\"number\">1</span>); </span><br><span class=\"line\"><span class=\"keyword\">if</span>(i + <span class=\"number\">1</span> &lt; s.length() &amp;&amp; (c == <span class=\"string\">'1'</span> || c == <span class=\"string\">'2'</span> &amp;&amp; s.charAt(i + <span class=\"number\">1</span>) &lt; <span class=\"string\">'7'</span>)) &#123; <span class=\"comment\">// can't be higher than length anyway</span></span><br><span class=\"line\">    r += dfs(s, i + <span class=\"number\">2</span>); <span class=\"comment\">// 1. we can skip the 0 value index</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"938. Range Sum of BST","catalog":true,"date":"2022-09-18T14:56:20.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- binary search tree\n- 1 <= Node.val <= 105\n- 1 <= low <= high <= 105\n- All `Node.val` are **unique**.\n\n## Solve by hands first\n\n---\n\nwe can use the character of binary search tree. we don’t need to check any nodes less than lower bound and greater than upper bound. if we check the first node and its value is less than lower bound then we need higher value so move to the right node. if we check the first node and its value is greater than upper bound then we need smaller value so move to the left node. if the value of current node is within the range then add the value then check left and right node because value of the child nodes can be without the range as well.  but if valud of child node is null then we can return 0 since its doesn’t need to added. then we can simply pass the added value to parent node.\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null) return 0;\n        if(root.val < low) return rangeSumBST(root.right, low, high); // low 보다 작은 노드는 갈 필요가 없다. 그러니 오른쪽 노드만 살펴보면 됨\n        if(root.val > high) return rangeSumBST(root.left, low, high); // high 보다 큰 노드는 갈 필요가 없다. 그러니 왼쪽 노드만 살펴보면 됨\n        return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\n    }\n}\n```\n\n![1D103191-F17F-4BDF-A9A9-3B2B09D7957D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ae21bc5-4c3e-4a24-9ed8-9050362dec48/1D103191-F17F-4BDF-A9A9-3B2B09D7957D.jpeg)\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a81ff54-737c-43a5-9e45-544034839154/Untitled.png)\n\n### Lesson I learnt\n\n---\n\n1. left node is less than its parent node in binary search tree\n2. right node is greater than its parent node in birnary search tree\n","source":"_posts/938-Range-Sum-of-BST.md","raw":"---\ntitle: \"938.\\_Range Sum of BST\"\ncatalog: true\ndate: 2022-09-18 23:56:20\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- binary search tree\n- 1 <= Node.val <= 105\n- 1 <= low <= high <= 105\n- All `Node.val` are **unique**.\n\n## Solve by hands first\n\n---\n\nwe can use the character of binary search tree. we don’t need to check any nodes less than lower bound and greater than upper bound. if we check the first node and its value is less than lower bound then we need higher value so move to the right node. if we check the first node and its value is greater than upper bound then we need smaller value so move to the left node. if the value of current node is within the range then add the value then check left and right node because value of the child nodes can be without the range as well.  but if valud of child node is null then we can return 0 since its doesn’t need to added. then we can simply pass the added value to parent node.\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    \n    public int rangeSumBST(TreeNode root, int low, int high) {\n        if(root == null) return 0;\n        if(root.val < low) return rangeSumBST(root.right, low, high); // low 보다 작은 노드는 갈 필요가 없다. 그러니 오른쪽 노드만 살펴보면 됨\n        if(root.val > high) return rangeSumBST(root.left, low, high); // high 보다 큰 노드는 갈 필요가 없다. 그러니 왼쪽 노드만 살펴보면 됨\n        return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);\n    }\n}\n```\n\n![1D103191-F17F-4BDF-A9A9-3B2B09D7957D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ae21bc5-4c3e-4a24-9ed8-9050362dec48/1D103191-F17F-4BDF-A9A9-3B2B09D7957D.jpeg)\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a81ff54-737c-43a5-9e45-544034839154/Untitled.png)\n\n### Lesson I learnt\n\n---\n\n1. left node is less than its parent node in binary search tree\n2. right node is greater than its parent node in birnary search tree\n","slug":"938-Range-Sum-of-BST","published":1,"updated":"2022-09-18T14:56:58.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1g0025qkccglf2g98l","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>binary search tree</li>\n<li>1 &lt;= Node.val &lt;= 105</li>\n<li>1 &lt;= low &lt;= high &lt;= 105</li>\n<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can use the character of binary search tree. we don’t need to check any nodes less than lower bound and greater than upper bound. if we check the first node and its value is less than lower bound then we need higher value so move to the right node. if we check the first node and its value is greater than upper bound then we need smaller value so move to the left node. if the value of current node is within the range then add the value then check left and right node because value of the child nodes can be without the range as well.  but if valud of child node is null then we can return 0 since its doesn’t need to added. then we can simply pass the added value to parent node.</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rangeSumBST</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val &lt; low) <span class=\"keyword\">return</span> rangeSumBST(root.right, low, high); <span class=\"comment\">// low 보다 작은 노드는 갈 필요가 없다. 그러니 오른쪽 노드만 살펴보면 됨</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val &gt; high) <span class=\"keyword\">return</span> rangeSumBST(root.left, low, high); <span class=\"comment\">// high 보다 큰 노드는 갈 필요가 없다. 그러니 왼쪽 노드만 살펴보면 됨</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ae21bc5-4c3e-4a24-9ed8-9050362dec48/1D103191-F17F-4BDF-A9A9-3B2B09D7957D.jpeg\" alt=\"1D103191-F17F-4BDF-A9A9-3B2B09D7957D.jpeg\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a81ff54-737c-43a5-9e45-544034839154/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"lesson-i-learnt\">Lesson I learnt</span></h3>\n<hr>\n<ol>\n<li>left node is less than its parent node in binary search tree</li>\n<li>right node is greater than its parent node in birnary search tree</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>binary search tree</li>\n<li>1 &lt;= Node.val &lt;= 105</li>\n<li>1 &lt;= low &lt;= high &lt;= 105</li>\n<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can use the character of binary search tree. we don’t need to check any nodes less than lower bound and greater than upper bound. if we check the first node and its value is less than lower bound then we need higher value so move to the right node. if we check the first node and its value is greater than upper bound then we need smaller value so move to the left node. if the value of current node is within the range then add the value then check left and right node because value of the child nodes can be without the range as well.  but if valud of child node is null then we can return 0 since its doesn’t need to added. then we can simply pass the added value to parent node.</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rangeSumBST</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val &lt; low) <span class=\"keyword\">return</span> rangeSumBST(root.right, low, high); <span class=\"comment\">// low 보다 작은 노드는 갈 필요가 없다. 그러니 오른쪽 노드만 살펴보면 됨</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val &gt; high) <span class=\"keyword\">return</span> rangeSumBST(root.left, low, high); <span class=\"comment\">// high 보다 큰 노드는 갈 필요가 없다. 그러니 왼쪽 노드만 살펴보면 됨</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ae21bc5-4c3e-4a24-9ed8-9050362dec48/1D103191-F17F-4BDF-A9A9-3B2B09D7957D.jpeg\" alt=\"1D103191-F17F-4BDF-A9A9-3B2B09D7957D.jpeg\"></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a81ff54-737c-43a5-9e45-544034839154/Untitled.png\" alt=\"Untitled\"></p>\n<h3>Lesson I learnt</h3>\n<hr>\n<ol>\n<li>left node is less than its parent node in binary search tree</li>\n<li>right node is greater than its parent node in birnary search tree</li>\n</ol>\n"},{"title":"[Hexo] Theme BeanTech","catalog":true,"date":"2017-03-18T01:51:24.000Z","subtitle":"This is hexo theme Demo.","header-img":"Demo.png","catagories":["Hexo"],"_content":"> Ported Theme of [Hux Blog](https://github.com/Huxpro/huxpro.github.io), Thank [Huxpro](https://github.com/Huxpro) for designing such a flawless theme.\n> \n> This BeanTech theme created by [YuHsuan](http://beantech.org) modified from the original Porter [Kaijun](http://kaijun.rocks/hexo-theme-huxblog/)\n\n# [Live Demo](http://beantech.org)\n---\n![BeanTech Desktop](http://beantech.org/img/beantech-desktop.png)\n\n# Usage\n---\nI publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!\n\nLet's begin!!!\n\n## Init\n---\n```bash\ngit clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech\ncd hexo-beantech\nnpm install\n```\n\n## Modify\n---\nModify `_config.yml` file with your own info.\nEspecially the section:\n### Deployment\nReplace to your own repo!\n```yml\ndeploy:\n  type: git\n  repo: https://github.com/<yourAccount>/<repo>\n  branch: <your-branch>\n```\n\n### Sidebar settings\nCopy your avatar image to `<root>/img/` and modify the `_config.yml`:\n```yml\nsidebar: true    # whether or not using Sidebar.\nsidebar-about-description: \"<your description>\"\nsidebar-avatar: img/<your avatar path>\n```\nand activate your personal widget you like\n```yml\nwidgets:         # here are widget you can use, you can comment out\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n- category\n```\nif you want to add sidebar widget, please add at `layout/_widget`.\n### Signature Setup\nCopy your signature image to `<root>/img/signature` and modify the `_config.yml`:\n```yml\nsignature: true   # show signature\nsignature-img: img/signature/<your-signature-ID>\n```\n### Go to top icon Setup\nMy icon is using iron man, you can change to your own icon at `css/image`.\n\n### Post tag\nYou can decide to show post tags or not.\n```yml\nhome_posts_tag: true\n```\n![home_posts_tag-true](home_posts_tag-true.png)\n```yml\nhome_posts_tag: false\n```\n![home_posts_tag-false](home_posts_tag-false.png)\n\n### Markdown render\nMy markdown render engine plugin is [hexo-renderer-markdown-it](https://github.com/celsomiranda/hexo-renderer-markdown-it).\n```yml\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: '“”‘’'\n```\nand if you want to change the header anchor 'ℬ', you can go to `layout/post.ejs` to change it.\n```javascript\nasync(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function(){\n        anchors.options = {\n          visible: 'hover',\n          placement: 'left',\n          icon: ℬ // this is the header anchor \"unicode\" icon\n        };\n```\n\n## Hexo Basics\n---\nSome hexo command:\n```bash\nhexo new post \"<post name>\" # you can change post to another layout if you want\nhexo clean && hexo generate # generate the static file\nhexo server # run hexo in local environment\nhexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!\n```\n\n# Have fun ^_^ \n---\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n\nPlease <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\">Follow</a> would also be appreciated!\nPeace!\n","source":"_posts/hexo-theme-beantech.md","raw":"---\ntitle: \"[Hexo] Theme BeanTech\"\ncatalog: true\ndate: 2017-03-18 10:51:24\nsubtitle: \"This is hexo theme Demo.\"\nheader-img: \"Demo.png\"\ntags:\n- Hexo\n- Blog\ncatagories:\n- Hexo\n---\n> Ported Theme of [Hux Blog](https://github.com/Huxpro/huxpro.github.io), Thank [Huxpro](https://github.com/Huxpro) for designing such a flawless theme.\n> \n> This BeanTech theme created by [YuHsuan](http://beantech.org) modified from the original Porter [Kaijun](http://kaijun.rocks/hexo-theme-huxblog/)\n\n# [Live Demo](http://beantech.org)\n---\n![BeanTech Desktop](http://beantech.org/img/beantech-desktop.png)\n\n# Usage\n---\nI publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!\n\nLet's begin!!!\n\n## Init\n---\n```bash\ngit clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech\ncd hexo-beantech\nnpm install\n```\n\n## Modify\n---\nModify `_config.yml` file with your own info.\nEspecially the section:\n### Deployment\nReplace to your own repo!\n```yml\ndeploy:\n  type: git\n  repo: https://github.com/<yourAccount>/<repo>\n  branch: <your-branch>\n```\n\n### Sidebar settings\nCopy your avatar image to `<root>/img/` and modify the `_config.yml`:\n```yml\nsidebar: true    # whether or not using Sidebar.\nsidebar-about-description: \"<your description>\"\nsidebar-avatar: img/<your avatar path>\n```\nand activate your personal widget you like\n```yml\nwidgets:         # here are widget you can use, you can comment out\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n- category\n```\nif you want to add sidebar widget, please add at `layout/_widget`.\n### Signature Setup\nCopy your signature image to `<root>/img/signature` and modify the `_config.yml`:\n```yml\nsignature: true   # show signature\nsignature-img: img/signature/<your-signature-ID>\n```\n### Go to top icon Setup\nMy icon is using iron man, you can change to your own icon at `css/image`.\n\n### Post tag\nYou can decide to show post tags or not.\n```yml\nhome_posts_tag: true\n```\n![home_posts_tag-true](home_posts_tag-true.png)\n```yml\nhome_posts_tag: false\n```\n![home_posts_tag-false](home_posts_tag-false.png)\n\n### Markdown render\nMy markdown render engine plugin is [hexo-renderer-markdown-it](https://github.com/celsomiranda/hexo-renderer-markdown-it).\n```yml\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: '“”‘’'\n```\nand if you want to change the header anchor 'ℬ', you can go to `layout/post.ejs` to change it.\n```javascript\nasync(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function(){\n        anchors.options = {\n          visible: 'hover',\n          placement: 'left',\n          icon: ℬ // this is the header anchor \"unicode\" icon\n        };\n```\n\n## Hexo Basics\n---\nSome hexo command:\n```bash\nhexo new post \"<post name>\" # you can change post to another layout if you want\nhexo clean && hexo generate # generate the static file\nhexo server # run hexo in local environment\nhexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!\n```\n\n# Have fun ^_^ \n---\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n\nPlease <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\">Follow</a> would also be appreciated!\nPeace!\n","slug":"hexo-theme-beantech","published":1,"updated":"2022-08-20T14:55:07.561Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1g0026qkcc0zwxfk48","content":"<blockquote>\n<p>Ported Theme of <a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"noopener\">Hux Blog</a>, Thank <a href=\"https://github.com/Huxpro\" target=\"_blank\" rel=\"noopener\">Huxpro</a> for designing such a flawless theme.</p>\n<p>This BeanTech theme created by <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> modified from the original Porter <a href=\"http://kaijun.rocks/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">Kaijun</a></p>\n</blockquote>\n<h1><span id=\"live-demo\"></span></h1>\n<hr>\n<p><img src=\"http://beantech.org/img/beantech-desktop.png\" alt=\"BeanTech Desktop\"></p>\n<h1><span id=\"usage\">Usage</span></h1>\n<hr>\n<p>I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!</p>\n<p>Let’s begin!!!</p>\n<h2><span id=\"init\">Init</span></h2>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-beantech</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h2><span id=\"modify\">Modify</span></h2>\n<hr>\n<p>Modify <code>_config.yml</code> file with your own info.<br>\nEspecially the section:</p>\n<h3><span id=\"deployment\">Deployment</span></h3>\n<p>Replace to your own repo!</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"sidebar-settings\">Sidebar settings</span></h3>\n<p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>    <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"&lt;your description&gt;\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">img/&lt;your</span> <span class=\"string\">avatar</span> <span class=\"string\">path&gt;</span></span><br></pre></td></tr></table></figure>\n<p>and activate your personal widget you like</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">widgets:</span>         <span class=\"comment\"># here are widget you can use, you can comment out</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></span><br></pre></td></tr></table></figure>\n<p>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p>\n<h3><span id=\"signature-setup\">Signature Setup</span></h3>\n<p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">signature:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># show signature</span></span><br><span class=\"line\"><span class=\"attr\">signature-img:</span> <span class=\"string\">img/signature/&lt;your-signature-ID&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"go-to-top-icon-setup\">Go to top icon Setup</span></h3>\n<p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p>\n<h3><span id=\"post-tag\">Post tag</span></h3>\n<p>You can decide to show post tags or not.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-true.png\" alt=\"home_posts_tag-true\"></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-false.png\" alt=\"home_posts_tag-false\"></p>\n<h3><span id=\"markdown-render\">Markdown render</span></h3>\n<p>My markdown render engine plugin is <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a>.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Markdown-it config</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class=\"line\"><span class=\"attr\">markdown:</span></span><br><span class=\"line\">  <span class=\"attr\">render:</span></span><br><span class=\"line\">    <span class=\"attr\">html:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">xhtmlOut:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">breaks:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">linkify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">typographer:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">quotes:</span> <span class=\"string\">'“”‘’'</span></span><br></pre></td></tr></table></figure>\n<p>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"string\">\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        anchors.options = &#123;</span><br><span class=\"line\">          visible: <span class=\"string\">'hover'</span>,</span><br><span class=\"line\">          placement: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">          icon: ℬ <span class=\"comment\">// this is the header anchor \"unicode\" icon</span></span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"hexo-basics\">Hexo Basics</span></h2>\n<hr>\n<p>Some hexo command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post <span class=\"string\">\"&lt;post name&gt;\"</span> <span class=\"comment\"># you can change post to another layout if you want</span></span><br><span class=\"line\">hexo clean &amp;&amp; hexo generate <span class=\"comment\"># generate the static file</span></span><br><span class=\"line\">hexo server <span class=\"comment\"># run hexo in local environment</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\"># hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"have-fun-_\">Have fun ^_^</span></h1>\n<hr>\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n<p>Please <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Ported Theme of <a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"noopener\">Hux Blog</a>, Thank <a href=\"https://github.com/Huxpro\" target=\"_blank\" rel=\"noopener\">Huxpro</a> for designing such a flawless theme.</p>\n<p>This BeanTech theme created by <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> modified from the original Porter <a href=\"http://kaijun.rocks/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">Kaijun</a></p>\n</blockquote>\n<h1><a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">Live Demo</a></h1>\n<hr>\n<p><img src=\"http://beantech.org/img/beantech-desktop.png\" alt=\"BeanTech Desktop\"></p>\n<h1>Usage</h1>\n<hr>\n<p>I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!</p>\n<p>Let’s begin!!!</p>\n<h2>Init</h2>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-beantech</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h2>Modify</h2>\n<hr>\n<p>Modify <code>_config.yml</code> file with your own info.<br>\nEspecially the section:</p>\n<h3>Deployment</h3>\n<p>Replace to your own repo!</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>Sidebar settings</h3>\n<p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>    <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"&lt;your description&gt;\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">img/&lt;your</span> <span class=\"string\">avatar</span> <span class=\"string\">path&gt;</span></span><br></pre></td></tr></table></figure>\n<p>and activate your personal widget you like</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">widgets:</span>         <span class=\"comment\"># here are widget you can use, you can comment out</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></span><br></pre></td></tr></table></figure>\n<p>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p>\n<h3>Signature Setup</h3>\n<p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">signature:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># show signature</span></span><br><span class=\"line\"><span class=\"attr\">signature-img:</span> <span class=\"string\">img/signature/&lt;your-signature-ID&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>Go to top icon Setup</h3>\n<p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p>\n<h3>Post tag</h3>\n<p>You can decide to show post tags or not.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-true.png\" alt=\"home_posts_tag-true\"></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-false.png\" alt=\"home_posts_tag-false\"></p>\n<h3>Markdown render</h3>\n<p>My markdown render engine plugin is <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a>.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Markdown-it config</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class=\"line\"><span class=\"attr\">markdown:</span></span><br><span class=\"line\">  <span class=\"attr\">render:</span></span><br><span class=\"line\">    <span class=\"attr\">html:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">xhtmlOut:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">breaks:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">linkify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">typographer:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">quotes:</span> <span class=\"string\">'“”‘’'</span></span><br></pre></td></tr></table></figure>\n<p>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"string\">\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        anchors.options = &#123;</span><br><span class=\"line\">          visible: <span class=\"string\">'hover'</span>,</span><br><span class=\"line\">          placement: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">          icon: ℬ <span class=\"comment\">// this is the header anchor \"unicode\" icon</span></span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h2>Hexo Basics</h2>\n<hr>\n<p>Some hexo command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post <span class=\"string\">\"&lt;post name&gt;\"</span> <span class=\"comment\"># you can change post to another layout if you want</span></span><br><span class=\"line\">hexo clean &amp;&amp; hexo generate <span class=\"comment\"># generate the static file</span></span><br><span class=\"line\">hexo server <span class=\"comment\"># run hexo in local environment</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\"># hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</span></span><br></pre></td></tr></table></figure>\n<h1>Have fun ^_^</h1>\n<hr>\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n<p>Please <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n"},{"title":"test","catalog":true,"date":"2022-09-22T09:08:54.000Z","subtitle":null,"header-img":null,"_content":"\n## Tag test\n\n","source":"_posts/test.md","raw":"---\ntitle: test\ncatalog: true\ndate: 2022-09-22 18:08:54\nsubtitle:\nheader-img:\ntags: tag \n---\n\n## Tag test\n\n","slug":"test","published":1,"updated":"2022-10-30T13:18:42.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1h0027qkcci4poe7nb","content":"<h2><span id=\"tag-test\">Tag test</span></h2>\n","site":{"data":{}},"excerpt":"","more":"<h2>Tag test</h2>\n"},{"title":"새로운 포스트","catalog":true,"date":"2022-08-22T14:51:45.000Z","subtitle":null,"header-img":null,"_content":"\n새로운 포스트\n\n# 제목 1\n## 제목 2\n### 제목 3\n\n테이블은...?\n\n\n안녕|하세요|이건\n\n\n\n![img.png](img.png)\n","source":"_posts/새로운-포스트.md","raw":"---\ntitle: 새로운 포스트\ncatalog: true\ndate: 2022-08-22 23:51:45\nsubtitle:\nheader-img:\ntags:\n---\n\n새로운 포스트\n\n# 제목 1\n## 제목 2\n### 제목 3\n\n테이블은...?\n\n\n안녕|하세요|이건\n\n\n\n![img.png](img.png)\n","slug":"새로운-포스트","published":1,"updated":"2022-08-31T09:44:15.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1l0029qkcc15hcv81m","content":"<p>새로운 포스트</p>\n<h1><span id=\"제목-1\">제목 1</span></h1>\n<h2><span id=\"제목-2\">제목 2</span></h2>\n<h3><span id=\"제목-3\">제목 3</span></h3>\n<p>테이블은…?</p>\n<p>안녕|하세요|이건</p>\n<p><img src=\"img.png\" alt=\"img.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>새로운 포스트</p>\n<h1>제목 1</h1>\n<h2>제목 2</h2>\n<h3>제목 3</h3>\n<p>테이블은…?</p>\n<p>안녕|하세요|이건</p>\n<p><img src=\"img.png\" alt=\"img.png\"></p>\n"},{"title":"9월 2일 새로운 컨텐츠","catalog":true,"date":"2022-09-02T13:38:26.000Z","subtitle":null,"header-img":null,"_content":"","source":"_posts/9월-2일-새로운-컨텐츠.md","raw":"---\ntitle: 9월 2일 새로운 컨텐츠\ncatalog: true\ndate: 2022-09-02 22:38:26\nsubtitle:\nheader-img:\ntags:\n---\n","slug":"9월-2일-새로운-컨텐츠","published":1,"updated":"2022-09-02T13:38:26.079Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1m002aqkccymyx4ke7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"98. Validate Binary Search Tree","catalog":true,"date":"2022-10-04T14:08:59.000Z","subtitle":null,"header-img":null,"_content":"## Conditions\n\n---\n\n- Given the `root` of a binary tree\n- *if it is a valid binary search tree (BST)*\n- -2^31 <= Node.val <= 2^31 - 1\n\n## Solve by hands first\n\n---\n\nwe can simply compare left and right node to current node\n\n```java\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        if(root == null) return true;\n        if(root.right != null && root.val >= root.right.val) return false;\n        if(root.left != null && root.val <= root.left.val) return false;\n        \n        if(root.left == null && root.right == null) return true;\n        \n        return isValidBST(root.left) && isValidBST(root.right);\n    }\n}\n```\n\nThe problem is how to remember the previous parent node. **it means we have to track the history of parent node**\n\n![32526D92-787F-48DC-8F8C-D7832A9B0846.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aeacdbef-d991-40eb-9c4a-e85018e64187/32526D92-787F-48DC-8F8C-D7832A9B0846.jpeg)\n\nwe can keep tracking of parent value in two cases\n\n1. move to left node\n    - left node is always less than parent node\n    - so we update the upper bound to parent node\n    - Once set up the upper bound, whenever it move to right node, **it will stay upper bound forever!**\n2. move to right node\n    - right node is always greater than parent node\n    - so we update the lower bound to parent node\n    - Once set up the lower bound, whenever it move to left node, **it will stay lower bound forever!**\n\nin a nut shell, the upper and lower bound switch when it move to the other way around (left → right, right → left)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        return valid(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    private boolean valid(TreeNode root, long left, long right) {\n        if(root == null) return true;\n        if(root.val >= right || root.val <= left) return false;\n        \n        return valid(root.left, left, root.val) && valid(root.right, root.val, right);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0336171d-a8fb-4c68-a31f-fe4fe4b419bf/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Max int value in java is 2^31-1. but in this case, upper bound can be 2^31-1 and if it’s equals to max int then it will return false. so we have to use Long.MAX_VALUE\n    \n    ```java\n    if(root.val >= right || root.val <= left) return false;\n    ```\n","source":"_posts/98-Validate-Binary-Search-Tree.md","raw":"---\ntitle: \"98.\\_Validate Binary Search Tree\"\ncatalog: true\ndate: 2022-10-04 23:08:59\nsubtitle:\nheader-img:\ntags:\n---\n## Conditions\n\n---\n\n- Given the `root` of a binary tree\n- *if it is a valid binary search tree (BST)*\n- -2^31 <= Node.val <= 2^31 - 1\n\n## Solve by hands first\n\n---\n\nwe can simply compare left and right node to current node\n\n```java\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        if(root == null) return true;\n        if(root.right != null && root.val >= root.right.val) return false;\n        if(root.left != null && root.val <= root.left.val) return false;\n        \n        if(root.left == null && root.right == null) return true;\n        \n        return isValidBST(root.left) && isValidBST(root.right);\n    }\n}\n```\n\nThe problem is how to remember the previous parent node. **it means we have to track the history of parent node**\n\n![32526D92-787F-48DC-8F8C-D7832A9B0846.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aeacdbef-d991-40eb-9c4a-e85018e64187/32526D92-787F-48DC-8F8C-D7832A9B0846.jpeg)\n\nwe can keep tracking of parent value in two cases\n\n1. move to left node\n    - left node is always less than parent node\n    - so we update the upper bound to parent node\n    - Once set up the upper bound, whenever it move to right node, **it will stay upper bound forever!**\n2. move to right node\n    - right node is always greater than parent node\n    - so we update the lower bound to parent node\n    - Once set up the lower bound, whenever it move to left node, **it will stay lower bound forever!**\n\nin a nut shell, the upper and lower bound switch when it move to the other way around (left → right, right → left)\n\n## Solution\n\n---\n\n```java\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        return valid(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    private boolean valid(TreeNode root, long left, long right) {\n        if(root == null) return true;\n        if(root.val >= right || root.val <= left) return false;\n        \n        return valid(root.left, left, root.val) && valid(root.right, root.val, right);\n    }\n}\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0336171d-a8fb-4c68-a31f-fe4fe4b419bf/Untitled.png)\n\n## Lesson I learnt\n\n---\n\n1. Max int value in java is 2^31-1. but in this case, upper bound can be 2^31-1 and if it’s equals to max int then it will return false. so we have to use Long.MAX_VALUE\n    \n    ```java\n    if(root.val >= right || root.val <= left) return false;\n    ```\n","slug":"98-Validate-Binary-Search-Tree","published":1,"updated":"2022-10-04T14:09:12.458Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1m002bqkcc9hodvwtm","content":"<h2><span id=\"conditions\">Conditions</span></h2>\n<hr>\n<ul>\n<li>Given the <code>root</code> of a binary tree</li>\n<li><em>if it is a valid binary search tree (BST)</em></li>\n<li>-2^31 &lt;= Node.val &lt;= 2^31 - 1</li>\n</ul>\n<h2><span id=\"solve-by-hands-first\">Solve by hands first</span></h2>\n<hr>\n<p>we can simply compare left and right node to current node</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.right != <span class=\"keyword\">null</span> &amp;&amp; root.val &gt;= root.right.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left != <span class=\"keyword\">null</span> &amp;&amp; root.val &lt;= root.left.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left == <span class=\"keyword\">null</span> &amp;&amp; root.right == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> isValidBST(root.left) &amp;&amp; isValidBST(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The problem is how to remember the previous parent node. <strong>it means we have to track the history of parent node</strong></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aeacdbef-d991-40eb-9c4a-e85018e64187/32526D92-787F-48DC-8F8C-D7832A9B0846.jpeg\" alt=\"32526D92-787F-48DC-8F8C-D7832A9B0846.jpeg\"></p>\n<p>we can keep tracking of parent value in two cases</p>\n<ol>\n<li>move to left node\n<ul>\n<li>left node is always less than parent node</li>\n<li>so we update the upper bound to parent node</li>\n<li>Once set up the upper bound, whenever it move to right node, <strong>it will stay upper bound forever!</strong></li>\n</ul>\n</li>\n<li>move to right node\n<ul>\n<li>right node is always greater than parent node</li>\n<li>so we update the lower bound to parent node</li>\n<li>Once set up the lower bound, whenever it move to left node, <strong>it will stay lower bound forever!</strong></li>\n</ul>\n</li>\n</ol>\n<p>in a nut shell, the upper and lower bound switch when it move to the other way around (left → right, right → left)</p>\n<h2><span id=\"solution\">Solution</span></h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> valid(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">valid</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">long</span> left, <span class=\"keyword\">long</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val &gt;= right || root.val &lt;= left) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> valid(root.left, left, root.val) &amp;&amp; valid(root.right, root.val, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0336171d-a8fb-4c68-a31f-fe4fe4b419bf/Untitled.png\" alt=\"Untitled\"></p>\n<h2><span id=\"lesson-i-learnt\">Lesson I learnt</span></h2>\n<hr>\n<ol>\n<li>\n<p>Max int value in java is 2^31-1. but in this case, upper bound can be 2^31-1 and if it’s equals to max int then it will return false. so we have to use Long.MAX_VALUE</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(root.val &gt;= right || root.val &lt;= left) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Conditions</h2>\n<hr>\n<ul>\n<li>Given the <code>root</code> of a binary tree</li>\n<li><em>if it is a valid binary search tree (BST)</em></li>\n<li>-2^31 &lt;= Node.val &lt;= 2^31 - 1</li>\n</ul>\n<h2>Solve by hands first</h2>\n<hr>\n<p>we can simply compare left and right node to current node</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.right != <span class=\"keyword\">null</span> &amp;&amp; root.val &gt;= root.right.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left != <span class=\"keyword\">null</span> &amp;&amp; root.val &lt;= root.left.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left == <span class=\"keyword\">null</span> &amp;&amp; root.right == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> isValidBST(root.left) &amp;&amp; isValidBST(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The problem is how to remember the previous parent node. <strong>it means we have to track the history of parent node</strong></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aeacdbef-d991-40eb-9c4a-e85018e64187/32526D92-787F-48DC-8F8C-D7832A9B0846.jpeg\" alt=\"32526D92-787F-48DC-8F8C-D7832A9B0846.jpeg\"></p>\n<p>we can keep tracking of parent value in two cases</p>\n<ol>\n<li>move to left node\n<ul>\n<li>left node is always less than parent node</li>\n<li>so we update the upper bound to parent node</li>\n<li>Once set up the upper bound, whenever it move to right node, <strong>it will stay upper bound forever!</strong></li>\n</ul>\n</li>\n<li>move to right node\n<ul>\n<li>right node is always greater than parent node</li>\n<li>so we update the lower bound to parent node</li>\n<li>Once set up the lower bound, whenever it move to left node, <strong>it will stay lower bound forever!</strong></li>\n</ul>\n</li>\n</ol>\n<p>in a nut shell, the upper and lower bound switch when it move to the other way around (left → right, right → left)</p>\n<h2>Solution</h2>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> valid(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">valid</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">long</span> left, <span class=\"keyword\">long</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val &gt;= right || root.val &lt;= left) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> valid(root.left, left, root.val) &amp;&amp; valid(root.right, root.val, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0336171d-a8fb-4c68-a31f-fe4fe4b419bf/Untitled.png\" alt=\"Untitled\"></p>\n<h2>Lesson I learnt</h2>\n<hr>\n<ol>\n<li>\n<p>Max int value in java is 2^31-1. but in this case, upper bound can be 2^31-1 and if it’s equals to max int then it will return false. so we have to use Long.MAX_VALUE</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(root.val &gt;= right || root.val &lt;= left) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"11111. test","catalog":true,"date":"2022-10-12T12:06:43.000Z","subtitle":null,"header-img":null,"_content":"\n# Title\nalgorithm tags test page\n\n\n","source":"_posts/11111-test.md","raw":"---\ntitle: 11111. test\ncatalog: true\ndate: 2022-10-12 21:06:43\nsubtitle:\nheader-img:\ntags: algorithm\n---\n\n# Title\nalgorithm tags test page\n\n\n","slug":"11111-test","published":1,"updated":"2022-10-13T14:43:19.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1m002dqkccm6vnej8d","content":"<h1><span id=\"title\">Title</span></h1>\n<p>algorithm tags test page</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Title</h1>\n<p>algorithm tags test page</p>\n"},{"title":"1048. Longest String Chain","catalog":true,"date":"2022-10-26T12:20:43.000Z","subtitle":null,"header-img":null,"_content":"### **Requirements**\n\n---\n\n- words consists of lowercase english letters\n- return the length of the longest possible predecessor words chain\n\n### **Edge cases**\n\n---\n\n- [a,b,bc,bcd,da,bcad] → [b,bc,bcd,bcad]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nWe can start with Brute force way first. first things first, sort the array by the length of word in ascending order. because to find the the longest predecessor word chain, the length of word has to be incremented. loop through array and check if there was predecessor in previous loop. in order to find the predecessor we need to store the predecessors in the data structure. I choose the map to store word as key and the length of the longest possible word chain as value. all we need to do is finding a possbile predecessor in each word. we can find the previous length of the longest possible word chain with current word’s combination of predecessor (it’s dynamic programming approach actually) \n\n```java\nMap<String,Integer> dp = new HashMap();\nArrays.sort(words, (a, b) -> a.length() - b.length());\nint res = 0;\nfor(String word : words) {\n\tint max = 0;\n\tfor(int i = 0; i < word.length(); i++) {\n\t\tString prev = word.substring(0, i) + word.substring(i + 1);\n\t\tmax = Math.max(max, dp.getOrDefault(prev, 0) + 1);\n\t}\n\tdp.put(word, max);\n\tres = Math.max(res, max);\n}\nreturn res;\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int longestStrChain(String[] words) {\n        Map<String,Integer> dp = new HashMap();\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        int res = 0;\n        for(String word : words) {\n            int max = 0;\n            for(int i = 0; i < word.length(); i++) {\n                String prev = word.substring(0, i) + word.substring(i + 1);\n                max = Math.max(max, dp.getOrDefault(prev, 0) + 1);\n            }\n            dp.put(word, max);\n            res = Math.max(res, max);\n        }\n        return res;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b6a625e-4354-44ef-82ee-f8e18ebeed1a/Untitled.png)\n\n### What I learned\n\n---\n\n1. This problem tought me the importance of the brute force first before coming up with optimized solution first. because there is case that no further possible optimization solution. then we can go back to brute force way instead. it helps us to feel ensecure about having at least one right solution\n2. If you can store any sub problem/answer and bring it out for current problem, then its called dynamic programing approach\n\n```java\nMap<String, Integer> dp = new HashMap<>();\n\nfor (String word : words) {\n    for (int i = 0; i < word.length(); ++i) {\n        best = Math.max(best, dp.getOrDefault(prev, 0) + 1); // find the sub problem/answer from the cache\n    }\n    dp.put(word, best); // store current sub problem/answer\n}\n```\n","source":"_posts/1048-Longest-String-Chain.md","raw":"---\ntitle: \"1048.\\_Longest String Chain\"\ncatalog: true\ndate: 2022-10-26 21:20:43\nsubtitle:\nheader-img:\ntags:\n---\n### **Requirements**\n\n---\n\n- words consists of lowercase english letters\n- return the length of the longest possible predecessor words chain\n\n### **Edge cases**\n\n---\n\n- [a,b,bc,bcd,da,bcad] → [b,bc,bcd,bcad]\n\n### **Brute force approach (Discussion + Complexity)**\n\n---\n\nWe can start with Brute force way first. first things first, sort the array by the length of word in ascending order. because to find the the longest predecessor word chain, the length of word has to be incremented. loop through array and check if there was predecessor in previous loop. in order to find the predecessor we need to store the predecessors in the data structure. I choose the map to store word as key and the length of the longest possible word chain as value. all we need to do is finding a possbile predecessor in each word. we can find the previous length of the longest possible word chain with current word’s combination of predecessor (it’s dynamic programming approach actually) \n\n```java\nMap<String,Integer> dp = new HashMap();\nArrays.sort(words, (a, b) -> a.length() - b.length());\nint res = 0;\nfor(String word : words) {\n\tint max = 0;\n\tfor(int i = 0; i < word.length(); i++) {\n\t\tString prev = word.substring(0, i) + word.substring(i + 1);\n\t\tmax = Math.max(max, dp.getOrDefault(prev, 0) + 1);\n\t}\n\tdp.put(word, max);\n\tres = Math.max(res, max);\n}\nreturn res;\n```\n\n### **Optimised approach (Discussion + Complexity) …X times**\n\n---\n\n### **Coding**\n\n---\n\n```java\nclass Solution {\n    public int longestStrChain(String[] words) {\n        Map<String,Integer> dp = new HashMap();\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        int res = 0;\n        for(String word : words) {\n            int max = 0;\n            for(int i = 0; i < word.length(); i++) {\n                String prev = word.substring(0, i) + word.substring(i + 1);\n                max = Math.max(max, dp.getOrDefault(prev, 0) + 1);\n            }\n            dp.put(word, max);\n            res = Math.max(res, max);\n        }\n        return res;\n    }\n}\n```\n\n### **Dry Run**\n\n---\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b6a625e-4354-44ef-82ee-f8e18ebeed1a/Untitled.png)\n\n### What I learned\n\n---\n\n1. This problem tought me the importance of the brute force first before coming up with optimized solution first. because there is case that no further possible optimization solution. then we can go back to brute force way instead. it helps us to feel ensecure about having at least one right solution\n2. If you can store any sub problem/answer and bring it out for current problem, then its called dynamic programing approach\n\n```java\nMap<String, Integer> dp = new HashMap<>();\n\nfor (String word : words) {\n    for (int i = 0; i < word.length(); ++i) {\n        best = Math.max(best, dp.getOrDefault(prev, 0) + 1); // find the sub problem/answer from the cache\n    }\n    dp.put(word, best); // store current sub problem/answer\n}\n```\n","slug":"1048-Longest-String-Chain","published":1,"updated":"2022-10-26T12:21:00.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9zaxc1m002eqkccqa9ky70q","content":"<h3><span id=\"requirements\"><strong>Requirements</strong></span></h3>\n<hr>\n<ul>\n<li>words consists of lowercase english letters</li>\n<li>return the length of the longest possible predecessor words chain</li>\n</ul>\n<h3><span id=\"edge-cases\"><strong>Edge cases</strong></span></h3>\n<hr>\n<ul>\n<li>[a,b,bc,bcd,da,bcad] → [b,bc,bcd,bcad]</li>\n</ul>\n<h3><span id=\"brute-force-approach-discussion-complexity\"><strong>Brute force approach (Discussion + Complexity)</strong></span></h3>\n<hr>\n<p>We can start with Brute force way first. first things first, sort the array by the length of word in ascending order. because to find the the longest predecessor word chain, the length of word has to be incremented. loop through array and check if there was predecessor in previous loop. in order to find the predecessor we need to store the predecessors in the data structure. I choose the map to store word as key and the length of the longest possible word chain as value. all we need to do is finding a possbile predecessor in each word. we can find the previous length of the longest possible word chain with current word’s combination of predecessor (it’s dynamic programming approach actually)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String,Integer&gt; dp = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">Arrays.sort(words, (a, b) -&gt; a.length() - b.length());</span><br><span class=\"line\"><span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(String word : words) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">\t\tString prev = word.substring(<span class=\"number\">0</span>, i) + word.substring(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tmax = Math.max(max, dp.getOrDefault(prev, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdp.put(word, max);</span><br><span class=\"line\">\tres = Math.max(res, max);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> res;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"optimised-approach-discussion-complexity-x-times\"><strong>Optimised approach (Discussion + Complexity) …X times</strong></span></h3>\n<hr>\n<h3><span id=\"coding\"><strong>Coding</strong></span></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestStrChain</span><span class=\"params\">(String[] words)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String,Integer&gt; dp = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        Arrays.sort(words, (a, b) -&gt; a.length() - b.length());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String word : words) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">                String prev = word.substring(<span class=\"number\">0</span>, i) + word.substring(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                max = Math.max(max, dp.getOrDefault(prev, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dp.put(word, max);</span><br><span class=\"line\">            res = Math.max(res, max);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dry-run\"><strong>Dry Run</strong></span></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b6a625e-4354-44ef-82ee-f8e18ebeed1a/Untitled.png\" alt=\"Untitled\"></p>\n<h3><span id=\"what-i-learned\">What I learned</span></h3>\n<hr>\n<ol>\n<li>This problem tought me the importance of the brute force first before coming up with optimized solution first. because there is case that no further possible optimization solution. then we can go back to brute force way instead. it helps us to feel ensecure about having at least one right solution</li>\n<li>If you can store any sub problem/answer and bring it out for current problem, then its called dynamic programing approach</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; dp = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String word : words) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); ++i) &#123;</span><br><span class=\"line\">        best = Math.max(best, dp.getOrDefault(prev, <span class=\"number\">0</span>) + <span class=\"number\">1</span>); <span class=\"comment\">// find the sub problem/answer from the cache</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp.put(word, best); <span class=\"comment\">// store current sub problem/answer</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3><strong>Requirements</strong></h3>\n<hr>\n<ul>\n<li>words consists of lowercase english letters</li>\n<li>return the length of the longest possible predecessor words chain</li>\n</ul>\n<h3><strong>Edge cases</strong></h3>\n<hr>\n<ul>\n<li>[a,b,bc,bcd,da,bcad] → [b,bc,bcd,bcad]</li>\n</ul>\n<h3><strong>Brute force approach (Discussion + Complexity)</strong></h3>\n<hr>\n<p>We can start with Brute force way first. first things first, sort the array by the length of word in ascending order. because to find the the longest predecessor word chain, the length of word has to be incremented. loop through array and check if there was predecessor in previous loop. in order to find the predecessor we need to store the predecessors in the data structure. I choose the map to store word as key and the length of the longest possible word chain as value. all we need to do is finding a possbile predecessor in each word. we can find the previous length of the longest possible word chain with current word’s combination of predecessor (it’s dynamic programming approach actually)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String,Integer&gt; dp = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">Arrays.sort(words, (a, b) -&gt; a.length() - b.length());</span><br><span class=\"line\"><span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(String word : words) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">\t\tString prev = word.substring(<span class=\"number\">0</span>, i) + word.substring(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tmax = Math.max(max, dp.getOrDefault(prev, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdp.put(word, max);</span><br><span class=\"line\">\tres = Math.max(res, max);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> res;</span><br></pre></td></tr></table></figure>\n<h3><strong>Optimised approach (Discussion + Complexity) …X times</strong></h3>\n<hr>\n<h3><strong>Coding</strong></h3>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestStrChain</span><span class=\"params\">(String[] words)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String,Integer&gt; dp = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        Arrays.sort(words, (a, b) -&gt; a.length() - b.length());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String word : words) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">                String prev = word.substring(<span class=\"number\">0</span>, i) + word.substring(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                max = Math.max(max, dp.getOrDefault(prev, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dp.put(word, max);</span><br><span class=\"line\">            res = Math.max(res, max);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><strong>Dry Run</strong></h3>\n<hr>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9b6a625e-4354-44ef-82ee-f8e18ebeed1a/Untitled.png\" alt=\"Untitled\"></p>\n<h3>What I learned</h3>\n<hr>\n<ol>\n<li>This problem tought me the importance of the brute force first before coming up with optimized solution first. because there is case that no further possible optimization solution. then we can go back to brute force way instead. it helps us to feel ensecure about having at least one right solution</li>\n<li>If you can store any sub problem/answer and bring it out for current problem, then its called dynamic programing approach</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; dp = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String word : words) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); ++i) &#123;</span><br><span class=\"line\">        best = Math.max(best, dp.getOrDefault(prev, <span class=\"number\">0</span>) + <span class=\"number\">1</span>); <span class=\"comment\">// find the sub problem/answer from the cache</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp.put(word, best); <span class=\"comment\">// store current sub problem/answer</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","slug":"home_posts_tag-true.png","post":"cl9zaxc1g0026qkcc0zwxfk48","modified":1,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","slug":"Demo.png","post":"cl9zaxc1g0026qkcc0zwxfk48","modified":1,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","post":"cl9zaxc1g0026qkcc0zwxfk48","slug":"home_posts_tag-false.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cl9zaxc1g0026qkcc0zwxfk48","tag_id":"cl9zaxc1h0028qkccamky5ovv","_id":"cl9zaxc1n002gqkcclhec19jy"},{"post_id":"cl9zaxc1g0026qkcc0zwxfk48","tag_id":"cl9zaxc1m002cqkcc98psgqxc","_id":"cl9zaxc1n002hqkccf9zopbc5"},{"post_id":"cl9zaxc1h0027qkcci4poe7nb","tag_id":"cl9zaxc1n002fqkcckn3rw9ur","_id":"cl9zaxc1n002jqkccfverc1l6"},{"post_id":"cl9zaxc1m002dqkccm6vnej8d","tag_id":"cl9zaxc1n002iqkccyh3zf9mu","_id":"cl9zaxc1n002kqkccufhwzbvc"}],"Tag":[{"name":"Hexo","_id":"cl9zaxc1h0028qkccamky5ovv"},{"name":"Blog","_id":"cl9zaxc1m002cqkcc98psgqxc"},{"name":"tag","_id":"cl9zaxc1n002fqkcckn3rw9ur"},{"name":"algorithm","_id":"cl9zaxc1n002iqkccyh3zf9mu"}]}}